{"ast":null,"code":"/**\n * 配置、初始化、后期筛选前置\n * 处理多图\n * BaseDAG 只专注 DAG 布局算法\n */\nimport BaseDAG from './BaseDAG';\nimport { maxBy } from '../../Utils/utils';\nconst defaultDAGAIUConfig = {\n  isTransverse: false,\n  defaultNodeWidth: 180,\n  defaultNodeHeight: 50,\n  nodeAndNodeSpace: 40,\n  paddingLineSpace: 30,\n  levelSpace: 80,\n  margin: {\n    left: 180,\n    right: 180,\n    top: 50,\n    bottom: 50\n  },\n  padding: 200,\n  linkType: 'polyline',\n  DiyLine: () => {},\n  _isLinkMerge: true\n};\nconst emptyDAG = {\n  nodes: [],\n  links: [],\n  pos: {\n    width: 0,\n    height: 0\n  }\n};\n\nclass DAGAIU {\n  /** 默认配置项 */\n  constructor(DAGConfig = {}) {\n    this.config = defaultDAGAIUConfig;\n    this.config = { ...this.config,\n      // 横向布局时要尽量减小虚拟节点的高度\n      defaultVirtualNodeWidth: DAGConfig.isTransverse ? 0.1 : 180,\n      ...DAGConfig\n    };\n  } // 数据预处理，将节点与边信息提取出来，\n\n\n  _preprocess(data) {\n    // 节点去重\n    const nodeMap = new Map(); // 边去重\n\n    const linkMap = new Map(); // 去重节点列表\n\n    const nodes = []; // 去重边列表，不带自环\n\n    const links = []; // 自环边\n\n    const selfLinks = [];\n    data.forEach(node => {\n      // 去除重复节点\n      if (node && node.id && !nodeMap.has(node.id)) {\n        const newNode = {\n          id: node.id,\n          sourceLinks: [],\n          targetLinks: [],\n          type: 'real',\n          nodeWidth: this.config.isTransverse ? node.nodeHeight || this.config.defaultNodeHeight : node.nodeWidth || this.config.defaultNodeWidth,\n          nodeHeight: this.config.isTransverse ? node.nodeWidth || this.config.defaultNodeWidth : node.nodeHeight || this.config.defaultNodeHeight,\n          originInfo: node\n        };\n        const key = this.config.getNodeKey ? this.config.getNodeKey(node) : node.id;\n        nodeMap.set(key, newNode);\n        nodes.push(newNode);\n      }\n    });\n    data.forEach(node => {\n      if (node && node.id) {\n        [...node.downRelations, ...node.upRelations].forEach(relation => {\n          const {\n            sourceId,\n            targetId\n          } = relation;\n          const key = this.config.getLinkKey ? this.config.getLinkKey(relation) : `${sourceId}-${targetId}`;\n          const sourceNode = nodeMap.get(sourceId);\n          const targetNode = nodeMap.get(targetId); // 先确保节点均存在，连线不重复\n\n          if (sourceNode && targetNode && !linkMap.has(key)) {\n            const newRelation = {\n              source: sourceNode,\n              target: targetNode,\n              originInfo: relation,\n              isReverse: false\n            }; // 处理自环\n\n            if (sourceId === targetId) {\n              linkMap.set(key, newRelation);\n              selfLinks.push(newRelation);\n            } else {\n              linkMap.set(key, newRelation);\n              links.push(newRelation);\n              sourceNode.sourceLinks.push(newRelation);\n              targetNode.targetLinks.push(newRelation);\n            }\n          }\n        });\n      }\n    });\n    return {\n      nodes,\n      links,\n      selfLinks\n    };\n  }\n\n  _getDAG(data) {\n    const {\n      nodes,\n      links,\n      selfLinks\n    } = this._preprocess(data);\n\n    const {\n      defaultVirtualNodeWidth,\n      nodeAndNodeSpace,\n      paddingLineSpace,\n      levelSpace,\n      linkType,\n      DiyLine,\n      _isLinkMerge\n    } = this.config;\n    const dag = new BaseDAG({\n      nodes,\n      links,\n      selfLinks,\n      config: {\n        defaultVirtualNodeWidth,\n        nodeAndNodeSpace,\n        paddingLineSpace,\n        levelSpace,\n        linkType,\n        DiyLine,\n        _isLinkMerge\n      }\n    });\n    return dag;\n  }\n  /**\n   * 单个 DAG\n   * @param data\n   */\n\n\n  getSingleDAG(data) {\n    if (!data || !data.length) {\n      return emptyDAG;\n    } // 单图横向布局，本质为逆转竖向布局\n\n\n    if (this.config.isTransverse) {\n      const ans = this._getDAG(data).run().getOutput(this.config.margin.bottom, this.config.margin.left);\n\n      const width = ans.pos.width + this.config.margin.top + this.config.margin.bottom;\n      const height = ans.pos.height + this.config.margin.left + this.config.margin.right;\n      return {\n        nodes: ans.nodes.map(node => {\n          return { ...node,\n            nodeWidth: node.nodeHeight,\n            nodeHeight: node.nodeWidth,\n            view: {\n              x: node.view.y,\n              y: node.view.x\n            }\n          };\n        }),\n        links: ans.links.map(link => {\n          return { ...link,\n            pathPoint: link.path,\n            path: `${link.path.map((point, index) => {\n              if (index === 0) return `M${point.y},${point.x}`;\n              return `L${point.y},${point.x}`;\n            }).join(' ')}`\n          };\n        }),\n        pos: {\n          width: height,\n          height: width\n        }\n      };\n    }\n\n    const ans = this._getDAG(data).run().getOutput(this.config.margin.left, this.config.margin.top);\n\n    return { ...ans,\n      links: ans.links.map(link => {\n        return { ...link,\n          pathPoint: link.path,\n          path: `${link.path.map((point, index) => {\n            if (index === 0) return `M${point.x},${point.y}`;\n            return `L${point.x},${point.y}`;\n          }).join(' ')}`\n        };\n      }),\n      pos: {\n        width: ans.pos.width + this.config.margin.left + this.config.margin.right,\n        height: ans.pos.height + this.config.margin.top + this.config.margin.bottom\n      }\n    };\n  }\n  /**\n   * 多个DAG，可兼容单个 DAG\n   * @param data\n   */\n\n\n  getMultiDAG(data) {\n    if (!data || !data.length) {\n      return emptyDAG;\n    }\n\n    const nodesList = this._separateNodes(data); // 单个 DAG\n\n\n    if (nodesList.length === 1) {\n      return this.getSingleDAG(nodesList[0]);\n    } else {\n      const widthList = [];\n      const heightList = [];\n      const dagInstanceList = nodesList.map(nodes => {\n        const dag = this._getDAG(nodes).run();\n\n        const {\n          width,\n          height\n        } = dag.getSize();\n        widthList.push(width);\n        heightList.push(height);\n        return dag;\n      });\n\n      if (this.config.isTransverse) {\n        const height = maxBy(heightList, width => {\n          return width;\n        }) + this.config.margin.left + this.config.margin.right;\n        const width = widthList.reduce((pre, width, index) => {\n          if (index === 0) {\n            return pre + width;\n          }\n\n          return pre + width + this.config.padding;\n        }, 0) + this.config.margin.top + this.config.margin.bottom;\n        const result = dagInstanceList.reduce((pre, dag) => {\n          const {\n            addWidth\n          } = pre;\n          const {\n            height: curheight\n          } = dag.getSize();\n          const ans = dag.getOutput(addWidth, (height - curheight) / 2);\n          return {\n            nodes: [...pre.nodes, ...ans.nodes],\n            links: [...pre.links, ...ans.links],\n            addWidth: addWidth + this.config.padding + ans.pos.width\n          };\n        }, {\n          nodes: [],\n          links: [],\n          addWidth: this.config.margin.top\n        });\n        return {\n          nodes: result.nodes.map(node => {\n            return { ...node,\n              nodeWidth: node.nodeHeight,\n              nodeHeight: node.nodeWidth,\n              view: {\n                x: node.view.y,\n                y: node.view.x\n              }\n            };\n          }),\n          links: result.links.map(link => {\n            return { ...link,\n              pathPoint: link.path,\n              path: `${link.path.map((point, index) => {\n                if (index === 0) return `M${point.y},${point.x}`;\n                return `L${point.y},${point.x}`;\n              }).join(' ')}`\n            };\n          }),\n          pos: {\n            width: height,\n            height: width\n          }\n        };\n      }\n\n      const height = maxBy(heightList, height => {\n        return height;\n      }) + this.config.margin.top + this.config.margin.bottom;\n      const width = widthList.reduce((pre, width, index) => {\n        if (index === 0) {\n          return pre + width;\n        }\n\n        return pre + width + this.config.padding;\n      }, 0) + this.config.margin.left + this.config.margin.right;\n      const result = dagInstanceList.reduce((pre, dag, index) => {\n        const {\n          addWidth\n        } = pre;\n        const {\n          height: curheight\n        } = dag.getSize();\n        const ans = dag.getOutput(addWidth, (height - curheight) / 2);\n        return {\n          nodes: [...pre.nodes, ...ans.nodes],\n          links: [...pre.links, ...ans.links],\n          addWidth: addWidth + this.config.padding + ans.pos.width\n        };\n      }, {\n        nodes: [],\n        links: [],\n        addWidth: this.config.margin.left\n      });\n      return {\n        nodes: result.nodes,\n        links: result.links.map(link => {\n          return { ...link,\n            pathPoint: link.path,\n            path: `${link.path.map((point, index) => {\n              if (index === 0) return `M${point.x},${point.y}`;\n              return `L${point.x},${point.y}`;\n            }).join(' ')}`\n          };\n        }),\n        pos: {\n          width,\n          height\n        }\n      };\n    }\n  }\n\n  dfs(node, result, queueId, nodeMarkMap) {\n    /** 下游节点 */\n    [...node.upRelations, ...node.downRelations].forEach(link => {\n      const nodeId = link.targetId !== node.id ? link.targetId : link.sourceId;\n\n      if (nodeMarkMap.has(nodeId)) {\n        if (nodeMarkMap.get(nodeId).queueId === -1) {\n          const targetNode = nodeMarkMap.get(nodeId).node;\n          nodeMarkMap.set(nodeId, {\n            node: targetNode,\n            queueId\n          });\n          result.push(targetNode);\n          this.dfs(targetNode, result, queueId, nodeMarkMap);\n        } else {\n          /** 表示重复遍历 */\n          // if (nodeMarkMap.get(nodeId).queueId === queueId) { }\n          if (nodeMarkMap.get(nodeId).queueId !== queueId) {\n            throw new Error(`图数据异常, ${nodeId}，${node.id}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * 将 nodes 进行分离\n   * @param data\n   */\n\n\n  _separateNodes(data) {\n    const nodeMarkMap = new Map(); // 初始化 nodeMarkMap\n\n    data.forEach(node => {\n      if (!nodeMarkMap.has(node.id)) {\n        nodeMarkMap.set(node.id, {\n          node,\n          queueId: -1\n        });\n      }\n    });\n    const result = [];\n    let index = 0;\n    data.forEach(node => {\n      if (nodeMarkMap.get(node.id).queueId === -1) {\n        result[index] = [];\n        result[index].push(node);\n        const targetNode = nodeMarkMap.get(node.id).node;\n        nodeMarkMap.set(node.id, {\n          node: targetNode,\n          queueId: index\n        });\n        this.dfs(node, result[index], index, nodeMarkMap);\n        index++;\n      }\n    });\n    return result;\n  }\n\n}\n\nexport default DAGAIU;","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/DAG/DAGAIU.ts"],"names":["BaseDAG","maxBy","defaultDAGAIUConfig","isTransverse","defaultNodeWidth","defaultNodeHeight","nodeAndNodeSpace","paddingLineSpace","levelSpace","margin","left","right","top","bottom","padding","linkType","DiyLine","_isLinkMerge","emptyDAG","nodes","links","pos","width","height","DAGAIU","constructor","DAGConfig","config","defaultVirtualNodeWidth","_preprocess","data","nodeMap","Map","linkMap","selfLinks","forEach","node","id","has","newNode","sourceLinks","targetLinks","type","nodeWidth","nodeHeight","originInfo","key","getNodeKey","set","push","downRelations","upRelations","relation","sourceId","targetId","getLinkKey","sourceNode","get","targetNode","newRelation","source","target","isReverse","_getDAG","dag","getSingleDAG","length","ans","run","getOutput","map","view","x","y","link","pathPoint","path","point","index","join","getMultiDAG","nodesList","_separateNodes","widthList","heightList","dagInstanceList","getSize","reduce","pre","result","addWidth","curheight","dfs","queueId","nodeMarkMap","nodeId","Error"],"mappings":"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","sourcesContent":["/**\n * 配置、初始化、后期筛选前置\n * 处理多图\n * BaseDAG 只专注 DAG 布局算法\n */\n\nimport {\n  InputNode,\n  InputRelation,\n  OutputNode,\n  OutputRelation,\n  NodeId,\n  InternalUpGradeNode,\n  InternalUpGradeLink,\n  DAGAIUConfig,\n} from './types';\nimport BaseDAG from './BaseDAG';\nimport { maxBy } from '../../Utils/utils';\nimport { Point } from '../../Utils/graph';\n\nconst defaultDAGAIUConfig: DAGAIUConfig = {\n  isTransverse: false,\n  defaultNodeWidth: 180,\n  defaultNodeHeight: 50,\n  nodeAndNodeSpace: 40,\n  paddingLineSpace: 30,\n  levelSpace: 80,\n  margin: {\n    left: 180,\n    right: 180,\n    top: 50,\n    bottom: 50\n  },\n  padding: 200,\n  linkType: 'polyline',\n  DiyLine: () => { },\n  _isLinkMerge: true,\n};\n\nconst emptyDAG = {\n  nodes: [] as any,\n  links: [] as any,\n  pos: {\n    width: 0,\n    height: 0\n  }\n};\n\nclass DAGAIU<Node extends InputNode<Relation>, Relation extends InputRelation> {\n  /** 默认配置项 */\n  private config: DAGAIUConfig = defaultDAGAIUConfig;\n\n  constructor(DAGConfig: DAGAIUConfig = {}) {\n    this.config = {\n      ...this.config,\n      // 横向布局时要尽量减小虚拟节点的高度\n      defaultVirtualNodeWidth: DAGConfig.isTransverse ? 0.1 : 180,\n      ...DAGConfig,\n    };\n  }\n\n  // 数据预处理，将节点与边信息提取出来，\n  _preprocess(data: Node[]) {\n    // 节点去重\n    const nodeMap = new Map<NodeId, InternalUpGradeNode<Node, Relation>>();\n    // 边去重\n    const linkMap = new Map<NodeId, InternalUpGradeLink<Node, Relation>>();\n    // 去重节点列表\n    const nodes: InternalUpGradeNode<Node, Relation>[] = [];\n    // 去重边列表，不带自环\n    const links: InternalUpGradeLink<Node, Relation>[] = [];\n    // 自环边\n    const selfLinks: InternalUpGradeLink<Node, Relation>[] = [];\n    data.forEach(node => {\n      // 去除重复节点\n      if (node && node.id && !nodeMap.has(node.id)) {\n        const newNode: InternalUpGradeNode<Node, Relation> = {\n          id: node.id,\n          sourceLinks: [],\n          targetLinks: [],\n          type: 'real',\n          nodeWidth: this.config.isTransverse\n            ? node.nodeHeight || this.config.defaultNodeHeight\n            : node.nodeWidth || this.config.defaultNodeWidth,\n          nodeHeight: this.config.isTransverse\n            ? node.nodeWidth || this.config.defaultNodeWidth\n            : node.nodeHeight || this.config.defaultNodeHeight,\n          originInfo: node\n        };\n        const key = this.config.getNodeKey ? this.config.getNodeKey(node) : node.id; \n        nodeMap.set(key, newNode);\n        nodes.push(newNode);\n      }\n    });\n\n    data.forEach(node => {\n      if (node && node.id) {\n        [...node.downRelations, ...node.upRelations].forEach(relation => {\n          const { sourceId, targetId } = relation;\n          const key = this.config.getLinkKey ? this.config.getLinkKey(relation) : `${sourceId}-${targetId}`;\n          const sourceNode = nodeMap.get(sourceId);\n          const targetNode = nodeMap.get(targetId);\n\n          // 先确保节点均存在，连线不重复\n          if (sourceNode && targetNode && !linkMap.has(key)) {\n            const newRelation: InternalUpGradeLink<Node, Relation> = {\n              source: sourceNode,\n              target: targetNode,\n              originInfo: relation,\n              isReverse: false,\n            };\n\n            // 处理自环\n            if (sourceId === targetId) {\n              linkMap.set(key, newRelation);\n              selfLinks.push(newRelation);\n            } else {\n              linkMap.set(key, newRelation);\n              links.push(newRelation);\n              sourceNode.sourceLinks.push(newRelation);\n              targetNode.targetLinks.push(newRelation);\n            }\n          }\n        });\n      }\n    });\n\n    return {\n      nodes,\n      links,\n      selfLinks\n    };\n  }\n\n  _getDAG(data: Node[]): BaseDAG<Node, Relation> {\n    const { nodes, links, selfLinks } = this._preprocess(data);\n    const {\n      defaultVirtualNodeWidth,\n      nodeAndNodeSpace,\n      paddingLineSpace,\n      levelSpace,\n      linkType,\n      DiyLine,\n      _isLinkMerge,\n    } = this.config;\n    const dag = new BaseDAG<Node, Relation>({\n      nodes,\n      links,\n      selfLinks,\n      config: {\n        defaultVirtualNodeWidth,\n        nodeAndNodeSpace,\n        paddingLineSpace,\n        levelSpace,\n        linkType,\n        DiyLine,\n        _isLinkMerge,\n      }\n    });\n\n    return dag;\n  }\n\n  /**\n   * 单个 DAG\n   * @param data\n   */\n  getSingleDAG(\n    data: Node[]\n  ): {\n    nodes: OutputNode<Node>[];\n    links: OutputRelation<Relation>[];\n    pos: { width: number; height: number };\n  } {\n    if (!data || !data.length) {\n      return emptyDAG;\n    }\n\n    // 单图横向布局，本质为逆转竖向布局\n    if (this.config.isTransverse) {\n      const ans = this._getDAG(data)\n        .run()\n        .getOutput(this.config.margin.bottom, this.config.margin.left);\n      \n      const width = ans.pos.width + this.config.margin.top + this.config.margin.bottom;\n      const height = ans.pos.height + this.config.margin.left + this.config.margin.right;\n\n      return {\n        nodes: ans.nodes.map((node) => {\n          return {\n            ...node,\n            nodeWidth: node.nodeHeight,\n            nodeHeight: node.nodeWidth,\n            view: {\n              x: node.view.y,\n              y: node.view.x,\n            }\n          };\n        }),\n        links: ans.links.map(link => {\n          return {\n            ...link,\n            pathPoint: link.path,\n            path: `${link.path\n              .map((point, index) => {\n                if (index === 0) return `M${point.y},${point.x}`;\n                return `L${point.y},${point.x}`;\n              })\n              .join(' ')}`\n          };\n        }),\n        pos: {\n          width: height,\n          height: width, \n        }\n      };\n    }\n\n    const ans = this._getDAG(data)\n      .run()\n      .getOutput(this.config.margin.left, this.config.margin.top);\n\n    return {\n      ...ans,\n      links: ans.links.map(link => {\n        return {\n          ...link,\n          pathPoint: link.path,\n          path: `${link.path\n            .map((point, index) => {\n              if (index === 0) return `M${point.x},${point.y}`;\n              return `L${point.x},${point.y}`;\n            })\n            .join(' ')}`\n        };\n      }),\n      pos: {\n        width:\n          ans.pos.width + this.config.margin.left + this.config.margin.right,\n        height:\n          ans.pos.height + this.config.margin.top + this.config.margin.bottom\n      }\n    };\n  }\n\n  /**\n   * 多个DAG，可兼容单个 DAG\n   * @param data\n   */\n  getMultiDAG(\n    data: Node[]\n  ): {\n    nodes: OutputNode<Node>[];\n    links: OutputRelation<Relation>[];\n    pos: { width: number; height: number };\n  } {\n    if (!data || !data.length) {\n      return emptyDAG;\n    }\n\n    const nodesList = this._separateNodes(data);\n    // 单个 DAG\n    if (nodesList.length === 1) {\n      return this.getSingleDAG(nodesList[0]);\n    } else {\n      const widthList: number[] = [];\n      const heightList: number[] = [];\n\n      const dagInstanceList = nodesList.map(nodes => {\n        const dag = this._getDAG(nodes).run();\n        const { width, height } = dag.getSize();\n        widthList.push(width);\n        heightList.push(height);\n        return dag;\n      });\n\n      if (this.config.isTransverse) {\n        const height = maxBy(heightList, width => {\n          return width;\n        }) + this.config.margin.left + this.config.margin.right;\n        const width = widthList.reduce((pre, width, index) => {\n          if (index === 0) {\n            return pre + width;\n          }\n          return pre + width + this.config.padding;\n        }, 0) +\n          this.config.margin.top +\n          this.config.margin.bottom;\n        \n        const result = dagInstanceList.reduce(\n          (pre, dag) => {\n            const { addWidth } = pre;\n            const { height: curheight } = dag.getSize();\n            \n            const ans = dag.getOutput(addWidth, (height - curheight) / 2);\n\n            return {\n              nodes: [...pre.nodes, ...ans.nodes],\n              links: [...pre.links, ...ans.links],\n              addWidth: addWidth + this.config.padding + ans.pos.width\n            };\n          },\n          {\n            nodes: [],\n            links: [],\n            addWidth: this.config.margin.top\n          });\n\n        return {\n          nodes: result.nodes.map((node) => {\n            return {\n              ...node,\n              nodeWidth: node.nodeHeight,\n              nodeHeight: node.nodeWidth,\n              view: {\n                x: node.view.y,\n                y: node.view.x,\n              }\n            };\n          }),\n          links: result.links.map(link => {\n            return {\n              ...link,\n              pathPoint: link.path,\n              path: `${link.path\n                .map((point: Point, index: number) => {\n                  if (index === 0) return `M${point.y},${point.x}`;\n                  return `L${point.y},${point.x}`;\n                })\n                .join(' ')}`\n            };\n          }),\n          pos: {\n            width: height,\n            height: width\n          }\n        };\n      }\n      \n      const height =\n        maxBy(heightList, height => {\n          return height;\n        }) +\n        this.config.margin.top +\n        this.config.margin.bottom;\n      const width =\n        widthList.reduce((pre, width, index) => {\n          if (index === 0) {\n            return pre + width;\n          }\n          return pre + width + this.config.padding;\n        }, 0) +\n        this.config.margin.left +\n        this.config.margin.right;\n      const result = dagInstanceList.reduce(\n        (pre, dag, index) => {\n          const { addWidth } = pre;\n          const { height: curheight } = dag.getSize();\n\n          const ans = dag.getOutput(addWidth, (height - curheight) / 2);\n\n          return {\n            nodes: [...pre.nodes, ...ans.nodes],\n            links: [...pre.links, ...ans.links],\n            addWidth: addWidth + this.config.padding + ans.pos.width\n          };\n        },\n        {\n          nodes: [],\n          links: [],\n          addWidth: this.config.margin.left\n        }\n      );\n\n      return {\n        nodes: result.nodes,\n        links: result.links.map(link => {\n          return {\n            ...link,\n            pathPoint: link.path,\n            path: `${link.path\n              .map((point: Point, index: number) => {\n                if (index === 0) return `M${point.x},${point.y}`;\n                return `L${point.x},${point.y}`;\n              })\n              .join(' ')}`\n          };\n        }),\n        pos: {\n          width,\n          height\n        }\n      };\n    }\n  }\n\n  dfs(\n    node: Node,\n    result: Node[],\n    queueId: number,\n    nodeMarkMap: Map<NodeId, { node: Node; queueId: number }>\n  ) {\n    /** 下游节点 */\n    [...node.upRelations, ...node.downRelations].forEach(link => {\n      const nodeId = link.targetId !== node.id ? link.targetId : link.sourceId;\n      if (nodeMarkMap.has(nodeId)) {\n        if (nodeMarkMap.get(nodeId).queueId === -1) {\n          const targetNode = nodeMarkMap.get(nodeId).node;\n          nodeMarkMap.set(nodeId, {\n            node: targetNode,\n            queueId\n          });\n          result.push(targetNode);\n          this.dfs(targetNode, result, queueId, nodeMarkMap);\n        } else {\n          /** 表示重复遍历 */\n          // if (nodeMarkMap.get(nodeId).queueId === queueId) { }\n          if (nodeMarkMap.get(nodeId).queueId !== queueId) {\n            throw new Error(`图数据异常, ${nodeId}，${node.id}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * 将 nodes 进行分离\n   * @param data\n   */\n  _separateNodes(data: Node[]): Node[][] {\n    const nodeMarkMap = new Map<\n      NodeId,\n      {\n        node: Node;\n        queueId: number;\n      }\n    >();\n\n    // 初始化 nodeMarkMap\n    data.forEach(node => {\n      if (!nodeMarkMap.has(node.id)) {\n        nodeMarkMap.set(node.id, {\n          node,\n          queueId: -1\n        });\n      }\n    });\n\n    const result = [] as Node[][];\n    let index = 0;\n    data.forEach(node => {\n      if (nodeMarkMap.get(node.id).queueId === -1) {\n        result[index] = [];\n        result[index].push(node);\n        const targetNode = nodeMarkMap.get(node.id).node;\n        nodeMarkMap.set(node.id, {\n          node: targetNode,\n          queueId: index\n        });\n        this.dfs(node, result[index], index, nodeMarkMap);\n        index++;\n      }\n    });\n\n    return result;\n  }\n}\n\nexport default DAGAIU;"]},"metadata":{},"sourceType":"module"}