{"ast":null,"code":"// 对于 sortNodelevel 进行排序按照 _median 排序，排序结果存储于 _levelPos，对于 -1 不改变位置(levelPos)\nfunction sortNodelevel(nodelevel) {\n  const noChangeList = [];\n  const internalNodeLevel = nodelevel.filter(node => {\n    if (node._median === -1) {\n      noChangeList.push(node);\n    }\n\n    return node._median !== -1;\n  });\n  internalNodeLevel.sort((node1, node2) => {\n    return node1._median - node2._median;\n  });\n  noChangeList.sort((node1, node2) => {\n    return node1.levelPos - node2.levelPos;\n  });\n  noChangeList.forEach(node => {\n    const pos = node.levelPos;\n    internalNodeLevel.splice(pos, 0, node);\n  });\n  internalNodeLevel.forEach((node, i) => node._levelPos = i);\n  return internalNodeLevel;\n}\n/* 计算两个层级间边交叉数量\n * 上游节点可能没有下游，但下游一定有上游\n * Simple and Efficient Bilayer Cross Counting\n * 一种优化方式，通过树状数组来降低求解复杂度\n */\n\n\nfunction crossing(upNodes, downNodes) {\n  const pieNodeList = []; // 遍历上游节点，获取所有与下一相邻层极的联通边、\n\n  upNodes.forEach(node => {\n    // 同一个节点的下游节点，需要按照 _levelPos 来排序\n    node.sourceLinks.sort((link1, link2) => {\n      return link1.target._levelPos - link2.target._levelPos;\n    });\n    node.sourceLinks.forEach(link => {\n      if (link.target.level - link.source.level === 1) {\n        pieNodeList.push(link.target);\n      }\n    });\n  });\n  const q = downNodes.length;\n  let firstIndex = 1;\n\n  while (firstIndex < q) firstIndex *= 2;\n\n  const treesize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = new Array(treesize).fill(0);\n  let crossCount = 0;\n  pieNodeList.map(node => {\n    let index = node._levelPos + firstIndex;\n    tree[index]++;\n\n    while (index > 0) {\n      if (index % 2) crossCount += tree[index + 1];\n      index = Math.floor((index - 1) / 2);\n      tree[index]++;\n    }\n  });\n  return crossCount;\n}\n\nfunction getRatio(idx, length) {\n  const range = [0, 1];\n  const count = Math.ceil(length / 2) + 1;\n  const interval = (range[1] - range[0]) / count; // 存在中位数的情况\n\n  if (length % 2 === 1) {\n    const median = (length - 1) / 2;\n    return interval * (Math.abs(median - idx) + 1);\n  }\n\n  const median = [length / 2 - 1, length / 2];\n\n  if (idx <= median[0]) {\n    return interval * (Math.abs(median[0] - idx) + 1);\n  }\n\n  return interval * (Math.abs(median[1] - idx) + 1);\n}\n\nexport { getRatio, sortNodelevel, crossing };","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/DAG/utils.ts"],"names":["sortNodelevel","nodelevel","noChangeList","internalNodeLevel","filter","node","_median","push","sort","node1","node2","levelPos","forEach","pos","splice","i","_levelPos","crossing","upNodes","downNodes","pieNodeList","sourceLinks","link1","link2","target","link","level","source","q","length","firstIndex","treesize","tree","Array","fill","crossCount","map","index","Math","floor","getRatio","idx","range","count","ceil","interval","median","abs"],"mappings":"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","sourcesContent":["import { InternalUpGradeNode } from './types';\n\n// 对于 sortNodelevel 进行排序按照 _median 排序，排序结果存储于 _levelPos，对于 -1 不改变位置(levelPos)\nfunction sortNodelevel<T extends {\n  _median?: number; // 中位数结果\n  levelPos?: number; // 目前位置\n  _levelPos?: number; // 临时位置\n}>(nodelevel: T[]): T[] {\n  const noChangeList: T[] = [];\n  const internalNodeLevel = nodelevel.filter(node => {\n    if (node._median === -1) {\n      noChangeList.push(node);\n    }\n    return node._median !== -1;\n  });\n\n  internalNodeLevel.sort((node1, node2) => {\n    return node1._median - node2._median;\n  });\n\n  noChangeList.sort((node1, node2) => {\n    return node1.levelPos - node2.levelPos;\n  });\n\n  noChangeList.forEach(node => {\n    const pos = node.levelPos;\n    internalNodeLevel.splice(pos, 0, node);\n  });\n\n  internalNodeLevel.forEach((node, i) => node._levelPos = i);\n  return internalNodeLevel;\n}\n\n/* 计算两个层级间边交叉数量\n * 上游节点可能没有下游，但下游一定有上游\n * Simple and Efficient Bilayer Cross Counting\n * 一种优化方式，通过树状数组来降低求解复杂度\n */\nfunction crossing<ON, OL>(\n  upNodes: InternalUpGradeNode<ON, OL>[],\n  downNodes: InternalUpGradeNode<ON, OL>[]\n): number {\n  const pieNodeList: InternalUpGradeNode<ON, OL>[] = [];\n  // 遍历上游节点，获取所有与下一相邻层极的联通边、\n  upNodes.forEach(node => {\n    // 同一个节点的下游节点，需要按照 _levelPos 来排序\n    node.sourceLinks.sort((link1, link2) => {\n      return link1.target._levelPos - link2.target._levelPos;\n    });\n    node.sourceLinks.forEach(link => {\n      if (link.target.level - link.source.level === 1) {\n        pieNodeList.push(link.target);\n      }\n    });\n  });\n  const q = downNodes.length;\n  let firstIndex = 1;\n  while (firstIndex < q) firstIndex *= 2;\n  const treesize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = (new Array(treesize)).fill(0);\n\n  let crossCount = 0;\n  pieNodeList.map(node => {\n    let index = node._levelPos + firstIndex;\n    tree[index]++;\n    while (index > 0) {\n      if (index % 2) crossCount += tree[index + 1];\n      index = Math.floor((index - 1) / 2);\n      tree[index]++;\n    }\n  });\n  return crossCount;\n}\n\nfunction getRatio(idx: number, length: number) {\n  const range = [0, 1];\n  const count = Math.ceil(length / 2) + 1;\n  const interval = (range[1] - range[0]) / count;\n  // 存在中位数的情况\n  if (length % 2 === 1) {\n    const median = (length - 1) / 2;\n    return interval * (Math.abs(median - idx) + 1)\n  }\n  const median = [length / 2 - 1, length / 2];\n  if (idx <= median[0]) {\n    return interval * (Math.abs(median[0] - idx) + 1);\n  }\n  return interval * (Math.abs(median[1] - idx) + 1);\n}\n\nexport {\n  getRatio,\n  sortNodelevel,\n  crossing,\n}"]},"metadata":{},"sourceType":"module"}