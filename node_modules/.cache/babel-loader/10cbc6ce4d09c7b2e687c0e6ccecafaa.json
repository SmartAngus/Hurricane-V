{"ast":null,"code":"import { useReducer, useCallback } from \"react\"; // Initial state that we pass into useReducer\n\nconst initialState = {\n  // Array of previous state values updated each time we push a new state\n  past: [],\n  // Current state value\n  present: null,\n  // Will contain \"future\" state values if we undo (so we can redo)\n  future: []\n}; // Our reducer function to handle state changes based on action\n\nconst reducer = (state, action) => {\n  const {\n    past,\n    present,\n    future\n  } = state;\n\n  switch (action.type) {\n    case \"UNDO\":\n      const previous = past[past.length - 1];\n      const newPast = past.slice(0, past.length - 1);\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future]\n      };\n\n    case \"REDO\":\n      const next = future[0];\n      const newFuture = future.slice(1);\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture\n      };\n\n    case \"SET\":\n      const {\n        newPresent\n      } = action;\n\n      if (newPresent === present) {\n        return state;\n      }\n\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: []\n      };\n\n    case \"CLEAR\":\n      const {\n        initialPresent\n      } = action;\n      return { ...initialState,\n        present: initialPresent\n      };\n  }\n};\n\nconst useHistory = initialPresent => {\n  const [state, dispatch] = useReducer(reducer, { ...initialState,\n    present: initialPresent\n  });\n  const canUndo = state.past.length !== 0;\n  const canRedo = state.future.length !== 0; // Setup our callback functions\n  // We memoize with useCallback to prevent unecessary re-renders\n\n  const undo = useCallback(() => {\n    if (canUndo) {\n      dispatch({\n        type: \"UNDO\"\n      });\n    }\n  }, [canUndo, dispatch]);\n  const redo = useCallback(() => {\n    if (canRedo) {\n      dispatch({\n        type: \"REDO\"\n      });\n    }\n  }, [canRedo, dispatch]);\n  const set = useCallback(newPresent => dispatch({\n    type: \"SET\",\n    newPresent\n  }), [dispatch]);\n  const clear = useCallback(() => dispatch({\n    type: \"CLEAR\",\n    initialPresent\n  }), [dispatch]); // If needed we could also return past and future state\n\n  return {\n    state: state.present,\n    set,\n    undo,\n    redo,\n    clear,\n    canUndo,\n    canRedo\n  };\n};\n\nexport { useHistory };","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/features/editor/hooks/useHistory.tsx"],"names":["useReducer","useCallback","initialState","past","present","future","reducer","state","action","type","previous","length","newPast","slice","next","newFuture","newPresent","initialPresent","useHistory","dispatch","canUndo","canRedo","undo","redo","set","clear"],"mappings":"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","sourcesContent":["import { useReducer, useCallback } from \"react\";\n\n// Initial state that we pass into useReducer\nconst initialState = {\n  // Array of previous state values updated each time we push a new state\n  past: [],\n  // Current state value\n  present: null,\n  // Will contain \"future\" state values if we undo (so we can redo)\n  future: []\n};\n\n// Our reducer function to handle state changes based on action\nconst reducer = (state, action) => {\n  const { past, present, future } = state;\n  switch (action.type) {\n    case \"UNDO\":\n      const previous = past[past.length - 1];\n      const newPast = past.slice(0, past.length - 1);\n\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future]\n      };\n    case \"REDO\":\n      const next = future[0];\n      const newFuture = future.slice(1);\n\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture\n      };\n    case \"SET\":\n      const { newPresent } = action;\n\n      if (newPresent === present) {\n        return state;\n      }\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: []\n      };\n    case \"CLEAR\":\n      const { initialPresent } = action;\n\n      return {\n        ...initialState,\n        present: initialPresent\n      };\n  }\n};\n\nconst useHistory = initialPresent => {\n  const [state, dispatch] = useReducer(reducer, {\n    ...initialState,\n    present: initialPresent\n  });\n\n  const canUndo = state.past.length !== 0;\n  const canRedo = state.future.length !== 0;\n\n  // Setup our callback functions\n  // We memoize with useCallback to prevent unecessary re-renders\n\n  const undo = useCallback(() => {\n    if (canUndo) {\n      dispatch({ type: \"UNDO\" });\n    }\n  }, [canUndo, dispatch]);\n\n  const redo = useCallback(() => {\n    if (canRedo) {\n      dispatch({ type: \"REDO\" });\n    }\n  }, [canRedo, dispatch]);\n\n  const set = useCallback(newPresent => dispatch({ type: \"SET\", newPresent }), [\n    dispatch\n  ]);\n\n  const clear = useCallback(() => dispatch({ type: \"CLEAR\", initialPresent }), [\n    dispatch\n  ]);\n\n  // If needed we could also return past and future state\n  return { state: state.present, set, undo, redo, clear, canUndo, canRedo };\n};\n\nexport { useHistory };\n"]},"metadata":{},"sourceType":"module"}