{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar utils_1 = require(\"../Utils/utils\");\n\nvar VIRTUAL_ROOT_ID = Symbol('VIRTUAL_ROOT_ID');\n\nvar _TreeVertex = function () {\n  function _TreeVertex(config) {\n    this.id = config.id;\n    this.type = config.type;\n    this.level = config.level;\n    this.parentEdge = config.parentEdge;\n    this.childrenEdge = config.childrenEdge;\n    this.origin = config.origin;\n  }\n\n  _TreeVertex.prototype.getParent = function () {\n    return this.parentEdge.parent;\n  };\n\n  _TreeVertex.prototype.getChildrenOriginNode = function () {\n    return this.childrenEdge.map(function (childEdge) {\n      return childEdge.child.getOriginNode();\n    });\n  };\n\n  _TreeVertex.prototype.getOriginNode = function () {\n    return this.origin;\n  };\n\n  _TreeVertex.prototype.getLevel = function () {\n    return this.level;\n  };\n\n  _TreeVertex.prototype.getSibling = function () {\n    var _this = this;\n\n    var sibling = this.parentEdge.parent.getChildrenOriginNode();\n    var index = utils_1.findIndex(sibling, function (item) {\n      return item.id === _this.id;\n    });\n    return {\n      pre: sibling.slice(0, index),\n      index: index,\n      next: sibling.slice(index + 1)\n    };\n  };\n\n  _TreeVertex.prototype.isVirtualRoot = function () {\n    return this.type === 'virtualRoot';\n  };\n\n  return _TreeVertex;\n}();\n\nvar _TreeEdge = function () {\n  function _TreeEdge(config) {\n    this.parent = config.parent;\n    this.child = config.child;\n    this.origin = config.origin;\n  }\n\n  return _TreeEdge;\n}();\n\nfunction getRoot(vertexes, edges) {\n  var roots = [];\n\n  var _loop_1 = function (i) {\n    var id = vertexes[i].id;\n\n    if (edges.filter(function (edge) {\n      return edge.v === id;\n    }).map(function (edge) {\n      return edge.u;\n    }).length === 0) {\n      roots.push(vertexes[i]);\n    }\n  };\n\n  for (var i = 0; i < vertexes.length; i++) {\n    _loop_1(i);\n  }\n\n  return roots;\n}\n\nvar Tree = function () {\n  function Tree(vertexes, edges) {\n    this.vertexes = [];\n    this.edges = [];\n    this._tree = null;\n    this._treeMap = new Map();\n    this._treeReady = false;\n\n    if (Tree.isTree(vertexes, edges) || Tree.isMulti(vertexes, edges)) {\n      this.vertexes = vertexes;\n      this.edges = edges;\n      this._tree = this._createTree();\n      return;\n    }\n\n    console.error('当前数据无法成树');\n  }\n\n  Tree.prototype._createTree = function () {\n    var _this = this;\n\n    this._treeReady = false;\n\n    this._treeMap.clear();\n\n    var virtualRoot = this._createVirtualRoot();\n\n    this._treeMap.set(virtualRoot.id, virtualRoot);\n\n    var root = this._getRoot();\n\n    root.forEach(function (node) {\n      var treeNode = new _TreeVertex({\n        id: node.id,\n        type: 'realNode',\n        level: virtualRoot.level + 1,\n        parentEdge: null,\n        childrenEdge: [],\n        origin: node\n      });\n\n      _this._addChildren(virtualRoot, treeNode);\n\n      _this.dfs(treeNode, function (parent) {\n        var children = _this.getChildren(parent.id);\n\n        return children.map(function (child) {\n          return new _TreeVertex({\n            id: child.id,\n            type: 'realNode',\n            level: parent.level + 1,\n            parentEdge: null,\n            childrenEdge: [],\n            origin: child\n          });\n        });\n      }, function (parent, child) {\n        if (child) {\n          _this._addChildren(parent, child);\n        }\n      });\n    });\n    this._treeReady = true;\n    return virtualRoot;\n  };\n\n  Tree.prototype._addChildren = function (parentNode, childNode) {\n    var isExistChild = utils_1.find(parentNode.childrenEdge.map(function (childEdge) {\n      return childEdge.child;\n    }), function (child) {\n      return child.id === childNode.id;\n    });\n\n    if (!isExistChild) {\n      var edge = this.getEdge(parentNode.origin.id, childNode.origin.id);\n      parentNode.childrenEdge.push(new _TreeEdge({\n        parent: parentNode,\n        child: childNode,\n        origin: edge\n      }));\n      childNode.parentEdge = new _TreeEdge({\n        parent: parentNode,\n        child: childNode,\n        origin: edge\n      });\n\n      this._treeMap.set(childNode.id, childNode);\n    }\n  };\n\n  Tree.prototype._createVirtualRoot = function () {\n    var id = VIRTUAL_ROOT_ID.toString();\n    return new _TreeVertex({\n      id: id,\n      parentEdge: null,\n      type: 'virtualRoot',\n      level: 0,\n      childrenEdge: [],\n      origin: {\n        id: id\n      }\n    });\n  };\n\n  Tree.prototype.dfs = function (node, getChildren, beforeCallback, isDfs, callBackResult, afterCallback) {\n    var _this = this;\n\n    if (beforeCallback === void 0) {\n      beforeCallback = function () {\n        return undefined;\n      };\n    }\n\n    if (isDfs === void 0) {\n      isDfs = function () {\n        return true;\n      };\n    }\n\n    if (callBackResult === void 0) {\n      callBackResult = null;\n    }\n\n    if (afterCallback === void 0) {\n      afterCallback = function () {\n        return undefined;\n      };\n    }\n\n    if (!isDfs(node.id)) {\n      return;\n    }\n\n    var children = getChildren(node);\n\n    if (children && children.length) {\n      children.forEach(function (child) {\n        var result = beforeCallback(node, child, callBackResult);\n\n        _this.dfs(child, getChildren, beforeCallback, isDfs, result, afterCallback);\n\n        afterCallback(node, child, result);\n      });\n    } else {\n      var result = beforeCallback(node, null, callBackResult);\n      afterCallback(node, null, result);\n    }\n  };\n\n  Tree.prototype.bfs = function (node, getChildren, callback, isBfs) {\n    if (isBfs === void 0) {\n      isBfs = function () {\n        return true;\n      };\n    }\n\n    if (!isBfs(node.id)) {\n      return;\n    }\n\n    getChildren(node).forEach(function (child) {\n      callback(node, child);\n    });\n  };\n\n  Tree.prototype._getRoot = function (isVirtual) {\n    if (this._treeReady) {\n      if (isVirtual) {\n        return [this._tree.getOriginNode()];\n      }\n\n      return this._tree.getChildrenOriginNode();\n    } else {\n      return getRoot(this.vertexes, this.edges);\n    }\n  };\n\n  Tree.prototype.getSingleRoot = function () {\n    var roots = this._getRoot();\n\n    return roots[0];\n  };\n\n  Tree.prototype.getMultiRoot = function () {\n    return this._getRoot();\n  };\n\n  Tree.prototype.getParent = function (id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        var parent_1 = this._treeMap.get(id).getParent();\n\n        if (parent_1.isVirtualRoot()) {\n          return null;\n        }\n\n        return parent_1.getOriginNode();\n      }\n\n      return null;\n    } else {\n      var edgeIdList_1 = this.edges.filter(function (edge) {\n        return edge.v === id;\n      }).map(function (edge) {\n        return edge.u;\n      });\n\n      if (edgeIdList_1.length === 0) {\n        return null;\n      }\n\n      return utils_1.find(this.vertexes, function (vertex) {\n        return edgeIdList_1.indexOf(vertex.id) !== -1;\n      });\n    }\n  };\n\n  Tree.prototype.getEdge = function (parentId, childId) {\n    var edges = this.edges.filter(function (edge) {\n      return edge.u === parentId && edge.v === childId;\n    });\n    return edges.length === 0 ? null : edges[0];\n  };\n\n  Tree.prototype.getNode = function (id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getOriginNode();\n      }\n\n      return null;\n    } else {\n      var vertex = this.vertexes.filter(function (vertex) {\n        return vertex.id === id;\n      });\n      return vertex.length === 0 ? null : vertex[0];\n    }\n  };\n\n  Tree.prototype.getSibling = function (id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getSibling();\n      }\n    }\n\n    return {\n      pre: [],\n      next: [],\n      index: -1\n    };\n  };\n\n  Tree.prototype.getChildren = function (id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getChildrenOriginNode();\n      }\n\n      return [];\n    } else {\n      if (id === VIRTUAL_ROOT_ID.toString()) {\n        return this._getRoot();\n      }\n\n      var edgeIdList_2 = this.edges.filter(function (edge) {\n        return edge.u === id;\n      }).map(function (edge) {\n        return edge.v;\n      });\n      return this.vertexes.filter(function (vertex) {\n        return edgeIdList_2.indexOf(vertex.id) !== -1;\n      });\n    }\n  };\n\n  Tree.prototype.getLevel = function (id) {\n    if (this._treeMap.has(id)) {\n      return this._treeMap.get(id).getLevel();\n    }\n\n    return null;\n  };\n\n  Tree.prototype.getSingleTree = function (id, depth) {\n    if (depth === void 0) {\n      depth = -1;\n    }\n\n    if (id && !this._treeMap.has(id)) {\n      return null;\n    }\n\n    return this.getTree(id, depth)[0];\n  };\n\n  Tree.prototype.getTree = function (id, depth) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = -1;\n    }\n\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    }\n\n    var nodes = id ? [tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), {\n      children: [],\n      _origin: this._treeMap.get(id).getOriginNode()\n    })] : this._getRoot().map(function (root) {\n      return tslib_1.__assign(tslib_1.__assign({}, root), {\n        children: [],\n        _origin: root\n      });\n    });\n    nodes.forEach(function (node) {\n      _this.dfs(node, function (parent) {\n        var children = _this.getChildren(parent.id);\n\n        return children.map(function (child) {\n          return tslib_1.__assign(tslib_1.__assign({}, child), {\n            children: [],\n            _origin: child\n          });\n        });\n      }, function (parent, child) {\n        if (child) {\n          parent.children.push(child);\n        }\n      }, function (id) {\n        var currentLevel = _this._treeMap.get(id).getLevel();\n\n        var level = _this._treeMap.get(node.id).getLevel();\n\n        if (depth === -1 || currentLevel - level < depth - 1) {\n          return true;\n        }\n\n        return false;\n      });\n    });\n    return nodes;\n  };\n\n  Tree.prototype._getTreeByBFS = function (id, depth) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = -1;\n    }\n\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    }\n\n    var nodes = id ? [tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), {\n      children: [],\n      _origin: this._treeMap.get(id).getOriginNode()\n    })] : this._getRoot().map(function (root) {\n      return tslib_1.__assign(tslib_1.__assign({}, root), {\n        children: [],\n        _origin: root\n      });\n    });\n    this._bfsQueue = tslib_1.__spread(nodes);\n\n    while (this._bfsQueue.length !== 0) {\n      var node = this._bfsQueue.shift();\n\n      this.bfs(node, function (parent) {\n        return _this.getChildren(parent.id).map(function (child) {\n          return tslib_1.__assign(tslib_1.__assign({}, child), {\n            children: [],\n            _origin: child\n          });\n        });\n      }, function (parent, child) {\n        parent.children.push(child);\n\n        _this._bfsQueue.push(child);\n      }, function (id) {\n        var currentLevel = _this._treeMap.get(id).getLevel();\n\n        var level = _this._treeMap.get(nodes[0].id).getLevel();\n\n        if (depth === -1 || currentLevel - level < depth - 1) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return nodes;\n  };\n\n  Tree.prototype.getPath = function (ancestorId, childId) {\n    var _this = this;\n\n    var ancestor = this.getNode(ancestorId);\n    if (!ancestor) return [];\n    var path = [];\n    this.dfs(ancestor, function (p) {\n      return _this.getChildren(p.id);\n    }, function (p, child, pre) {\n      if (child) {\n        if (childId === child.id) {\n          path = tslib_1.__spread(pre, [child]);\n        }\n\n        return tslib_1.__spread(pre, [child]);\n      }\n\n      return pre;\n    }, function () {\n      return path.length === 0;\n    }, [ancestor]);\n    return path;\n  };\n\n  Tree.prototype.getNodeRelation = function (node1, node2) {\n    var root = this._getRoot(true)[0];\n\n    var path1 = this.getPath(root.id, node1);\n    var path2 = this.getPath(root.id, node2);\n    var commonRoot = path1.reduce(function (pre, item) {\n      var node = utils_1.find(path2, function (i) {\n        return item.id === i.id;\n      });\n\n      if (node) {\n        return node;\n      }\n\n      return pre;\n    }, null);\n\n    if (commonRoot.id === VIRTUAL_ROOT_ID.toString()) {\n      return null;\n    }\n\n    return commonRoot;\n  };\n\n  Tree.prototype._translate = function (vertex) {\n    var vertexResult = [vertex._origin];\n    var edgeResult = [];\n    this.dfs(vertex, function (parent) {\n      parent.children.forEach(function (child) {\n        vertexResult.push(child._origin);\n        edgeResult.push({\n          u: parent.id,\n          v: child.id\n        });\n      });\n      return parent.children;\n    }, function () {});\n    return {\n      vertexes: vertexResult,\n      edges: edgeResult\n    };\n  };\n\n  Tree.prototype.addVertex = function (vertex, parentId) {\n    if (parentId === void 0) {\n      parentId = VIRTUAL_ROOT_ID.toString();\n    }\n\n    if (!this._treeMap.has(parentId)) {\n      return;\n    }\n\n    this.edges = parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{\n      u: parentId,\n      v: vertex.id\n    }]);\n    this.vertexes = tslib_1.__spread(this.vertexes, [vertex]);\n\n    var parent = this._treeMap.get(parentId);\n\n    var newTreeNode = new _TreeVertex({\n      id: vertex.id,\n      parentEdge: null,\n      type: 'realNode',\n      level: parent.level + 1,\n      childrenEdge: [],\n      origin: vertex\n    });\n\n    this._addChildren(parent, newTreeNode);\n  };\n\n  Tree.prototype.addChildTree = function (vertex, parentId) {\n    var _this = this;\n\n    if (parentId === void 0) {\n      parentId = VIRTUAL_ROOT_ID.toString();\n    }\n\n    if (!this._treeMap.has(parentId)) {\n      return;\n    }\n\n    this.edges = parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{\n      u: parentId,\n      v: vertex.id\n    }]);\n\n    var _a = this._translate(vertex),\n        vertexes = _a.vertexes,\n        edges = _a.edges;\n\n    this.vertexes = tslib_1.__spread(this.vertexes, vertexes);\n    this.edges = tslib_1.__spread(this.edges, edges);\n    this._treeReady = false;\n\n    var parent = this._treeMap.get(parentId);\n\n    this.dfs(parent, function (parent) {\n      var children = _this.getChildren(parent.id);\n\n      return children.map(function (child) {\n        return new _TreeVertex({\n          id: child.id,\n          parentEdge: null,\n          type: 'realNode',\n          level: parent.level + 1,\n          childrenEdge: [],\n          origin: child\n        });\n      });\n    }, function (parent, child) {\n      if (child) {\n        _this._addChildren(parent, child);\n      }\n    });\n    this._treeReady = true;\n  };\n\n  Tree.prototype.deleteVertex = function (vertexId) {\n    var _this = this;\n\n    if (!this._treeMap.has(vertexId)) {\n      return null;\n    }\n\n    var childTree = this.getSingleTree(vertexId);\n\n    var parent = this._treeMap.get(vertexId).getParent();\n\n    var _a = this._translate(childTree),\n        vertexes = _a.vertexes,\n        edges = _a.edges;\n\n    this.vertexes = this.vertexes.filter(function (vertex) {\n      return utils_1.find(vertexes, function (item) {\n        return item.id === vertex.id;\n      }) ? false : true;\n    });\n    this.edges = this.edges.filter(function (edge) {\n      return utils_1.find(edges, function (e) {\n        return edge.u === e.u && edge.v === e.v || edge.u === parent.id && edge.v === vertexId;\n      }) ? false : true;\n    });\n    vertexes.forEach(function (vertex) {\n      _this._treeMap.delete(vertex.id);\n    });\n    parent.childrenEdge = parent.childrenEdge.filter(function (childEdge) {\n      return childEdge.child.id !== vertexId;\n    });\n    return childTree;\n  };\n\n  Tree.prototype.updateVertex = function (vertex) {\n    this.vertexes = this.vertexes.map(function (item) {\n      if (item.id === vertex.id) {\n        return vertex;\n      }\n\n      return item;\n    });\n\n    if (this._treeMap.has(vertex.id)) {\n      var oldVertex = this._treeMap.get(vertex.id);\n\n      oldVertex.origin = vertex;\n    }\n  };\n\n  Tree.prototype.updateEdge = function (edge) {\n    this.edges = this.edges.map(function (e) {\n      if (e.u === edge.u && e.v === edge.v) {\n        return edge;\n      }\n\n      return e;\n    });\n  };\n\n  Tree.prototype.deleteEdge = function (u, v) {\n    if (!this._treeMap.has(u) || !this._treeMap.has(v)) {\n      return null;\n    }\n\n    this.edges = this.edges.filter(function (edge) {\n      return edge.u !== u && edge.v !== edge.v;\n    });\n    return this.deleteVertex(v);\n  };\n\n  Tree.prototype.getVertexes = function () {\n    return this.vertexes;\n  };\n\n  Tree.prototype.getEdges = function () {\n    return this.edges;\n  };\n\n  Tree.prototype.getLeafVertexes = function (id, depth) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = -1;\n    }\n\n    var vertexes = this._translate(this._getTreeByBFS(id, depth)[0]).vertexes;\n\n    return vertexes.filter(function (node) {\n      return _this.getChildren(node.id).length === 0;\n    });\n  };\n\n  return Tree;\n}();\n\nTree.isTree = function (vertexes, edges) {\n  var visitedList = [];\n\n  function dfs(node) {\n    if (visitedList.indexOf(node.id) !== -1) {\n      return false;\n    }\n\n    visitedList.push(node.id);\n    var edgeIdList = edges.filter(function (edge) {\n      return edge.u === node.id;\n    }).map(function (edge) {\n      return edge.v;\n    });\n    var children = vertexes.filter(function (vertex) {\n      return edgeIdList.indexOf(vertex.id) !== -1;\n    });\n\n    for (var i = 0; i < children.length; i++) {\n      if (!dfs(children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (vertexes.length !== edges.length + 1) {\n    return false;\n  }\n\n  var roots = getRoot(vertexes, edges);\n\n  if (roots.length === 1) {\n    return dfs(roots[0]);\n  }\n\n  return false;\n};\n\nTree.isMulti = function (vertexes, edges) {\n  var roots = getRoot(vertexes, edges);\n\n  if (roots.length <= 1) {\n    return false;\n  }\n\n  var virtualRootId = VIRTUAL_ROOT_ID.toString();\n  return Tree.isTree(tslib_1.__spread(vertexes, [{\n    id: virtualRootId\n  }]), tslib_1.__spread(edges, roots.map(function (node) {\n    return {\n      u: virtualRootId,\n      v: node.id\n    };\n  })));\n};\n\nTree.parse = function (tree, getId, getChildren, getEdge) {\n  var getIdHandler = getId ? getId : function (node) {\n    return node.id;\n  };\n  var getChildrenHandler = getChildren ? getChildren : function (node) {\n    return node.children;\n  };\n  var vertexes = [];\n  var edges = [];\n  var visitedList = [];\n\n  function dfs(node) {\n    var id = getIdHandler(node);\n    node.id = id;\n\n    if (visitedList.indexOf(id) !== -1) {\n      console.error('存在环！');\n      return false;\n    }\n\n    visitedList.push(id);\n    vertexes.push(node);\n    var children = getChildrenHandler(node);\n\n    if (children && children.length) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var childId = getIdHandler(child);\n        child.id = childId;\n        var edge = getEdge ? getEdge(node, child) : {\n          u: id,\n          v: childId\n        };\n        edges.push(edge);\n        dfs(child);\n      }\n    }\n  }\n\n  for (var i = 0; i < tree.length; i++) {\n    dfs(tree[i]);\n  }\n\n  return {\n    vertexes: vertexes,\n    edges: edges\n  };\n};\n\nexports.default = Tree;","map":{"version":3,"sources":["../../src/BaseGraph/Tree.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"../Utils/utils\");\nvar VIRTUAL_ROOT_ID = Symbol('VIRTUAL_ROOT_ID');\nvar _TreeVertex = (function () {\n    function _TreeVertex(config) {\n        this.id = config.id;\n        this.type = config.type;\n        this.level = config.level;\n        this.parentEdge = config.parentEdge;\n        this.childrenEdge = config.childrenEdge;\n        this.origin = config.origin;\n    }\n    _TreeVertex.prototype.getParent = function () {\n        return this.parentEdge.parent;\n    };\n    _TreeVertex.prototype.getChildrenOriginNode = function () {\n        return this.childrenEdge.map(function (childEdge) {\n            return childEdge.child.getOriginNode();\n        });\n    };\n    _TreeVertex.prototype.getOriginNode = function () {\n        return this.origin;\n    };\n    _TreeVertex.prototype.getLevel = function () {\n        return this.level;\n    };\n    _TreeVertex.prototype.getSibling = function () {\n        var _this = this;\n        var sibling = this.parentEdge.parent.getChildrenOriginNode();\n        var index = utils_1.findIndex(sibling, function (item) {\n            return item.id === _this.id;\n        });\n        return {\n            pre: sibling.slice(0, index),\n            index: index,\n            next: sibling.slice(index + 1)\n        };\n    };\n    _TreeVertex.prototype.isVirtualRoot = function () {\n        return this.type === 'virtualRoot';\n    };\n    return _TreeVertex;\n}());\nvar _TreeEdge = (function () {\n    function _TreeEdge(config) {\n        this.parent = config.parent;\n        this.child = config.child;\n        this.origin = config.origin;\n    }\n    return _TreeEdge;\n}());\nfunction getRoot(vertexes, edges) {\n    var roots = [];\n    var _loop_1 = function (i) {\n        var id = vertexes[i].id;\n        if (edges.filter(function (edge) { return edge.v === id; }).map(function (edge) { return edge.u; }).length === 0) {\n            roots.push(vertexes[i]);\n        }\n    };\n    for (var i = 0; i < vertexes.length; i++) {\n        _loop_1(i);\n    }\n    return roots;\n}\nvar Tree = (function () {\n    function Tree(vertexes, edges) {\n        this.vertexes = [];\n        this.edges = [];\n        this._tree = null;\n        this._treeMap = new Map();\n        this._treeReady = false;\n        if (Tree.isTree(vertexes, edges) || Tree.isMulti(vertexes, edges)) {\n            this.vertexes = vertexes;\n            this.edges = edges;\n            this._tree = this._createTree();\n            return;\n        }\n        console.error('当前数据无法成树');\n    }\n    Tree.prototype._createTree = function () {\n        var _this = this;\n        this._treeReady = false;\n        this._treeMap.clear();\n        var virtualRoot = this._createVirtualRoot();\n        this._treeMap.set(virtualRoot.id, virtualRoot);\n        var root = this._getRoot();\n        root.forEach(function (node) {\n            var treeNode = new _TreeVertex({\n                id: node.id,\n                type: 'realNode',\n                level: virtualRoot.level + 1,\n                parentEdge: null,\n                childrenEdge: [],\n                origin: node\n            });\n            _this._addChildren(virtualRoot, treeNode);\n            _this.dfs(treeNode, function (parent) {\n                var children = _this.getChildren(parent.id);\n                return children.map(function (child) {\n                    return new _TreeVertex({\n                        id: child.id,\n                        type: 'realNode',\n                        level: parent.level + 1,\n                        parentEdge: null,\n                        childrenEdge: [],\n                        origin: child\n                    });\n                });\n            }, function (parent, child) {\n                if (child) {\n                    _this._addChildren(parent, child);\n                }\n            });\n        });\n        this._treeReady = true;\n        return virtualRoot;\n    };\n    Tree.prototype._addChildren = function (parentNode, childNode) {\n        var isExistChild = utils_1.find(parentNode.childrenEdge.map(function (childEdge) {\n            return childEdge.child;\n        }), function (child) {\n            return child.id === childNode.id;\n        });\n        if (!isExistChild) {\n            var edge = this.getEdge(parentNode.origin.id, childNode.origin.id);\n            parentNode.childrenEdge.push(new _TreeEdge({\n                parent: parentNode,\n                child: childNode,\n                origin: edge\n            }));\n            childNode.parentEdge = new _TreeEdge({\n                parent: parentNode,\n                child: childNode,\n                origin: edge\n            });\n            this._treeMap.set(childNode.id, childNode);\n        }\n    };\n    Tree.prototype._createVirtualRoot = function () {\n        var id = VIRTUAL_ROOT_ID.toString();\n        return new _TreeVertex({\n            id: id,\n            parentEdge: null,\n            type: 'virtualRoot',\n            level: 0,\n            childrenEdge: [],\n            origin: {\n                id: id\n            }\n        });\n    };\n    Tree.prototype.dfs = function (node, getChildren, beforeCallback, isDfs, callBackResult, afterCallback) {\n        var _this = this;\n        if (beforeCallback === void 0) { beforeCallback = function () { return undefined; }; }\n        if (isDfs === void 0) { isDfs = function () { return true; }; }\n        if (callBackResult === void 0) { callBackResult = null; }\n        if (afterCallback === void 0) { afterCallback = function () { return undefined; }; }\n        if (!isDfs(node.id)) {\n            return;\n        }\n        var children = getChildren(node);\n        if (children && children.length) {\n            children.forEach(function (child) {\n                var result = beforeCallback(node, child, callBackResult);\n                _this.dfs(child, getChildren, beforeCallback, isDfs, result, afterCallback);\n                afterCallback(node, child, result);\n            });\n        }\n        else {\n            var result = beforeCallback(node, null, callBackResult);\n            afterCallback(node, null, result);\n        }\n    };\n    Tree.prototype.bfs = function (node, getChildren, callback, isBfs) {\n        if (isBfs === void 0) { isBfs = function () { return true; }; }\n        if (!isBfs(node.id)) {\n            return;\n        }\n        getChildren(node).forEach(function (child) {\n            callback(node, child);\n        });\n    };\n    Tree.prototype._getRoot = function (isVirtual) {\n        if (this._treeReady) {\n            if (isVirtual) {\n                return [this._tree.getOriginNode()];\n            }\n            return this._tree.getChildrenOriginNode();\n        }\n        else {\n            return getRoot(this.vertexes, this.edges);\n        }\n    };\n    Tree.prototype.getSingleRoot = function () {\n        var roots = this._getRoot();\n        return roots[0];\n    };\n    Tree.prototype.getMultiRoot = function () {\n        return this._getRoot();\n    };\n    Tree.prototype.getParent = function (id) {\n        if (this._treeReady) {\n            if (this._treeMap.has(id)) {\n                var parent_1 = this._treeMap.get(id).getParent();\n                if (parent_1.isVirtualRoot()) {\n                    return null;\n                }\n                return parent_1.getOriginNode();\n            }\n            return null;\n        }\n        else {\n            var edgeIdList_1 = this.edges.filter(function (edge) { return edge.v === id; }).map(function (edge) { return edge.u; });\n            if (edgeIdList_1.length === 0) {\n                return null;\n            }\n            return utils_1.find(this.vertexes, function (vertex) {\n                return edgeIdList_1.indexOf(vertex.id) !== -1;\n            });\n        }\n    };\n    Tree.prototype.getEdge = function (parentId, childId) {\n        var edges = this.edges.filter(function (edge) {\n            return edge.u === parentId && edge.v === childId;\n        });\n        return edges.length === 0 ? null : edges[0];\n    };\n    Tree.prototype.getNode = function (id) {\n        if (this._treeReady) {\n            if (this._treeMap.has(id)) {\n                return this._treeMap.get(id).getOriginNode();\n            }\n            return null;\n        }\n        else {\n            var vertex = this.vertexes.filter(function (vertex) {\n                return vertex.id === id;\n            });\n            return vertex.length === 0 ? null : vertex[0];\n        }\n    };\n    Tree.prototype.getSibling = function (id) {\n        if (this._treeReady) {\n            if (this._treeMap.has(id)) {\n                return this._treeMap.get(id).getSibling();\n            }\n        }\n        return {\n            pre: [],\n            next: [],\n            index: -1\n        };\n    };\n    Tree.prototype.getChildren = function (id) {\n        if (this._treeReady) {\n            if (this._treeMap.has(id)) {\n                return this._treeMap.get(id).getChildrenOriginNode();\n            }\n            return [];\n        }\n        else {\n            if (id === VIRTUAL_ROOT_ID.toString()) {\n                return this._getRoot();\n            }\n            var edgeIdList_2 = this.edges.filter(function (edge) { return edge.u === id; }).map(function (edge) { return edge.v; });\n            return this.vertexes.filter(function (vertex) {\n                return edgeIdList_2.indexOf(vertex.id) !== -1;\n            });\n        }\n    };\n    Tree.prototype.getLevel = function (id) {\n        if (this._treeMap.has(id)) {\n            return this._treeMap.get(id).getLevel();\n        }\n        return null;\n    };\n    Tree.prototype.getSingleTree = function (id, depth) {\n        if (depth === void 0) { depth = -1; }\n        if (id && !this._treeMap.has(id)) {\n            return null;\n        }\n        return this.getTree(id, depth)[0];\n    };\n    Tree.prototype.getTree = function (id, depth) {\n        var _this = this;\n        if (depth === void 0) { depth = -1; }\n        if (id && !this._treeMap.has(id)) {\n            return [];\n        }\n        var nodes = id\n            ? [\n                tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), { children: [], _origin: this._treeMap.get(id).getOriginNode() })\n            ]\n            : this._getRoot().map(function (root) {\n                return tslib_1.__assign(tslib_1.__assign({}, root), { children: [], _origin: root });\n            });\n        nodes.forEach(function (node) {\n            _this.dfs(node, function (parent) {\n                var children = _this.getChildren(parent.id);\n                return children.map(function (child) {\n                    return tslib_1.__assign(tslib_1.__assign({}, child), { children: [], _origin: child });\n                });\n            }, function (parent, child) {\n                if (child) {\n                    parent.children.push(child);\n                }\n            }, function (id) {\n                var currentLevel = _this._treeMap.get(id).getLevel();\n                var level = _this._treeMap.get(node.id).getLevel();\n                if (depth === -1 || currentLevel - level < depth - 1) {\n                    return true;\n                }\n                return false;\n            });\n        });\n        return nodes;\n    };\n    Tree.prototype._getTreeByBFS = function (id, depth) {\n        var _this = this;\n        if (depth === void 0) { depth = -1; }\n        if (id && !this._treeMap.has(id)) {\n            return [];\n        }\n        var nodes = id\n            ? [\n                tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), { children: [], _origin: this._treeMap.get(id).getOriginNode() })\n            ]\n            : this._getRoot().map(function (root) {\n                return tslib_1.__assign(tslib_1.__assign({}, root), { children: [], _origin: root });\n            });\n        this._bfsQueue = tslib_1.__spread(nodes);\n        while (this._bfsQueue.length !== 0) {\n            var node = this._bfsQueue.shift();\n            this.bfs(node, function (parent) {\n                return _this.getChildren(parent.id).map(function (child) {\n                    return tslib_1.__assign(tslib_1.__assign({}, child), { children: [], _origin: child });\n                });\n            }, function (parent, child) {\n                parent.children.push(child);\n                _this._bfsQueue.push(child);\n            }, function (id) {\n                var currentLevel = _this._treeMap.get(id).getLevel();\n                var level = _this._treeMap.get(nodes[0].id).getLevel();\n                if (depth === -1 || currentLevel - level < depth - 1) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        return nodes;\n    };\n    Tree.prototype.getPath = function (ancestorId, childId) {\n        var _this = this;\n        var ancestor = this.getNode(ancestorId);\n        if (!ancestor)\n            return [];\n        var path = [];\n        this.dfs(ancestor, function (p) {\n            return _this.getChildren(p.id);\n        }, function (p, child, pre) {\n            if (child) {\n                if (childId === child.id) {\n                    path = tslib_1.__spread(pre, [child]);\n                }\n                return tslib_1.__spread(pre, [child]);\n            }\n            return pre;\n        }, function () {\n            return path.length === 0;\n        }, [ancestor]);\n        return path;\n    };\n    Tree.prototype.getNodeRelation = function (node1, node2) {\n        var root = this._getRoot(true)[0];\n        var path1 = this.getPath(root.id, node1);\n        var path2 = this.getPath(root.id, node2);\n        var commonRoot = path1.reduce(function (pre, item) {\n            var node = utils_1.find(path2, function (i) {\n                return item.id === i.id;\n            });\n            if (node) {\n                return node;\n            }\n            return pre;\n        }, null);\n        if (commonRoot.id === VIRTUAL_ROOT_ID.toString()) {\n            return null;\n        }\n        return commonRoot;\n    };\n    Tree.prototype._translate = function (vertex) {\n        var vertexResult = [vertex._origin];\n        var edgeResult = [];\n        this.dfs(vertex, function (parent) {\n            parent.children.forEach(function (child) {\n                vertexResult.push(child._origin);\n                edgeResult.push({\n                    u: parent.id,\n                    v: child.id\n                });\n            });\n            return parent.children;\n        }, function () { });\n        return {\n            vertexes: vertexResult,\n            edges: edgeResult\n        };\n    };\n    Tree.prototype.addVertex = function (vertex, parentId) {\n        if (parentId === void 0) { parentId = VIRTUAL_ROOT_ID.toString(); }\n        if (!this._treeMap.has(parentId)) {\n            return;\n        }\n        this.edges =\n            parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{ u: parentId, v: vertex.id }]);\n        this.vertexes = tslib_1.__spread(this.vertexes, [vertex]);\n        var parent = this._treeMap.get(parentId);\n        var newTreeNode = new _TreeVertex({\n            id: vertex.id,\n            parentEdge: null,\n            type: 'realNode',\n            level: parent.level + 1,\n            childrenEdge: [],\n            origin: vertex\n        });\n        this._addChildren(parent, newTreeNode);\n    };\n    Tree.prototype.addChildTree = function (vertex, parentId) {\n        var _this = this;\n        if (parentId === void 0) { parentId = VIRTUAL_ROOT_ID.toString(); }\n        if (!this._treeMap.has(parentId)) {\n            return;\n        }\n        this.edges =\n            parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{ u: parentId, v: vertex.id }]);\n        var _a = this._translate(vertex), vertexes = _a.vertexes, edges = _a.edges;\n        this.vertexes = tslib_1.__spread(this.vertexes, vertexes);\n        this.edges = tslib_1.__spread(this.edges, edges);\n        this._treeReady = false;\n        var parent = this._treeMap.get(parentId);\n        this.dfs(parent, function (parent) {\n            var children = _this.getChildren(parent.id);\n            return children.map(function (child) {\n                return new _TreeVertex({\n                    id: child.id,\n                    parentEdge: null,\n                    type: 'realNode',\n                    level: parent.level + 1,\n                    childrenEdge: [],\n                    origin: child\n                });\n            });\n        }, function (parent, child) {\n            if (child) {\n                _this._addChildren(parent, child);\n            }\n        });\n        this._treeReady = true;\n    };\n    Tree.prototype.deleteVertex = function (vertexId) {\n        var _this = this;\n        if (!this._treeMap.has(vertexId)) {\n            return null;\n        }\n        var childTree = this.getSingleTree(vertexId);\n        var parent = this._treeMap.get(vertexId).getParent();\n        var _a = this._translate(childTree), vertexes = _a.vertexes, edges = _a.edges;\n        this.vertexes = this.vertexes.filter(function (vertex) {\n            return utils_1.find(vertexes, function (item) {\n                return item.id === vertex.id;\n            })\n                ? false\n                : true;\n        });\n        this.edges = this.edges.filter(function (edge) {\n            return utils_1.find(edges, function (e) {\n                return (edge.u === e.u && edge.v === e.v) || (edge.u === parent.id && edge.v === vertexId);\n            })\n                ? false\n                : true;\n        });\n        vertexes.forEach(function (vertex) {\n            _this._treeMap.delete(vertex.id);\n        });\n        parent.childrenEdge = parent.childrenEdge.filter(function (childEdge) {\n            return childEdge.child.id !== vertexId;\n        });\n        return childTree;\n    };\n    Tree.prototype.updateVertex = function (vertex) {\n        this.vertexes = this.vertexes.map(function (item) {\n            if (item.id === vertex.id) {\n                return vertex;\n            }\n            return item;\n        });\n        if (this._treeMap.has(vertex.id)) {\n            var oldVertex = this._treeMap.get(vertex.id);\n            oldVertex.origin = vertex;\n        }\n    };\n    Tree.prototype.updateEdge = function (edge) {\n        this.edges = this.edges.map(function (e) {\n            if (e.u === edge.u && e.v === edge.v) {\n                return edge;\n            }\n            return e;\n        });\n    };\n    Tree.prototype.deleteEdge = function (u, v) {\n        if (!this._treeMap.has(u) || !this._treeMap.has(v)) {\n            return null;\n        }\n        this.edges = this.edges.filter(function (edge) {\n            return edge.u !== u && edge.v !== edge.v;\n        });\n        return this.deleteVertex(v);\n    };\n    Tree.prototype.getVertexes = function () {\n        return this.vertexes;\n    };\n    Tree.prototype.getEdges = function () {\n        return this.edges;\n    };\n    Tree.prototype.getLeafVertexes = function (id, depth) {\n        var _this = this;\n        if (depth === void 0) { depth = -1; }\n        var vertexes = this._translate(this._getTreeByBFS(id, depth)[0]).vertexes;\n        return vertexes.filter(function (node) {\n            return _this.getChildren(node.id).length === 0;\n        });\n    };\n    return Tree;\n}());\nTree.isTree = function (vertexes, edges) {\n    var visitedList = [];\n    function dfs(node) {\n        if (visitedList.indexOf(node.id) !== -1) {\n            return false;\n        }\n        visitedList.push(node.id);\n        var edgeIdList = edges.filter(function (edge) { return edge.u === node.id; }).map(function (edge) { return edge.v; });\n        var children = vertexes.filter(function (vertex) {\n            return edgeIdList.indexOf(vertex.id) !== -1;\n        });\n        for (var i = 0; i < children.length; i++) {\n            if (!dfs(children[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (vertexes.length !== edges.length + 1) {\n        return false;\n    }\n    var roots = getRoot(vertexes, edges);\n    if (roots.length === 1) {\n        return dfs(roots[0]);\n    }\n    return false;\n};\nTree.isMulti = function (vertexes, edges) {\n    var roots = getRoot(vertexes, edges);\n    if (roots.length <= 1) {\n        return false;\n    }\n    var virtualRootId = VIRTUAL_ROOT_ID.toString();\n    return Tree.isTree(tslib_1.__spread(vertexes, [{ id: virtualRootId }]), tslib_1.__spread(edges, roots.map(function (node) {\n        return {\n            u: virtualRootId,\n            v: node.id\n        };\n    })));\n};\nTree.parse = function (tree, getId, getChildren, getEdge) {\n    var getIdHandler = getId\n        ? getId\n        : function (node) {\n            return node.id;\n        };\n    var getChildrenHandler = getChildren\n        ? getChildren\n        : function (node) {\n            return node.children;\n        };\n    var vertexes = [];\n    var edges = [];\n    var visitedList = [];\n    function dfs(node) {\n        var id = getIdHandler(node);\n        node.id = id;\n        if (visitedList.indexOf(id) !== -1) {\n            console.error('存在环！');\n            return false;\n        }\n        visitedList.push(id);\n        vertexes.push(node);\n        var children = getChildrenHandler(node);\n        if (children && children.length) {\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                var childId = getIdHandler(child);\n                child.id = childId;\n                var edge = getEdge\n                    ? getEdge(node, child)\n                    : {\n                        u: id,\n                        v: childId\n                    };\n                edges.push(edge);\n                dfs(child);\n            }\n        }\n    }\n    for (var i = 0; i < tree.length; i++) {\n        dfs(tree[i]);\n    }\n    return {\n        vertexes: vertexes,\n        edges: edges\n    };\n};\nexports.default = Tree;\n//# sourceMappingURL=Tree.js.map"]},"metadata":{},"sourceType":"script"}