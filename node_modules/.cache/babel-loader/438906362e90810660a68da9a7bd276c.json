{"ast":null,"code":"import * as dagre from 'dagre';\nimport { find, findIndex } from '../Utils/utils';\nimport { BaseGroupLayout } from './base';\n\n/**\n * 普通图布局\n */\nexport class GraphLayout extends BaseGroupLayout {\n  constructor(\n  /** 节点 */\n  nodes,\n  /** 节点连线 */\n  links,\n  /** 图配置 */\n  config) {\n    super();\n    this.config = void 0;\n    this.nodes = this.getNodes(nodes);\n    this.links = links;\n    this.config = config;\n    this.init();\n  }\n\n  init() {\n    this.g = new dagre.graphlib.Graph(); // 配置\n\n    this.g.setGraph(this.config); // Default to assigning a new object as a label for each new edge.\n\n    this.g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n  }\n\n  layout() {\n    this.nodes.forEach(node => {\n      const {\n        id,\n        width,\n        height\n      } = node;\n      this.g.setNode(id, {\n        id,\n        width,\n        height\n      });\n    });\n    this.links.forEach(link => {\n      const {\n        u,\n        v\n      } = link;\n      this.g.setEdge(u, v);\n    });\n    dagre.layout(this.g);\n    return {\n      nodes: this.nodes.map(node => {\n        const {\n          x,\n          y\n        } = this.g.node(node.id);\n        return { ...node,\n          x,\n          y\n        };\n      }),\n      links: this.links.map(link => {\n        const {\n          points\n        } = this.g.edge({\n          v: link.u,\n          w: link.v\n        });\n        return { ...link,\n          u: link.u,\n          v: link.v,\n          points\n        };\n      })\n    };\n  }\n\n}\n\n/**\n * 带组布局\n */\nexport class GroupGraphLayout extends BaseGroupLayout {\n  /** 渲染结果 */\n  constructor(\n  /** 节点 */\n  nodes,\n  /** 节点连线 */\n  links,\n  /** 组 */\n  groups,\n  /** 组连线 */\n  groupLinks,\n  /** 图配置 */\n  config) {\n    super();\n    this.groupLinks = void 0;\n    this.groupNodeMap = void 0;\n    this.groupLinkMap = void 0;\n    this.config = void 0;\n    this.renderGroups = [];\n    this.renderNodes = [];\n    this.renderNodeLinks = [];\n    this.renderGroupLinks = [];\n    this.preRenderGroups = [];\n    this.preRenderNodes = [];\n    this.preRenderNodeLinks = [];\n    this.preRenderGroupLinks = [];\n    this.init(nodes, links, groups, groupLinks, config);\n  }\n\n  init(\n  /** 节点 */\n  nodes,\n  /** 节点连线 */\n  links,\n  /** 组 */\n  groups,\n  /** 组连线 */\n  groupLinks,\n  /** 图配置 */\n  config) {\n    // node 与 group 要保证顺序稳定，这样布局才能稳定\n    this.nodes = this.getNodes(nodes);\n    this.links = links;\n    this.groups = this.getGroups(groups);\n    this.groupLinks = groupLinks;\n    this.config = config; // 生成组与点的对应关系\n\n    this.groupNodeMap = new Map();\n    this.groupLinkMap = new Map();\n    this.getGroupNodeMap();\n  }\n\n  getGroupNodeMap() {\n    this.groups.forEach(group => {\n      group.vertexes.forEach(vertex => {\n        this.groupNodeMap.set(vertex.id, group);\n      });\n    });\n  }\n\n  getDownGroup(groupId) {\n    return this.groupLinks.filter(link => {\n      return link.u === groupId;\n    }).map(link => {\n      const {\n        v\n      } = link;\n      return find(this.groups, group => {\n        return group.id === v;\n      });\n    });\n  }\n  /** 处理一个 group 与其下游组及组内节点连通 */\n\n\n  processGroupConnect(g, groupId, nodeId = '', forceNoExpand = false) {\n    const downGroups = this.getDownGroup(groupId);\n    const connectId = nodeId || groupId;\n    downGroups.forEach(downGroup => {\n      if (downGroup.vertexes.length === 1) {\n        g.setEdge(connectId, downGroup.vertexes[0].id);\n      } else if (downGroup.expand && !forceNoExpand) {\n        // 展开就相关节点相连\n        const downGroupNodeIds = downGroup.vertexes.map(vertex => vertex.id);\n        this.links.filter(link => {\n          return link.u === connectId && downGroupNodeIds.includes(link.v);\n        }).forEach(link => {\n          g.setEdge(link.u, link.v);\n        });\n      } else {\n        // 未展开就两个 group 相连\n        g.setEdge(connectId, downGroup.id);\n      }\n    });\n  }\n\n  getLayoutInGroup(group) {\n    const g = new dagre.graphlib.Graph(); // 配置\n\n    g.setGraph(this.config.dagreConfig); // Default to assigning a new object as a label for each new edge.\n\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    const groupNodeIds = group.vertexes.map(vertex => vertex.id);\n    const links = [];\n    groupNodeIds.forEach(nodeId => {\n      const node = find(this.nodes, n => {\n        return n.id === nodeId;\n      });\n      g.setNode(nodeId, {\n        id: nodeId,\n        width: node.width,\n        height: node.height\n      }); // 组内节点连接\n\n      this.links.filter(link => {\n        if (link.u === nodeId && this.groupNodeMap.has(link.v)) {\n          const nodeGroup = this.groupNodeMap.get(link.v);\n          return nodeGroup.id === group.id;\n        }\n\n        return false;\n      }).forEach(link => {\n        links.push(link);\n        g.setEdge(nodeId, link.v);\n      });\n    });\n    dagre.layout(g);\n    return {\n      vertexes: group.vertexes.map(vertex => {\n        if (g.hasNode(vertex.id)) {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = g.node(vertex.id);\n          return { ...vertex,\n            x,\n            y,\n            width,\n            height\n          };\n        }\n\n        return vertex;\n      }),\n      edges: links.map(link => {\n        const {\n          points\n        } = g.edge({\n          v: link.u,\n          w: link.v\n        });\n        return { ...link,\n          u: link.u,\n          v: link.v,\n          points\n        };\n      })\n    };\n  }\n  /**\n   * 先获取 Group 的大小，以及 Group 中 node 在 Group 中的位置\n   */\n\n\n  getGroupSize() {\n    const {\n      groupPadding\n    } = this.config;\n    this.groups = this.groups.map(group => {\n      // 当组内只有一个节点时，直接显示节点，没有展开关闭状态\n      // 对于展开的组的内部节点进行布局\n      if (group.vertexes.length !== 1 && group.expand) {\n        let maxChildX = -Infinity;\n        let maxChildY = -Infinity;\n        let minChildX = Infinity;\n        let minChildY = Infinity;\n        const {\n          vertexes,\n          edges\n        } = this.getLayoutInGroup(group);\n        vertexes.forEach(vertex => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = vertex;\n\n          if (maxChildX < x + width / 2 + groupPadding[1]) {\n            maxChildX = x + width / 2 + groupPadding[1];\n          }\n\n          if (maxChildY < y + height / 2 + groupPadding[2]) {\n            maxChildY = y + height / 2 + groupPadding[2];\n          }\n\n          if (minChildX > x - width / 2 - groupPadding[3]) {\n            minChildX = x - width / 2 - groupPadding[3];\n          }\n\n          if (minChildY > y - height / 2 - groupPadding[0]) {\n            minChildY = y - height / 2 - groupPadding[0];\n          }\n        });\n        const links = edges.map(edge => {\n          const points = edge.points.map(point => {\n            return {\n              x: point.x - minChildX,\n              y: point.y - minChildY\n            };\n          });\n          return { ...edge,\n            points\n          };\n        });\n        this.groupLinkMap.set(group.id, links);\n        const groupWidth = maxChildX - minChildX;\n        const groupHeight = maxChildY - minChildY;\n        return { ...group,\n          width: groupWidth,\n          height: groupHeight,\n          vertexes: vertexes.map(vertex => {\n            const {\n              x,\n              y,\n              width,\n              height\n            } = vertex;\n            return { ...vertex,\n              x: x - width / 2 - minChildX,\n              y: y - height / 2 - minChildY\n            };\n          })\n        };\n      }\n\n      return group;\n    });\n  }\n  /**\n   * 对 group 进行布局\n   */\n\n\n  groupLayout() {\n    const nodeLinks = [];\n    const g = new dagre.graphlib.Graph({}); // 配置\n\n    g.setGraph(this.config.dagreConfig); // Default to assigning a new object as a label for each new edge.\n\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    this.groups.forEach(group => {\n      const groupId = group.id;\n\n      if (group.vertexes.length === 1) {\n        // 当组内只有一个节点时，直接显示节点，没有展开关闭状态\n        const {\n          id,\n          width,\n          height\n        } = group.vertexes[0];\n        g.setNode(String(id), {\n          id,\n          width,\n          height\n        });\n        this.processGroupConnect(g, groupId, String(id), true);\n      } else if (!group.expand) {\n        // 没有展开，取组的默认宽高\n        g.setNode(groupId, {\n          id: groupId,\n          width: this.config.defaultGroupWidth,\n          height: this.config.defaultGroupHeight\n        });\n        this.processGroupConnect(g, groupId, '', true);\n      } else {\n        g.setNode(groupId, {\n          id: groupId,\n          width: group.width,\n          height: group.height\n        });\n        this.processGroupConnect(g, groupId, '', true);\n      }\n    });\n    dagre.layout(g);\n    this.groups = this.groups.map(group => {\n      const groupId = group.id;\n\n      if (g.hasNode(group.id)) {\n        const {\n          x,\n          y,\n          width,\n          height\n        } = g.node(groupId);\n        const vertexes = group.vertexes.map(vertex => {\n          return { ...vertex,\n            x: x - width / 2 + vertex.x + vertex.width / 2,\n            y: y - height / 2 + vertex.y + vertex.height / 2\n          };\n        });\n        const edges = this.groupLinkMap.get(groupId) || [];\n        edges.forEach(edge => {\n          const points = edge.points.map(point => {\n            return {\n              x: point.x + (x - width / 2),\n              y: point.y + (y - height / 2)\n            };\n          });\n          nodeLinks.push({ ...edge,\n            points\n          });\n        });\n        return { ...group,\n          x,\n          y,\n          vertexes\n        };\n      }\n\n      return { ...group,\n        vertexes: group.vertexes.map(vertex => {\n          if (g.hasNode(vertex.id)) {\n            const {\n              x,\n              y\n            } = g.node(vertex.id);\n            return { ...vertex,\n              x,\n              y\n            };\n          }\n\n          return vertex;\n        })\n      };\n    });\n    const nodes = this.groups.reduce((pre, cur) => {\n      if (cur.expand || cur.vertexes.length === 1) {\n        return [...pre, ...cur.vertexes];\n      }\n\n      return pre;\n    }, []);\n    this.getGroupNodeMap(); // 先绘制组与组之间的连线，然后在根据组与组之间的连线来绘制节点与节点之间的连线\n    // 一个组与一个组之间，最多只有一条连线，如果一个组内有多条线到另一个组，需要在组内合并\n    // 确定组与组之间的连线路径，同时确定组的点位\n\n    this.groupLinks = this.groupLinks.map(groupLink => {\n      const {\n        u,\n        v\n      } = groupLink; // 第二段起始点\n\n      let startPoint; // 第二段终止点\n\n      let endPoint;\n      const uGroup = find(this.groups, group => group.id === u);\n      const vGroup = find(this.groups, group => group.id === v); // uGroup，有几条出边\n\n      const uGroupLink = this.groupLinks.filter(gl => {\n        return gl.u === u;\n      }).sort((glA, glB) => {\n        const glAGroup = find(this.groups, group => group.id === glA.v);\n        const glBGroup = find(this.groups, group => group.id === glB.v);\n        const {\n          points: glAGroupPoint\n        } = g.edge({\n          v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n          w: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id\n        });\n        const {\n          points: glBGroupPoint\n        } = g.edge({\n          v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n          w: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id\n        });\n\n        if (glAGroupPoint[0].y < glBGroupPoint[0].y) {\n          return -1;\n        }\n\n        return 1;\n      });\n      const uIndex = findIndex(uGroupLink, link => link.v === v);\n\n      if (uGroup.vertexes.length === 1) {\n        // 如果当前组只有一个节点，那么\n        const vertex = uGroup.vertexes[0];\n        startPoint = {\n          x: vertex.x + vertex.width / 2,\n          y: vertex.y - vertex.height / 2 + (uIndex + 1) / (uGroupLink.length + 1) * vertex.height\n        };\n      } else {\n        startPoint = {\n          x: uGroup.x + uGroup.width / 2,\n          y: uGroup.y - uGroup.height / 2 + (uIndex + 1) / (uGroupLink.length + 1) * uGroup.height\n        };\n      } // vGroup，有几条入边\n\n\n      const vGroupLink = this.groupLinks.filter(gl => {\n        return gl.v === v;\n      }).sort((glA, glB) => {\n        const glAGroup = find(this.groups, group => group.id === glA.u);\n        const glBGroup = find(this.groups, group => group.id === glB.u);\n        const {\n          points: glAGroupPoint\n        } = g.edge({\n          v: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id,\n          w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id\n        });\n        const {\n          points: glBGroupPoint\n        } = g.edge({\n          v: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id,\n          w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id\n        });\n\n        if (glAGroupPoint[0].y < glBGroupPoint[0].y) {\n          return -1;\n        }\n\n        return 1;\n      });\n      const vIndex = findIndex(vGroupLink, link => link.u === u);\n\n      if (vGroup.vertexes.length === 1) {\n        // 如果当前组只有一个节点，那么\n        const vertex = vGroup.vertexes[0];\n        endPoint = {\n          x: vertex.x - vertex.width / 2,\n          y: vertex.y - vertex.height / 2 + (vIndex + 1) / (vGroupLink.length + 1) * vertex.height\n        };\n      } else {\n        endPoint = {\n          x: vGroup.x - vGroup.width / 2,\n          y: vGroup.y - vGroup.height / 2 + (vIndex + 1) / (vGroupLink.length + 1) * vGroup.height\n        };\n      }\n\n      const {\n        points\n      } = g.edge({\n        v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n        w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id\n      });\n      let middlePoints = points.slice(1, points.length - 1); // 防止节点出现突转\n\n      if (middlePoints.length === 1) {\n        middlePoints = [{\n          x: middlePoints[0].x,\n          y: endPoint.y\n        }];\n      }\n\n      return { ...groupLink,\n        points: [startPoint, {\n          x: startPoint.x + 10,\n          y: startPoint.y\n        }, ...middlePoints, {\n          x: endPoint.x - 20,\n          y: endPoint.y\n        }, endPoint]\n      };\n    });\n    const groupLinks = [];\n    this.links.filter(link => {\n      const uGroup = this.groupNodeMap.get(link.u);\n      const vGroup = this.groupNodeMap.get(link.v);\n      return uGroup.id !== vGroup.id;\n    }).forEach(link => {\n      const {\n        u,\n        v\n      } = link;\n      const uGroup = this.groupNodeMap.get(u);\n      const vGroup = this.groupNodeMap.get(v);\n      const uNode = find(nodes, node => node.id === u);\n      const vNode = find(nodes, node => node.id === v);\n      const groupLink = find(this.groupLinks, link => {\n        return link.u === uGroup.id && link.v === vGroup.id;\n      });\n      const startPoint = groupLink.points[0];\n      const endPoint = groupLink.points[groupLink.points.length - 1];\n      let point_1 = [];\n\n      if (uGroup.expand) {\n        point_1 = [{\n          x: uNode.x + uNode.width / 2,\n          y: uNode.y\n        }, {\n          x: uNode.x + uNode.width / 2 + 10,\n          y: uNode.y\n        }, {\n          x: startPoint.x - 20,\n          y: startPoint.y\n        }, startPoint];\n      }\n\n      let point_3 = [];\n\n      if (vGroup.expand) {\n        point_3 = [endPoint, {\n          x: endPoint.x + 10,\n          y: endPoint.y\n        }, {\n          x: vNode.x - vNode.width / 2 - 20,\n          y: vNode.y\n        }, {\n          x: vNode.x - vNode.width / 2,\n          y: vNode.y\n        }];\n      }\n\n      groupLinks.push({ ...link,\n        uGroupId: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n        vGroupId: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,\n        groupPoints: [point_1, groupLink.points, point_3]\n      });\n    });\n    return {\n      nodes,\n      nodeLinks,\n      groupLinks\n    };\n  }\n\n  getTween(start, end) {\n    const duration = 100;\n    const times = Math.floor(duration / 16);\n    const paths = [];\n    const interval = (end - start) / times;\n\n    for (let i = 0; i <= times; i++) {\n      paths.push(start + interval * i);\n    }\n\n    return paths;\n  }\n\n  getAnimationPath(pre, current) {\n    const preWidth = pre.width;\n    const preHeight = pre.height;\n    const preX = pre.x;\n    const preY = pre.y;\n    const currentWidth = current.width;\n    const currentHeight = current.height;\n    const currentX = current.x;\n    const currentY = current.y;\n    return {\n      widthPath: this.getTween(preWidth, currentWidth),\n      heightPath: this.getTween(preHeight, currentHeight),\n      xPath: this.getTween(preX, currentX),\n      yPath: this.getTween(preY, currentY)\n    };\n  }\n\n  animation() {\n    this.renderNodes = this.renderNodes.map(renderNode => {\n      const preRenderNode = find(this.preRenderNodes, node => node.id === renderNode.id); // 之前存在\n\n      if (preRenderNode) {\n        const {\n          widthPath,\n          heightPath,\n          xPath,\n          yPath\n        } = this.getAnimationPath(preRenderNode, renderNode);\n        return { ...renderNode,\n          widthPath,\n          heightPath,\n          xPath,\n          yPath,\n          isMount: false,\n          width: preRenderNode.width,\n          height: preRenderNode.height,\n          x: preRenderNode.x,\n          y: preRenderNode.y,\n          opacity: 1\n        };\n      }\n\n      return { ...renderNode,\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      };\n    });\n    this.renderGroups = this.renderGroups.map(renderGroup => {\n      const preRenderGroup = find(this.preRenderGroups, group => group.id === renderGroup.id); // 之前存在\n\n      if (preRenderGroup) {\n        const {\n          widthPath,\n          heightPath,\n          xPath,\n          yPath\n        } = this.getAnimationPath(preRenderGroup, renderGroup);\n        return { ...renderGroup,\n          widthPath,\n          heightPath,\n          xPath,\n          yPath,\n          isMount: false,\n          width: preRenderGroup.width,\n          height: preRenderGroup.height,\n          x: preRenderGroup.x,\n          y: preRenderGroup.y,\n          opacity: 1\n        };\n      }\n\n      return { ...renderGroup,\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      };\n    });\n    this.renderNodeLinks = this.renderNodeLinks.map(renderNodeLink => {\n      const preNodeRenderLink = find(this.renderNodeLinks, link => link.u === renderNodeLink.u && link.v === renderNodeLink.v);\n\n      if (preNodeRenderLink) {\n        return { ...renderNodeLink,\n          isMount: false,\n          opacity: 1\n        };\n      }\n\n      return { ...renderNodeLink,\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      };\n    });\n    this.renderGroupLinks = this.renderGroupLinks.map(renderGroupLink => {\n      const preGroupRenderLink = find(this.renderGroupLinks, link => link.u === renderGroupLink.u && link.v === renderGroupLink.v);\n\n      if (preGroupRenderLink) {\n        return { ...renderGroupLink,\n          isMount: false,\n          opacity: 1\n        };\n      }\n\n      return { ...renderGroupLink,\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      };\n    });\n  }\n\n  update(\n  /** 节点 */\n  nodes,\n  /** 节点连线 */\n  links,\n  /** 组 */\n  groups,\n  /** 组连线 */\n  groupLinks,\n  /** 图配置 */\n  config) {\n    this.init(nodes, links, groups, groupLinks, config);\n  }\n  /**\n   * 布局生成\n   * 当组内只有一个节点时，直接显示节点\n   * 当前组展开时，内部节点与外部组或节点相连接\n   * 当组闭合时，组与相关节点/组连接\n   * 返回组数据，用于渲染\n   * 算法：组内节点独自布局，获得节点在组中的位置以及组的位置，然后组布局\n   */\n\n\n  layout() {\n    this.preRenderNodes = this.renderNodes.map(node => {\n      const {\n        isMount,\n        widthPath,\n        heightPath,\n        xPath,\n        yPath\n      } = node;\n\n      if (isMount) {\n        return node;\n      }\n\n      return { ...node,\n        width: widthPath[widthPath.length - 1],\n        height: heightPath[heightPath.length - 1],\n        x: xPath[xPath.length - 1],\n        y: yPath[yPath.length - 1]\n      };\n    });\n    this.preRenderGroups = this.renderGroups.map(group => {\n      const {\n        isMount,\n        widthPath,\n        heightPath,\n        xPath,\n        yPath\n      } = group;\n\n      if (isMount) {\n        return group;\n      }\n\n      return { ...group,\n        width: widthPath[widthPath.length - 1],\n        height: heightPath[heightPath.length - 1],\n        x: xPath[xPath.length - 1],\n        y: yPath[yPath.length - 1]\n      };\n    });\n    this.preRenderNodeLinks = this.renderNodeLinks;\n    this.preRenderGroupLinks = this.renderGroupLinks;\n    this.getGroupSize();\n    const {\n      nodeLinks,\n      nodes,\n      groupLinks\n    } = this.groupLayout();\n    this.renderGroups = this.groups.filter(group => {\n      return group.vertexes.length !== 1;\n    });\n    this.renderNodes = this.groups.reduce((pre, cur) => {\n      if (cur.expand || cur.vertexes.length === 1) {\n        return [...pre, ...cur.vertexes];\n      }\n\n      return pre;\n    }, []);\n    this.renderNodeLinks = nodeLinks.map(link => {\n      const {\n        u,\n        v\n      } = link;\n      const uNode = find(nodes, node => node.id === u);\n      const vNode = find(nodes, node => node.id === v);\n      const uLinks = nodeLinks.filter(link => link.u === u).sort((linkA, linkB) => {\n        const linkAStartPointY = linkA.points[0].y;\n        const linkBStartPointY = linkB.points[0].y;\n\n        if (linkAStartPointY < linkBStartPointY) {\n          return -1;\n        }\n\n        return 1;\n      });\n      const uNodeIndex = findIndex(uLinks, link => link.v === v);\n      const startPoint = {\n        x: uNode.x + uNode.width / 2,\n        y: uNode.y - uNode.height / 2 + (uNodeIndex + 1) / (uLinks.length + 1) * uNode.height\n      };\n      const vLinks = nodeLinks.filter(link => link.v === v).sort((linkA, linkB) => {\n        const linkAEndPointY = linkA.points[linkA.points.length - 1].y;\n        const linkBEndPointY = linkB.points[linkB.points.length - 1].y;\n\n        if (linkAEndPointY < linkBEndPointY) {\n          return -1;\n        }\n\n        return 1;\n      });\n      const vNodeIndex = findIndex(vLinks, link => link.u === u);\n      const endPoint = {\n        x: vNode.x - vNode.width / 2,\n        y: vNode.y - vNode.height / 2 + (vNodeIndex + 1) / (vLinks.length + 1) * vNode.height\n      };\n      const points = [startPoint, {\n        x: startPoint.x + 10,\n        y: startPoint.y\n      }, ...link.points.slice(1, link.points.length - 1), {\n        x: endPoint.x - 20,\n        y: endPoint.y\n      }, endPoint];\n      return { ...link,\n        points\n      };\n    });\n    this.renderGroupLinks = groupLinks;\n    this.animation();\n    return {\n      renderGroups: this.renderGroups,\n      renderNodes: this.renderNodes,\n      renderNodeLinks: this.renderNodeLinks,\n      renderGroupLinks: this.renderGroupLinks\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/dagre.ts"],"names":["dagre","find","findIndex","BaseGroupLayout","GraphLayout","constructor","nodes","links","config","getNodes","init","g","graphlib","Graph","setGraph","setDefaultEdgeLabel","layout","forEach","node","id","width","height","setNode","link","u","v","setEdge","map","x","y","points","edge","w","GroupGraphLayout","groups","groupLinks","groupNodeMap","groupLinkMap","renderGroups","renderNodes","renderNodeLinks","renderGroupLinks","preRenderGroups","preRenderNodes","preRenderNodeLinks","preRenderGroupLinks","getGroups","Map","getGroupNodeMap","group","vertexes","vertex","set","getDownGroup","groupId","filter","processGroupConnect","nodeId","forceNoExpand","downGroups","connectId","downGroup","length","expand","downGroupNodeIds","includes","getLayoutInGroup","dagreConfig","groupNodeIds","n","has","nodeGroup","get","push","hasNode","edges","getGroupSize","groupPadding","maxChildX","Infinity","maxChildY","minChildX","minChildY","point","groupWidth","groupHeight","groupLayout","nodeLinks","String","defaultGroupWidth","defaultGroupHeight","reduce","pre","cur","groupLink","startPoint","endPoint","uGroup","vGroup","uGroupLink","gl","sort","glA","glB","glAGroup","glBGroup","glAGroupPoint","glBGroupPoint","uIndex","vGroupLink","vIndex","middlePoints","slice","uNode","vNode","point_1","point_3","uGroupId","vGroupId","groupPoints","getTween","start","end","duration","times","Math","floor","paths","interval","i","getAnimationPath","current","preWidth","preHeight","preX","preY","currentWidth","currentHeight","currentX","currentY","widthPath","heightPath","xPath","yPath","animation","renderNode","preRenderNode","isMount","opacity","opacityPath","renderGroup","preRenderGroup","renderNodeLink","preNodeRenderLink","renderGroupLink","preGroupRenderLink","update","uLinks","linkA","linkB","linkAStartPointY","linkBStartPointY","uNodeIndex","vLinks","linkAEndPointY","linkBEndPointY","vNodeIndex"],"mappings":"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","sourcesContent":["import * as dagre from 'dagre';\n\nimport { Vertex, BaseVertex, Edge, BaseEdge, VertexGroup } from '../type';\nimport { Point } from '../Utils/graph';\nimport { find, findIndex } from '../Utils/utils';\nimport { BaseGroupLayout } from './base';\n\nexport interface LayoutVertex extends BaseVertex {\n  name?: string;\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  isMount?: boolean;\n  opacity?: number;\n\n  widthPath?: number[];\n  heightPath?: number[];\n  xPath?: number[];\n  yPath?: number[];\n  opacityPath?: number[];\n}\n\nexport interface LayoutGroupVertex extends BaseVertex {\n  name: string;\n  expand: boolean;\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  isMount?: boolean;\n  opacity?: number;\n\n  widthPath?: number[];\n  heightPath?: number[];\n  xPath?: number[];\n  yPath?: number[];\n  opacityPath?: number[];\n}\n\nexport interface LayoutEdge extends BaseEdge {\n  points?: Point[];\n  isMount?: boolean;\n  opacity?: number;\n\n  opacityPath?: number[];\n}\n\n/**\n * 普通图布局\n */\nexport class GraphLayout<\n  N extends LayoutVertex,\n  NL extends LayoutEdge\n> extends BaseGroupLayout<N, NL, any> {\n  config: dagre.GraphLabel;\n\n  constructor(\n    /** 节点 */\n    nodes: Array<Vertex<N>>,\n    /** 节点连线 */\n    links: Array<Edge<NL>>,\n    /** 图配置 */\n    config: dagre.GraphLabel\n  ) {\n    super();\n    this.nodes = this.getNodes(nodes);\n    this.links = links;\n    this.config = config;\n    this.init();\n  }\n\n  init() {\n    this.g = new dagre.graphlib.Graph();\n    // 配置\n    this.g.setGraph(this.config);\n    // Default to assigning a new object as a label for each new edge.\n    this.g.setDefaultEdgeLabel(function() {\n      return {};\n    });\n  }\n\n  layout(): {\n    nodes: Vertex<N>[];\n    links: Edge<NL>[];\n  } {\n    this.nodes.forEach(node => {\n      const { id, width, height } = node;\n      this.g.setNode(id, { id, width, height });\n    });\n\n    this.links.forEach(link => {\n      const { u, v } = link;\n      this.g.setEdge(u, v);\n    });\n\n    dagre.layout(this.g);\n\n    return {\n      nodes: this.nodes.map(node => {\n        const { x, y } = this.g.node(node.id);\n        return {\n          ...(node as object),\n          x,\n          y\n        } as N;\n      }),\n      links: this.links.map(link => {\n        const { points } = this.g.edge({\n          v: link.u,\n          w: link.v\n        });\n        return {\n          ...(link as object),\n          u: link.u,\n          v: link.v,\n          points\n        } as NL;\n      })\n    };\n  }\n}\n\ninterface GroupConfig {\n  /** dagre 配置 */\n  dagreConfig: dagre.GraphLabel;\n  /** 组宽度 */\n  defaultGroupWidth: number;\n  /** 组高度 */\n  defaultGroupHeight: number;\n  /** group padding */\n  groupPadding: number[];\n}\n\n/**\n * 带组布局\n */\nexport class GroupGraphLayout<\n  N extends LayoutVertex,\n  NL extends LayoutEdge,\n  G extends LayoutGroupVertex,\n  GL extends LayoutEdge\n> extends BaseGroupLayout<N, NL, G> {\n  groupLinks: Edge<GL>[];\n  groupNodeMap: Map<string, VertexGroup<N, G>>;\n  groupLinkMap: Map<string, NL[]>;\n  config: GroupConfig;\n  /** 渲染结果 */\n  renderGroups: VertexGroup<N, G>[] = [];\n  renderNodes: Vertex<N>[] = [];\n  renderNodeLinks: Edge<NL>[] = [];\n  renderGroupLinks: Edge<NL & {\n    uGroupId: string;\n    vGroupId: string;\n    groupPoints: [Point[], Point[], Point[]]\n  }>[] = [];\n  preRenderGroups: VertexGroup<N, G>[] = [];\n  preRenderNodes: Vertex<N>[] = [];\n  preRenderNodeLinks: Edge<NL>[] = [];\n  preRenderGroupLinks: Edge<NL & {\n    uGroupId: string;\n    vGroupId: string;\n    groupPoints: [Point[], Point[], Point[]]\n  }>[] = [];\n\n  constructor(\n    /** 节点 */\n    nodes: Array<Vertex<N>>,\n    /** 节点连线 */\n    links: Array<Edge<NL>>,\n    /** 组 */\n    groups: Array<VertexGroup<N, G>>,\n    /** 组连线 */\n    groupLinks: Array<Edge<GL>>,\n    /** 图配置 */\n    config: GroupConfig\n  ) {\n    super();\n    this.init(nodes, links, groups, groupLinks, config);\n  }\n\n  init(\n    /** 节点 */\n    nodes: Array<Vertex<N>>,\n    /** 节点连线 */\n    links: Array<Edge<NL>>,\n    /** 组 */\n    groups: Array<VertexGroup<N, G>>,\n    /** 组连线 */\n    groupLinks: Array<Edge<GL>>,\n    /** 图配置 */\n    config: GroupConfig\n  ) {\n    // node 与 group 要保证顺序稳定，这样布局才能稳定\n    this.nodes = this.getNodes(nodes);\n    this.links = links;\n    this.groups = this.getGroups(groups);\n    this.groupLinks = groupLinks;\n    this.config = config;\n    // 生成组与点的对应关系\n    this.groupNodeMap = new Map();\n    this.groupLinkMap = new Map();\n\n    this.getGroupNodeMap();\n  }\n\n  getGroupNodeMap() {\n    this.groups.forEach(group => {\n      group.vertexes.forEach(vertex => {\n        this.groupNodeMap.set(vertex.id, group);\n      });\n    });\n  }\n\n  getDownGroup(groupId: string): Array<VertexGroup<N, G>> {\n    return this.groupLinks\n      .filter(link => {\n        return link.u === groupId;\n      })\n      .map(link => {\n        const { v } = link;\n        return find(this.groups, group => {\n          return group.id === v;\n        });\n      });\n  }\n\n  /** 处理一个 group 与其下游组及组内节点连通 */\n  processGroupConnect(g: dagre.graphlib.Graph, groupId: string, nodeId: string = '', forceNoExpand: boolean = false) {\n    const downGroups = this.getDownGroup(groupId);\n    const connectId = nodeId || groupId;\n    downGroups.forEach(downGroup => {\n      if (downGroup.vertexes.length === 1) {\n        g.setEdge(connectId, downGroup.vertexes[0].id);\n      } else if (downGroup.expand && !forceNoExpand) {\n        // 展开就相关节点相连\n        const downGroupNodeIds = downGroup.vertexes.map(vertex => vertex.id);\n        this.links\n          .filter(link => {\n            return link.u === connectId && downGroupNodeIds.includes(link.v);\n          })\n          .forEach(link => {\n            g.setEdge(link.u, link.v);\n          });\n      } else {\n        // 未展开就两个 group 相连\n        g.setEdge(connectId, downGroup.id);\n      }\n    });\n  }\n\n  getLayoutInGroup(group: VertexGroup<N, G>) {\n    const g = new dagre.graphlib.Graph();\n    // 配置\n    g.setGraph(this.config.dagreConfig);\n    // Default to assigning a new object as a label for each new edge.\n    g.setDefaultEdgeLabel(function() {\n      return {};\n    });\n\n    const groupNodeIds = group.vertexes.map(vertex => vertex.id);\n    const links: Edge<NL>[] = [];\n    groupNodeIds.forEach(nodeId => {\n      const node = find(this.nodes, n => {\n        return n.id === nodeId;\n      });\n      g.setNode(nodeId, {\n        id: nodeId,\n        width: node.width,\n        height: node.height\n      });\n\n      // 组内节点连接\n      this.links\n        .filter(link => {\n          if (link.u === nodeId && this.groupNodeMap.has(link.v)) {\n            const nodeGroup = this.groupNodeMap.get(link.v);\n            return nodeGroup.id === group.id;\n          }\n          return false;\n        })\n        .forEach(link => {\n          links.push(link);\n          g.setEdge(nodeId, link.v);\n        });\n    });\n\n    dagre.layout(g);\n\n    return {\n      vertexes: group.vertexes.map(vertex => {\n        if (g.hasNode(vertex.id)) {\n          const { x, y, width, height } = g.node(vertex.id);\n          return {\n            ...(vertex as object),\n            x,\n            y,\n            width,\n            height\n          } as N;\n        }\n        return vertex;\n      }),\n      edges: links.map(link => {\n        const { points } = g.edge({\n          v: link.u,\n          w: link.v\n        });\n        return {\n          ...(link as object),\n          u: link.u,\n          v: link.v,\n          points\n        } as NL;\n      })\n    };\n  }\n\n  /**\n   * 先获取 Group 的大小，以及 Group 中 node 在 Group 中的位置\n   */\n  getGroupSize() {\n    const { groupPadding } = this.config;\n\n    this.groups = this.groups.map(group => {\n      // 当组内只有一个节点时，直接显示节点，没有展开关闭状态\n      // 对于展开的组的内部节点进行布局\n      if (group.vertexes.length !== 1 && group.expand) {\n        let maxChildX = -Infinity;\n        let maxChildY = -Infinity;\n        let minChildX = Infinity;\n        let minChildY = Infinity;\n\n        const { vertexes, edges } = this.getLayoutInGroup(group);\n\n        vertexes.forEach(vertex => {\n          const { x, y, width, height } = vertex;\n\n          if (maxChildX < x + width / 2 + groupPadding[1]) {\n            maxChildX = x + width / 2 + groupPadding[1];\n          }\n          if (maxChildY < y + height / 2 + groupPadding[2]) {\n            maxChildY = y + height / 2 + groupPadding[2];\n          }\n          if (minChildX > x - width / 2 - groupPadding[3]) {\n            minChildX = x - width / 2 - groupPadding[3];\n          }\n          if (minChildY > y - height / 2 - groupPadding[0]) {\n            minChildY = y - height / 2 - groupPadding[0];\n          }\n        });\n\n        const links: NL[] = edges.map(edge => {\n          const points = edge.points.map(point => {\n            return { x: point.x - minChildX, y: point.y - minChildY };\n          });\n\n          return {\n            ...(edge as object),\n            points\n          } as NL;\n        });\n\n        this.groupLinkMap.set(group.id, links);\n\n        const groupWidth = maxChildX - minChildX;\n        const groupHeight = maxChildY - minChildY;\n\n        return {\n          ...(group as object),\n          width: groupWidth,\n          height: groupHeight,\n          vertexes: vertexes.map(vertex => {\n            const { x, y, width, height } = vertex;\n            return {\n              ...(vertex as object),\n              x: x - width / 2 - minChildX,\n              y: y - height / 2 - minChildY\n            } as N;\n          })\n        } as VertexGroup<N, G>;\n      }\n\n      return group;\n    });\n  }\n\n  /**\n   * 对 group 进行布局\n   */\n  groupLayout() {\n    const nodeLinks: NL[] = [];\n    const g = new dagre.graphlib.Graph({});\n    // 配置\n    g.setGraph(this.config.dagreConfig);\n    // Default to assigning a new object as a label for each new edge.\n    g.setDefaultEdgeLabel(function() {\n      return {};\n    });\n\n    this.groups.forEach(group => {\n      const groupId = group.id;\n      if (group.vertexes.length === 1) {\n        // 当组内只有一个节点时，直接显示节点，没有展开关闭状态\n        const { id, width, height } = group.vertexes[0];\n        g.setNode(String(id), { id, width, height });\n        this.processGroupConnect(g, groupId, String(id), true);\n      } else if (!group.expand) {\n        // 没有展开，取组的默认宽高\n        g.setNode(groupId, {\n          id: groupId,\n          width: this.config.defaultGroupWidth,\n          height: this.config.defaultGroupHeight\n        });\n        this.processGroupConnect(g, groupId, '', true);\n      } else {\n        g.setNode(groupId, {\n          id: groupId,\n          width: group.width,\n          height: group.height\n        });\n        this.processGroupConnect(g, groupId, '', true);\n      }\n    });\n\n    dagre.layout(g);\n\n    this.groups = this.groups.map(group => {\n      const groupId = group.id;\n      if (g.hasNode(group.id)) {\n        const { x, y, width, height } = g.node(groupId);\n\n        const vertexes = group.vertexes.map(vertex => {\n          return {\n            ...(vertex as object),\n            x: x - width / 2 + vertex.x + vertex.width / 2,\n            y: y - height / 2 + vertex.y + vertex.height / 2\n          } as Vertex<N>;\n        });\n\n        const edges = this.groupLinkMap.get(groupId) || [];\n\n        edges.forEach(edge => {\n          const points = edge.points.map(point => {\n            return {\n              x: point.x + (x - width / 2),\n              y: point.y + (y - height / 2)\n            };\n          });\n\n          nodeLinks.push({\n            ...(edge as object),\n            points\n          } as NL);\n        });\n\n        return {\n          ...(group as object),\n          x,\n          y,\n          vertexes\n        } as VertexGroup<N, G>;\n      }\n\n      return {\n        ...(group as object),\n        vertexes: group.vertexes.map(vertex => {\n          if (g.hasNode(vertex.id)) {\n            const { x, y } = g.node(vertex.id);\n            return {\n              ...(vertex as object),\n              x,\n              y\n            };\n          }\n          return vertex;\n        })\n      } as VertexGroup<N, G>;\n    });\n\n    const nodes = this.groups.reduce((pre, cur) => {\n      if (cur.expand || cur.vertexes.length === 1) {\n        return [...pre, ...cur.vertexes];\n      }\n      return pre;\n    }, []);\n    this.getGroupNodeMap();\n\n    // 先绘制组与组之间的连线，然后在根据组与组之间的连线来绘制节点与节点之间的连线\n    // 一个组与一个组之间，最多只有一条连线，如果一个组内有多条线到另一个组，需要在组内合并\n\n    // 确定组与组之间的连线路径，同时确定组的点位\n    this.groupLinks = this.groupLinks.map(groupLink => {\n      const { u, v } = groupLink;\n\n      // 第二段起始点\n      let startPoint: Point;\n      // 第二段终止点\n      let endPoint: Point;\n\n      const uGroup = find(this.groups, (group) => group.id === u);\n      const vGroup = find(this.groups, (group) => group.id === v);\n\n      // uGroup，有几条出边\n      const uGroupLink = this.groupLinks.filter(gl => {\n        return gl.u === u;\n      }).sort((glA, glB) => {\n        const glAGroup = find(this.groups, (group) => group.id === glA.v);\n        const glBGroup = find(this.groups, (group) => group.id === glB.v);\n\n        const { points: glAGroupPoint } = g.edge({\n          v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n          w: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id,\n        });\n\n        const { points: glBGroupPoint } = g.edge({\n          v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n          w: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id,\n        });\n\n        if (glAGroupPoint[0].y < glBGroupPoint[0].y) {\n          return -1;\n        }\n        return 1;\n      });\n\n      const uIndex = findIndex(uGroupLink, link => link.v === v);\n\n      if (uGroup.vertexes.length === 1) {\n        // 如果当前组只有一个节点，那么\n        const vertex = uGroup.vertexes[0];\n        startPoint = {\n          x: vertex.x + vertex.width / 2,\n          y: vertex.y - vertex.height / 2 + ((uIndex + 1) / (uGroupLink.length + 1)) * vertex.height,\n        };\n      } else {\n        startPoint = {\n          x: uGroup.x + uGroup.width / 2,\n          y: uGroup.y - uGroup.height / 2 + ((uIndex + 1) / (uGroupLink.length + 1)) * uGroup.height,\n        };\n      }\n\n      // vGroup，有几条入边\n      const vGroupLink = this.groupLinks.filter(gl => {\n        return gl.v === v;\n      }).sort((glA, glB) => {\n        const glAGroup = find(this.groups, (group) => group.id === glA.u);\n        const glBGroup = find(this.groups, (group) => group.id === glB.u);\n\n        const { points: glAGroupPoint } = g.edge({\n          v: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id,\n          w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,\n        });\n\n        const { points: glBGroupPoint } = g.edge({\n          v: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id,\n          w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,\n        });\n        \n        if (glAGroupPoint[0].y < glBGroupPoint[0].y) {\n          return -1;\n        }\n        return 1;\n      });\n\n      const vIndex = findIndex(vGroupLink, link => link.u === u);\n      \n      if (vGroup.vertexes.length === 1) {\n        // 如果当前组只有一个节点，那么\n        const vertex = vGroup.vertexes[0];\n        endPoint = {\n          x: vertex.x - vertex.width / 2,\n          y: vertex.y - vertex.height / 2 + ((vIndex + 1) / (vGroupLink.length + 1)) * vertex.height,\n        };\n      } else {\n        endPoint = {\n          x: vGroup.x - vGroup.width / 2,\n          y: vGroup.y - vGroup.height / 2 + ((vIndex + 1) / (vGroupLink.length + 1)) * vGroup.height,\n        }\n      }\n\n      const { points } = g.edge({\n        v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n        w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,\n      });\n\n      let middlePoints = points.slice(1, points.length - 1);\n      \n      // 防止节点出现突转\n      if (middlePoints.length === 1) {\n        middlePoints = [{ x: middlePoints[0].x, y: endPoint.y }];\n      }\n\n      return {\n        ...(groupLink as object),\n        points: [\n          startPoint,\n          { x: startPoint.x + 10, y: startPoint.y },\n          ...middlePoints,\n          { x: endPoint.x - 20, y: endPoint.y },\n          endPoint\n        ]\n      } as Edge<GL>;\n    });\n\n    const groupLinks: (NL & {\n      uGroupId: string;\n      vGroupId: string;\n      groupPoints: [Point[], Point[], Point[]]\n    })[] = [];\n    \n    this.links\n      .filter(link => {\n        const uGroup = this.groupNodeMap.get(link.u);\n        const vGroup = this.groupNodeMap.get(link.v);\n        return uGroup.id !== vGroup.id;\n      }).forEach(link => {\n        const { u, v } = link;\n\n        const uGroup = this.groupNodeMap.get(u);\n        const vGroup = this.groupNodeMap.get(v);\n        const uNode = find(nodes, node => node.id === u);\n        const vNode = find(nodes, node => node.id === v);\n\n        const groupLink = find(this.groupLinks, (link) => {\n          return link.u === uGroup.id && link.v === vGroup.id;\n        });\n\n        const startPoint = groupLink.points[0];\n        const endPoint = groupLink.points[groupLink.points.length - 1];\n\n        let point_1: Point[] = [];\n        if (uGroup.expand) {\n          point_1 = [\n            { x: uNode.x + uNode.width / 2, y: uNode.y },\n            { x: uNode.x + uNode.width / 2 + 10, y: uNode.y },\n            { x: startPoint.x - 20, y: startPoint.y },\n            startPoint\n          ];\n        }\n\n        let point_3: Point[] = [];\n        if (vGroup.expand) {\n          point_3 = [\n            endPoint,\n            { x: endPoint.x + 10, y: endPoint.y },\n            { x: vNode.x - vNode.width / 2 - 20, y: vNode.y },\n            { x: vNode.x - vNode.width / 2, y: vNode.y },\n          ];\n        }\n\n        groupLinks.push({\n          ...(link as object),\n          uGroupId: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,\n          vGroupId: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,\n          groupPoints: [point_1, groupLink.points, point_3],\n        } as (NL & {\n          uGroupId: string;\n          vGroupId: string;\n          groupPoints: [Point[], Point[], Point[]]\n        }));\n      });\n\n    return {\n      nodes,\n      nodeLinks,\n      groupLinks\n    };\n  }\n\n  getTween(start: number, end: number) {\n    const duration = 100;\n    const times = Math.floor(duration / 16);\n\n    const paths = [];\n    const interval = (end - start) / times;\n    for (let i = 0; i <= times; i++) {\n      paths.push(start + interval * i);\n    }\n\n    return paths;\n  }\n\n  getAnimationPath(pre: LayoutVertex | LayoutGroupVertex, current: LayoutVertex | LayoutGroupVertex) {\n    const preWidth = pre.width;\n    const preHeight = pre.height;\n    const preX = pre.x;\n    const preY = pre.y;\n    const currentWidth = current.width;\n    const currentHeight = current.height;\n    const currentX = current.x;\n    const currentY = current.y;\n\n    return {\n      widthPath: this.getTween(preWidth, currentWidth),\n      heightPath: this.getTween(preHeight, currentHeight),\n      xPath: this.getTween(preX, currentX),\n      yPath: this.getTween(preY, currentY)\n    };\n  }\n\n  animation() {\n    this.renderNodes = this.renderNodes.map(renderNode => {\n      const preRenderNode = find(this.preRenderNodes, node => node.id === renderNode.id);\n      // 之前存在\n      if (preRenderNode) {\n        const { widthPath, heightPath, xPath, yPath } = this.getAnimationPath(preRenderNode, renderNode);\n        return {\n          ...(renderNode as object),\n          widthPath,\n          heightPath,\n          xPath,\n          yPath,\n          isMount: false,\n          width: preRenderNode.width,\n          height: preRenderNode.height,\n          x: preRenderNode.x,\n          y: preRenderNode.y,\n          opacity: 1\n        } as N;\n      }\n      return {\n        ...(renderNode as object),\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      } as N;\n    });\n    this.renderGroups = this.renderGroups.map(renderGroup => {\n      const preRenderGroup = find(this.preRenderGroups, group => group.id === renderGroup.id);\n      // 之前存在\n      if (preRenderGroup) {\n        const { widthPath, heightPath, xPath, yPath } = this.getAnimationPath(preRenderGroup, renderGroup);\n        return {\n          ...(renderGroup as object),\n          widthPath,\n          heightPath,\n          xPath,\n          yPath,\n          isMount: false,\n          width: preRenderGroup.width,\n          height: preRenderGroup.height,\n          x: preRenderGroup.x,\n          y: preRenderGroup.y,\n          opacity: 1\n        } as VertexGroup<N, G>;\n      }\n      return {\n        ...(renderGroup as object),\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      } as VertexGroup<N, G>;\n    });\n    this.renderNodeLinks = this.renderNodeLinks.map(renderNodeLink => {\n      const preNodeRenderLink = find(this.renderNodeLinks, link => link.u === renderNodeLink.u && link.v === renderNodeLink.v);\n      if (preNodeRenderLink) {\n        return {\n          ...(renderNodeLink as object),\n          isMount: false,\n          opacity: 1\n        } as Edge<NL>;\n      }\n      return {\n        ...(renderNodeLink as object),\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      } as Edge<NL>;\n    });\n    this.renderGroupLinks = this.renderGroupLinks.map(renderGroupLink => {\n      const preGroupRenderLink = find(this.renderGroupLinks, link => link.u === renderGroupLink.u && link.v === renderGroupLink.v);\n      if (preGroupRenderLink) {\n        return {\n          ...(renderGroupLink as object),\n          isMount: false,\n          opacity: 1\n        } as Edge<NL & {\n          uGroupId: string;\n          vGroupId: string;\n          groupPoints: [Point[], Point[], Point[]]\n        }>;\n      }\n      return {\n        ...(renderGroupLink as object),\n        isMount: true,\n        opacity: 0,\n        opacityPath: this.getTween(0, 1)\n      } as Edge<NL & {\n        uGroupId: string;\n        vGroupId: string;\n        groupPoints: [Point[], Point[], Point[]]\n      }>;\n    });\n  }\n\n  update(\n    /** 节点 */\n    nodes: Array<Vertex<N>>,\n    /** 节点连线 */\n    links: Array<Edge<NL>>,\n    /** 组 */\n    groups: Array<VertexGroup<N, G>>,\n    /** 组连线 */\n    groupLinks: Array<Edge<GL>>,\n    /** 图配置 */\n    config: GroupConfig\n  ) {\n    this.init(nodes, links, groups, groupLinks, config);\n  }\n\n  /**\n   * 布局生成\n   * 当组内只有一个节点时，直接显示节点\n   * 当前组展开时，内部节点与外部组或节点相连接\n   * 当组闭合时，组与相关节点/组连接\n   * 返回组数据，用于渲染\n   * 算法：组内节点独自布局，获得节点在组中的位置以及组的位置，然后组布局\n   */\n  layout(): {\n    renderGroups: VertexGroup<N, G>[];\n    renderNodes: Vertex<N>[];\n    renderNodeLinks: Edge<NL>[];\n    renderGroupLinks: Edge<NL & {\n      uGroupId: string;\n      vGroupId: string;\n      groupPoints: [Point[], Point[], Point[]]\n    }>[];\n  } {\n    this.preRenderNodes = this.renderNodes.map(node => {\n      const { isMount, widthPath, heightPath, xPath, yPath } = node;\n      if (isMount) {\n        return node;\n      }\n      return {\n        ...(node as object),\n        width: widthPath[widthPath.length - 1],\n        height: heightPath[heightPath.length - 1],\n        x: xPath[xPath.length - 1],\n        y: yPath[yPath.length - 1]\n      } as N;\n    });\n    this.preRenderGroups = this.renderGroups.map(group => {\n      const { isMount, widthPath, heightPath, xPath, yPath } = group;\n      if (isMount) {\n        return group;\n      }\n      return {\n        ...(group as object),\n        width: widthPath[widthPath.length - 1],\n        height: heightPath[heightPath.length - 1],\n        x: xPath[xPath.length - 1],\n        y: yPath[yPath.length - 1]\n      } as VertexGroup<N, G>;\n    });\n    this.preRenderNodeLinks = this.renderNodeLinks;\n    this.preRenderGroupLinks = this.renderGroupLinks;\n\n    this.getGroupSize();\n    const { nodeLinks, nodes, groupLinks } = this.groupLayout();\n\n    this.renderGroups = this.groups.filter((group) => {\n      return group.vertexes.length !== 1;\n    });\n    \n    this.renderNodes = this.groups.reduce((pre, cur) => {\n      if (cur.expand || cur.vertexes.length === 1) {\n        return [\n          ...pre,\n          ...cur.vertexes,\n        ];\n      }\n      return pre;\n    }, []);\n\n    this.renderNodeLinks = nodeLinks.map(link => {\n      const { u, v } = link;\n\n      const uNode = find(nodes, node => node.id === u);\n      const vNode = find(nodes, node => node.id === v);\n\n      const uLinks = nodeLinks\n        .filter(link => link.u === u)\n        .sort((linkA, linkB) => {\n          const linkAStartPointY = linkA.points[0].y;\n          const linkBStartPointY = linkB.points[0].y;\n          if (linkAStartPointY < linkBStartPointY) {\n            return -1;\n          }\n          return 1;\n        });\n\n      const uNodeIndex = findIndex(uLinks, link => link.v === v);\n      const startPoint = {\n        x: uNode.x + uNode.width / 2,\n        y: uNode.y - uNode.height / 2 + ((uNodeIndex + 1) / (uLinks.length + 1)) * uNode.height\n      };\n\n      const vLinks = nodeLinks\n        .filter(link => link.v === v)\n        .sort((linkA, linkB) => {\n          const linkAEndPointY = linkA.points[linkA.points.length - 1].y;\n          const linkBEndPointY = linkB.points[linkB.points.length - 1].y;\n          if (linkAEndPointY < linkBEndPointY) {\n            return -1;\n          }\n          return 1;\n        });\n\n      const vNodeIndex = findIndex(vLinks, link => link.u === u);\n      const endPoint = {\n        x: vNode.x - vNode.width / 2,\n        y: vNode.y - vNode.height / 2 + ((vNodeIndex + 1) / (vLinks.length + 1)) * vNode.height\n      };\n\n      const points = [\n        startPoint,\n        { x: startPoint.x + 10, y: startPoint.y },\n        ...link.points.slice(1, link.points.length - 1),\n        { x: endPoint.x - 20, y: endPoint.y },\n        endPoint\n      ];\n\n      return {\n        ...(link as object),\n        points\n      } as NL;\n    });\n\n    this.renderGroupLinks = groupLinks;\n    this.animation();\n\n    return {\n      renderGroups: this.renderGroups,\n      renderNodes: this.renderNodes,\n      renderNodeLinks: this.renderNodeLinks,\n      renderGroupLinks: this.renderGroupLinks,\n    };\n  }\n}"]},"metadata":{},"sourceType":"module"}