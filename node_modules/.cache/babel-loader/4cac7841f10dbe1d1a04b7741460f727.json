{"ast":null,"code":"/**\n* @description Bubble Tree\n*/\nimport { Matrix, LinkInfo } from './define';\nimport { getControlPoint, distance } from '../../Utils/graph';\nimport * as _ from 'lodash';\n\nfunction calcRadius(maxRadius, maxSize, minSize) {\n  if (maxSize === minSize) {\n    return () => {\n      return maxRadius;\n    };\n  }\n\n  const minRadius = maxRadius * 0.7;\n  const k = (maxSize - minSize) / (maxRadius - minRadius);\n  const b = minSize - minRadius * k;\n  return size => {\n    return (size - b) / k;\n  };\n}\n\n;\n\nfunction randomNumber(start, end) {\n  return Math.random() * (end - start) + start;\n}\n\n;\n\nclass defaultProps {\n  constructor() {\n    this.data = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.rowCount = void 0;\n    this.minSize = void 0;\n    this.maxSize = void 0;\n  }\n\n}\n\nexport class Bubble {\n  // 数据\n  // Bubble模型矩阵\n  // Bubble模型行矩阵\n  // Bubble模型列矩阵\n  // 每一行的高度\n  // 每一列的宽度\n  // 行的个数\n  // 列的个数\n  // TODO: 待去除\n  // 圆的最大值\n  // 圆的最小值\n  // 边\n  constructor({\n    data,\n    width,\n    height,\n    rowCount,\n    minSize,\n    maxSize\n  }) {\n    this.data = void 0;\n    this.matrix = [];\n    this.matrixRows = [];\n    this.matrixColumns = [];\n    this.heightInterval = void 0;\n    this.widthInterval = void 0;\n    this.rowCount = void 0;\n    this.columnCount = void 0;\n    this.maxSize = void 0;\n    this.minSize = void 0;\n    this.edges = [];\n    // 初始化\n    this.init(data, width, height, rowCount, maxSize, minSize);\n  }\n\n  init(data, width, height, rowCount, maxSize, minSize) {\n    this.data = data;\n    this.rowCount = rowCount;\n    this.maxSize = maxSize;\n    this.minSize = minSize;\n    this.columnCount = Math.ceil((data || []).length / rowCount); // 每一行的高度\n\n    this.heightInterval = height / rowCount; // 每一列的宽度\n\n    this.widthInterval = width / this.columnCount; // 将画布分割为[row,column]的矩阵\n\n    for (let i = 0; i < rowCount; i++) {\n      this.matrixRows.push({\n        l: i * this.heightInterval,\n        r: (i + 1) * this.heightInterval\n      });\n    }\n\n    for (let i = 0; i < this.columnCount; i++) {\n      this.matrixColumns.push({\n        l: i * this.widthInterval,\n        r: (i + 1) * this.widthInterval\n      });\n    }\n  } // 获取节点数据\n\n\n  getNodes() {\n    const radiusF = calcRadius(_.min([this.heightInterval / 2, this.widthInterval / 2]) * 0.9, this.maxSize, this.minSize);\n    const nodes = (this.data || []).map(node => {\n      // 根据权重分配半径\n      const radius = radiusF(node.value);\n      return {\n        id: String(node.id),\n        name: node.name,\n        value: node.value,\n        radius\n      };\n    });\n    const allCount = this.rowCount * this.columnCount;\n    const countList = Object.keys(Array.from({\n      length: allCount\n    })).map(item => {\n      return +item;\n    }).sort((a, b) => {\n      return Math.random() > 0.5 ? -1 : 1;\n    });\n    const matrix = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n      const rowIndex = Math.floor(countList[i] / this.columnCount);\n      const columnIndex = countList[i] % this.columnCount;\n      const radius = nodes[i].radius;\n      /** 存在风险，直径长度超过interval时，依赖手动设置行数rowCount */\n\n      const randomX = randomNumber(this.matrixColumns[columnIndex].l + radius, this.matrixColumns[columnIndex].r - radius);\n      const randomY = randomNumber(this.matrixRows[rowIndex].l + radius, this.matrixRows[rowIndex].r - radius); // 标签采用四分位模型\n\n      matrix.push({\n        node: nodes[i],\n        rowIndex,\n        columnIndex,\n        widthRange: this.matrixColumns[columnIndex],\n        heightRange: this.matrixRows[rowIndex],\n        center: {\n          x: randomX,\n          y: randomY\n        },\n        radius\n      });\n    }\n\n    this.matrix = matrix;\n    return matrix;\n  } // 获取边数据\n\n\n  getLinks() {\n    const dupliEdges = _.flatten((this.data || []).map(edge => {\n      return (edge.siblings || []).map(end => ({\n        u: String(edge.id),\n        v: String(end.id),\n        bothway: false\n      }));\n    }));\n\n    dupliEdges.forEach(item => {\n      const edge = _.find(this.edges, o => o.u === item.v && o.v === item.u);\n\n      if (!edge) {\n        this.edges.push(item);\n      } else {\n        edge.bothway = true;\n      }\n    }); // Bubble模型边信息\n\n    const link = [];\n    this.edges.forEach(edge => {\n      const {\n        u,\n        v,\n        bothway\n      } = edge;\n\n      const startNode = _.find(this.matrix, item => {\n        return String(item.node.id) === String(u);\n      });\n\n      const initStartPoint = startNode.center;\n\n      const endNode = _.find(this.matrix, item => {\n        return String(item.node.id) === String(v);\n      });\n\n      const initEndPoint = endNode.center;\n      const initControlPoint = getControlPoint(initStartPoint, initEndPoint, 0.2, 1);\n      const startDis = distance(initStartPoint, initControlPoint);\n      const startPoint = {\n        x: initStartPoint.x + (initControlPoint.x - initStartPoint.x) * (startNode.radius / startDis),\n        y: initStartPoint.y + (initControlPoint.y - initStartPoint.y) * (startNode.radius / startDis)\n      };\n      const endDis = distance(initControlPoint, initEndPoint);\n      const endPoint = {\n        x: initEndPoint.x + (initControlPoint.x - initEndPoint.x) * (endNode.radius / endDis),\n        y: initEndPoint.y + (initControlPoint.y - initEndPoint.y) * (endNode.radius / endDis)\n      };\n      const linkInfo = {\n        start: startPoint,\n        end: endPoint,\n        control: getControlPoint(startPoint, endPoint, 0.15, 1),\n        u,\n        v,\n        bothway\n      };\n      link.push(linkInfo);\n    });\n    return link;\n  } // 绘制得到节点和连线信息\n\n\n  graph() {\n    const nodes = this.getNodes();\n    const links = this.getLinks();\n    return {\n      nodes,\n      links\n    };\n  }\n\n}\nexport { Matrix, LinkInfo };","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/Bubble/index.ts"],"names":["Matrix","LinkInfo","getControlPoint","distance","_","calcRadius","maxRadius","maxSize","minSize","minRadius","k","b","size","randomNumber","start","end","Math","random","defaultProps","data","width","height","rowCount","Bubble","constructor","matrix","matrixRows","matrixColumns","heightInterval","widthInterval","columnCount","edges","init","ceil","length","i","push","l","r","getNodes","radiusF","min","nodes","map","node","radius","value","id","String","name","allCount","countList","Object","keys","Array","from","item","sort","a","rowIndex","floor","columnIndex","randomX","randomY","widthRange","heightRange","center","x","y","getLinks","dupliEdges","flatten","edge","siblings","u","v","bothway","forEach","find","o","link","startNode","initStartPoint","endNode","initEndPoint","initControlPoint","startDis","startPoint","endDis","endPoint","linkInfo","control","graph","links"],"mappings":"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","sourcesContent":["/**\n* @description Bubble Tree\n*/\n\nimport { Matrix, LinkInfo, Interval} from './define';\nimport { getControlPoint,distance } from '../../Utils/graph';\nimport { BaseEdge, Edge  } from '../../type';\n\nimport * as _ from 'lodash';\n\nfunction calcRadius(maxRadius: number, maxSize: number, minSize: number) {\n  if (maxSize === minSize) {\n    return () => {\n      return maxRadius;\n    };\n  }\n  const minRadius = maxRadius * 0.7;\n  const k = (maxSize - minSize) / (maxRadius - minRadius);\n  const b = minSize - minRadius * k;\n  return (size:number) => {\n    return (size - b) / k;\n  };\n};\n\nfunction randomNumber(start: number, end: number) {\n  return Math.random() * (end - start) + start;\n};\n\nclass defaultProps {\n  data: any;\n  width:  number;\n  height: number;\n  rowCount: number;\n  minSize: number;\n  maxSize: number;\n}\n\nexport class Bubble < E extends BaseEdge>{\n  // 数据\n  private data:any;\n  // Bubble模型矩阵\n  private matrix: Matrix[] = [];\n  // Bubble模型行矩阵\n  private matrixRows:Interval[] = [];\n  // Bubble模型列矩阵\n  private matrixColumns:Interval[] = [];\n  // 每一行的高度\n  private heightInterval:number;\n  // 每一列的宽度\n  private widthInterval:number;\n  // 行的个数\n  private rowCount: number;\n  // 列的个数\n  private columnCount:number;\n  // TODO: 待去除\n  // 圆的最大值\n  private maxSize:number;\n  // 圆的最小值\n  private minSize: number;\n  // 边\n  private edges:Array<Edge<E> & {bothway:boolean}> = [];\n  \n  constructor({\n    data,\n    width,\n    height,\n    rowCount,\n    minSize,\n    maxSize\n  } : defaultProps) {\n    // 初始化\n    this.init(data,width,height,rowCount,maxSize,minSize);\n  }\n  private init(data:any, width:number, height:number, rowCount:number, maxSize:number, minSize:number){\n    this.data = data;\n\n    this.rowCount = rowCount;\n    this.maxSize = maxSize;\n    this.minSize = minSize;\n    this.columnCount = Math.ceil((data || []).length / rowCount);\n    // 每一行的高度\n    this.heightInterval = height / rowCount;\n    // 每一列的宽度\n    this.widthInterval = width / this.columnCount;\n   \n    // 将画布分割为[row,column]的矩阵\n    for (let i = 0; i < rowCount; i++) {\n      this.matrixRows.push({ l: i * this.heightInterval , r: (i + 1) * this.heightInterval  });\n    }\n  \n    for (let i = 0; i < this.columnCount; i++) {\n      this.matrixColumns.push({ l: i * this.widthInterval, r: (i + 1) * this.widthInterval });\n    }\n  }\n\n  // 获取节点数据\n  public getNodes(): Matrix[]{\n    const radiusF = calcRadius(_.min([this.heightInterval  / 2, this.widthInterval / 2]) * 0.9, this.maxSize, this.minSize);\n  \n    const nodes = (this.data || []).map((node:any) => {\n      // 根据权重分配半径\n      const radius = radiusF(node.value);\n      return {\n        id: String(node.id),\n        name: node.name,\n        value: node.value,\n        radius\n      };\n    });\n  \n    const allCount = this.rowCount * this.columnCount;\n    const countList = Object.keys(Array.from({ length: allCount }))\n      .map(item => {\n        return +item;\n      })\n      .sort((a, b) => {\n        return Math.random() > 0.5 ? -1 : 1;\n      });\n    const matrix: Matrix[] = [];\n    for (let i = 0; i < nodes.length; i++) {\n      const rowIndex = Math.floor(countList[i] / this.columnCount);\n      const columnIndex = countList[i] % this.columnCount;\n      const radius = nodes[i].radius;\n      /** 存在风险，直径长度超过interval时，依赖手动设置行数rowCount */\n      const randomX = randomNumber(\n        this.matrixColumns[columnIndex].l + radius,\n        this.matrixColumns[columnIndex].r - radius\n      );\n      const randomY = randomNumber(\n        this.matrixRows[rowIndex].l + radius,\n        this.matrixRows[rowIndex].r - radius\n      );\n  \n      // 标签采用四分位模型\n      matrix.push({\n        node: nodes[i],\n        rowIndex,\n        columnIndex,\n        widthRange: this.matrixColumns[columnIndex],\n        heightRange: this.matrixRows[rowIndex],\n        center: {\n          x: randomX,\n          y: randomY\n        },\n        radius\n      });\n    }\n    this.matrix = matrix;\n    return matrix;\n  }\n  // 获取边数据\n  public getLinks(): LinkInfo[]{\n    const dupliEdges = _.flatten(\n      (this.data || []).map((edge:any) => {\n        return (edge.siblings || []).map((end:any) => ({\n          u: String(edge.id),\n          v: String(end.id),\n          bothway: false\n        }));\n      })\n    );\n    dupliEdges.forEach((item: Edge<E> & {bothway:boolean}) => {\n      const edge = _.find(this.edges, o => o.u === item.v && o.v === item.u);\n      if (!edge) {\n        this.edges.push(item);\n      } else {\n        edge.bothway = true;\n      }\n    });\n    // Bubble模型边信息\n    const link: LinkInfo[] = [];\n    this.edges.forEach((edge: Edge<E> & {bothway:boolean}) => {\n      const { u, v, bothway } = edge;\n      const startNode = _.find(this.matrix, (item: Matrix) => {\n        return String(item.node.id) === String(u);\n      });\n      const initStartPoint = startNode.center;\n      const endNode = _.find(this.matrix, item => {\n        return String(item.node.id) === String(v);\n      });\n      const initEndPoint = endNode.center;\n  \n      const initControlPoint = getControlPoint(initStartPoint, initEndPoint, 0.2, 1);\n      const startDis = distance(initStartPoint, initControlPoint);\n      const startPoint = {\n        x: initStartPoint.x + (initControlPoint.x - initStartPoint.x) * (startNode.radius / startDis),\n        y: initStartPoint.y + (initControlPoint.y - initStartPoint.y) * (startNode.radius / startDis)\n      };\n      const endDis = distance(initControlPoint, initEndPoint);\n      const endPoint = {\n        x: initEndPoint.x + (initControlPoint.x - initEndPoint.x) * (endNode.radius / endDis),\n        y: initEndPoint.y + (initControlPoint.y - initEndPoint.y) * (endNode.radius / endDis)\n      };\n  \n      const linkInfo: LinkInfo = {\n        start: startPoint,\n        end: endPoint,\n        control: getControlPoint(startPoint, endPoint, 0.15, 1),\n        u,\n        v,\n        bothway\n      };\n      link.push(linkInfo);\n    });\n    return link;\n  }\n  // 绘制得到节点和连线信息\n  public graph(): {\n    nodes: Matrix[],\n    links: LinkInfo[],\n  }{\n   const nodes = this.getNodes();\n   const links = this.getLinks();\n   return {\n    nodes,\n    links\n   }\n  }\n}\n\n\nexport { Matrix, LinkInfo};"]},"metadata":{},"sourceType":"module"}