{"ast":null,"code":"/**\n * 算法优化版本\n * 主要基于 dagre 修改节点顺序与位置算法\n */\nimport LinkGenerator from './Link';\nimport { minBy, find, sumBy, reverseArray, maxBy, getObjectMaxMin } from '../../Utils/utils';\nimport { sortNodelevel, crossing } from './utils';\nconst MAX_ITERATIONS = 24;\n\nclass BaseDAG {\n  // 去重节点列表，包含虚拟节点\n  // 去重边列表，不带自环\n  // 自环边\n  // 虚拟节点编号\n\n  /** 配置项 */\n  // 整个 DAG 的高度与宽度\n  // 节点层级初始化排序使用\n  // 按节点层级划分的\n  // 节点层级中 height 最大的节点\n  // dfs 节点标记\n  // link 实例\n  constructor({\n    nodes,\n    links,\n    selfLinks,\n    config\n  }) {\n    this.nodes = void 0;\n    this.links = void 0;\n    this.selfLinks = void 0;\n    this.virtualId = 0;\n    this.config = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.paddingSum = [];\n    this.levelPaddings = [];\n    this.levelMap = new Map();\n    this.nodesByLevel = [];\n    this.nodesLevelMaxHeight = [];\n    this.dfsVisited = [];\n    this.linkInstace = void 0;\n    this.nodes = nodes.slice().sort((nodeA, nodeB) => {\n      return nodeA.id > nodeB.id ? 1 : -1;\n    });\n    this.links = links.slice().sort((linkA, linkB) => {\n      return `${linkA.source.id}-${linkA.target.id}` > `${linkB.source.id}-${linkB.target.id}` ? 1 : -1;\n    });\n    this.selfLinks = selfLinks.slice();\n    this.config = { ...config\n    };\n  }\n\n  destroy() {\n    this.nodes = null;\n    this.links = null;\n    this.selfLinks = null;\n    this.nodesByLevel = null;\n    this.nodesLevelMaxHeight = null;\n  }\n\n  getOutput(left, top) {\n    // 加整体偏移量\n    this.nodes.forEach(node => {\n      node.finalPos = {\n        x: node.pos + left,\n        // y: this.paddingSum[node.level] + 50 * node.level + top,\n        // 间隔高度 + 节点层高度 + margin.top + 在层级中高度居中\n        y: this.paddingSum[node.level] + top + this.nodesLevelMaxHeight.reduce((pre, height, index) => {\n          if (index < node.level) return pre + this.nodesLevelMaxHeight[index];\n          return pre;\n        }, 0) + (this.nodesLevelMaxHeight[node.level] - node.nodeHeight) / 2\n      };\n    });\n    this.links.forEach(link => {\n      if (link.linkChildren && link.linkChildren.length) {\n        link.finalPath = link.linkChildren.reduce((path, child, index) => {\n          if (index === 0) {\n            return this.linkInstace.getFinalPath(child, this.levelPaddings, false, true);\n          }\n\n          return path.concat(this.linkInstace.getFinalPath(child, this.levelPaddings, index === link.linkChildren.length - 1, false));\n        }, []);\n      } else {\n        link.finalPath = this.linkInstace.getFinalPath(link, this.levelPaddings, true, true);\n      }\n    });\n    this.selfLinks.forEach(link => {\n      link.finalPath = this.linkInstace.getSelfFinalPath(link);\n    }); // 逆转边还原\n\n    this.recoverCycle();\n    return {\n      nodes: this.nodes.filter(node => node.type !== 'virtual').map(node => {\n        // nodes: this.nodes.map(node => {\n        return {\n          id: node.id,\n          view: {\n            x: node.finalPos.x,\n            y: node.finalPos.y\n          },\n          nodeWidth: node.nodeWidth,\n          nodeHeight: node.nodeHeight,\n          info: node.originInfo\n        };\n      }),\n      links: [...this.links.filter(link => link.source.type !== 'virtual' && link.target.type !== 'virtual').map(link => {\n        return {\n          sourceId: link.source.id,\n          targetId: link.target.id,\n          path: link.finalPath,\n          info: link.originInfo\n        };\n      }), ...this.selfLinks.map(link => {\n        return {\n          sourceId: link.source.id,\n          targetId: link.target.id,\n          path: link.finalPath,\n          info: link.originInfo\n        };\n      })],\n      pos: {\n        width: this.width,\n        height: this.height\n      }\n    };\n  }\n\n  run() {\n    // 将有向有环图转为为有向无环图\n    this.clearCycle(); // 计算节点层级\n\n    this.calcNodeLevels(); // 计算节点位置\n\n    this.calcNodePos(); // 计算节点坐标\n\n    this.xcordinate(); // 计算线的位置，做成插件分离出来，输入所有 node 的信息\n\n    this.calcLinkPos(); // 计算真实尺寸\n\n    this.calcRealSize();\n    return this;\n  }\n\n  getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  calcLinkPos() {\n    const {\n      linkType,\n      DiyLine\n    } = this.config;\n    const LinkClass = LinkGenerator(linkType, DiyLine);\n    this.linkInstace = new LinkClass(this.nodesByLevel, this.selfLinks, this.config);\n    this.levelPaddings = this.linkInstace.calcPosAndPadding();\n  }\n\n  calcRealSize() {\n    let sum = 0; // 累计 padding\n\n    this.levelPaddings.forEach((padding, index) => {\n      this.paddingSum[index] = sum;\n      sum += padding;\n    }); // width 和 height 为纯的宽高\n\n    this.height = this.paddingSum[this.paddingSum.length - 1] + sumBy(this.nodesLevelMaxHeight, height => height);\n    this.width = this.nodes.reduce((max, curNode) => {\n      return curNode.pos + curNode.nodeWidth > max ? curNode.pos + curNode.nodeWidth : max;\n    }, 0) - this.nodes.reduce((min, curNode) => {\n      return curNode.pos < min ? curNode.pos : min;\n    }, 0);\n  }\n\n  addVirtualNode() {\n    const virtualNodes = [];\n    const virtualLinks = [];\n    this.links.forEach(link => {\n      const source = link.source;\n      const target = link.target;\n      const sourceLevel = source.level;\n      const targetLevel = target.level;\n      link.linkChildren = []; // 跨层级的边上才需要添加虚拟节点\n\n      if (sourceLevel + 1 < targetLevel) {\n        for (let i = sourceLevel + 1; i < targetLevel; i++) {\n          const virtualNode = {\n            id: `virtual${this.virtualId++}`,\n            sourceLinks: [],\n            targetLinks: [],\n            type: 'virtual',\n            nodeWidth: this.config.defaultVirtualNodeWidth,\n            nodeHeight: this.nodesLevelMaxHeight[i],\n            originInfo: {},\n            level: i\n          };\n          const sourceNode = i === sourceLevel + 1 ? source : virtualNodes[virtualNodes.length - 1];\n          const virtualLink = {\n            source: sourceNode,\n            target: virtualNode,\n            originInfo: {},\n            isReverse: link.isReverse\n          };\n          link.linkChildren.push(virtualLink);\n          virtualLinks.push(virtualLink);\n          sourceNode.sourceLinks.push(virtualLink);\n          virtualNode.targetLinks.push(virtualLink);\n\n          if (i === targetLevel - 1) {\n            const virtualLink = {\n              source: virtualNode,\n              target,\n              originInfo: {},\n              isReverse: link.isReverse\n            };\n            link.linkChildren.push(virtualLink);\n            virtualLinks.push(virtualLink);\n            virtualNode.sourceLinks.push(virtualLink);\n            target.targetLinks.push(virtualLink);\n          }\n\n          virtualNodes.push(virtualNode);\n        }\n      }\n    });\n    this.nodes = [...this.nodes, ...virtualNodes];\n    this.links = [...this.links, ...virtualLinks];\n  }\n\n  dfsOrder(node) {\n    if (this.dfsVisited.indexOf(node.id) > -1) return;\n    const pos = this.levelMap.get(node.level);\n    node.levelPos = pos;\n    node._levelPos = pos;\n    this.levelMap.set(node.level, pos + 1);\n    this.dfsVisited.push(node.id);\n    node.sourceLinks.forEach(link => {\n      const {\n        source,\n        target\n      } = link; // 只处理相邻层级\n\n      if (target.level - source.level === 1) {\n        this.dfsOrder(target);\n      }\n    });\n  }\n\n  initOrder() {\n    // 分割进入\n    this.nodes.forEach(node => {\n      const level = node.level;\n\n      if (this.nodesByLevel[level]) {\n        this.nodesByLevel[level].push(node);\n      } else {\n        this.nodesByLevel[level] = [node];\n        this.levelMap.set(level, 0);\n      }\n    }); // 利用 dfs 来设置 order，树可以保证初始化排序没有交叉\n\n    this.dfsVisited = [];\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        if (this.nodesByLevel[i][j].levelPos === undefined) {\n          this.dfsOrder(this.nodesByLevel[i][j]);\n        }\n      }\n    }\n  }\n\n  wmedian(index) {\n    /**\n     * 节点中位数\n     * @param nodelevel\n     */\n    function medianNodeLevel(nodelevel) {\n      nodelevel.forEach(node => {\n        // 筛选出非跨层级上游节点，并按照 levelPos 排序\n        const parentNode = node.targetLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).map(link => link.source);\n        parentNode.sort((node1, node2) => {\n          return node1.levelPos - node2.levelPos;\n        });\n        const m = Math.floor(parentNode.length / 2);\n\n        if (parentNode.length === 0) {\n          node._median = -1;\n        } else if (parentNode.length % 2 === 1) {\n          node._median = parentNode[m].levelPos;\n        } else if (parentNode.length === 2) {\n          node._median = (parentNode[0].levelPos + parentNode[1].levelPos) / 2;\n        } else {\n          const left = parentNode[m - 1].levelPos - parentNode[0].levelPos;\n          const right = parentNode[parentNode.length - 1].levelPos - parentNode[m].levelPos;\n          node._median = (parentNode[m - 1].levelPos * right + parentNode[m].levelPos * left) / (left + right);\n        }\n      });\n    } // index 为偶，从上到下，index 为奇，从下到上\n\n\n    if (index % 2 === 0) {\n      for (let i = 0; i < this.nodesByLevel.length; i++) {\n        const nodelevel = this.nodesByLevel[i];\n        medianNodeLevel(nodelevel); // 根据 _median 重排序\n\n        this.nodesByLevel[i] = sortNodelevel(nodelevel);\n      }\n\n      return;\n    } else {\n      for (let i = this.nodesByLevel.length - 1; i >= 0; i--) {\n        const nodelevel = this.nodesByLevel[i];\n        medianNodeLevel(nodelevel);\n        this.nodesByLevel[i] = sortNodelevel(nodelevel);\n      }\n    }\n  } // 求全图交叉数量\n\n\n  crossing() {\n    let count = 0;\n\n    for (let i = 1; i < this.nodesByLevel.length; i++) {\n      count += crossing(this.nodesByLevel[i - 1], this.nodesByLevel[i]);\n    }\n\n    return count;\n  } // 交换相邻节点位置\n\n\n  transpose() {\n    let bestCount = this.crossing(); // 这里 i,j 的顺序与 level、_levelPos 的顺序保持一致\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      if (this.nodesByLevel.length === 1) continue;\n\n      for (let j = 1; j < this.nodesByLevel[i].length; j++) {\n        // 暂时交换位置\n        this.nodesByLevel[i][j]._levelPos = j - 1;\n        this.nodesByLevel[i][j - 1]._levelPos = j;\n        let currentCount = this.crossing();\n\n        if (currentCount < bestCount) {\n          // 能减少交叉，完成交换\n          const tmpNode = this.nodesByLevel[i][j];\n          this.nodesByLevel[i][j] = this.nodesByLevel[i][j - 1];\n          this.nodesByLevel[i][j - 1] = tmpNode;\n          bestCount = currentCount;\n        } else {\n          // 没有效果，还原\n          this.nodesByLevel[i][j]._levelPos = j;\n          this.nodesByLevel[i][j - 1]._levelPos = j - 1;\n        }\n      }\n    }\n\n    return bestCount;\n  }\n  /**\n   * 确定同层级中节点的先后排列顺序，这里需要尽可能减少边交叉\n   * 算法来源：A Technique for Drawing Directed Graphs.pdf 第3节\n   * 主要思路是根据 dfs 遍历顺序获取一个初始顺序\n   * 然后是启发式算法：从上到下，从下到上遍历，子节点位置由父节点们来决定，同时每次遍历完成后，尝试交换相邻节点的位置，看看是否能够减少边交叉数\n   * 取最小边交叉数的排序，默认为最优解\n   */\n\n\n  ordering() {\n    // 按层级排布，并给予初始化排序\n    this.initOrder();\n    let bestCount = this.crossing();\n\n    if (bestCount !== 0) {\n      for (let i = 0; i <= MAX_ITERATIONS; i++) {\n        this.wmedian(i);\n        const currentCount = this.transpose();\n\n        if (bestCount > currentCount) {\n          bestCount = currentCount; // 将所有 _levelPos 赋给 levelPos，并排序\n\n          this.nodesByLevel.forEach((nodelevel, i) => {\n            nodelevel.forEach(node => node.levelPos = node._levelPos);\n            nodelevel.sort((node1, node2) => {\n              return node1.levelPos - node2.levelPos;\n            });\n          });\n        }\n      }\n    } // 最终以 levelPos 为准\n\n\n    this.nodesByLevel.forEach((nodelevel, i) => {\n      nodelevel.sort((node1, node2) => {\n        return node1.levelPos - node2.levelPos;\n      });\n    });\n  }\n\n  findTypeConflicts() {\n    const conflicts = []; // 层级\n\n    for (let i = 1; i < this.nodesByLevel.length; i++) {\n      let k0 = 0;\n      let scanPos = 0;\n      let prevLayerLength = this.nodesByLevel[i - 1].length; // 层级中的节点\n\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        let node = this.nodesByLevel[i][j]; // 寻找两个虚节点连成的边，寻找当前虚拟节点的相邻上游的虚拟节点，有且仅有一个\n\n        const upVirtualLink = node.type === 'virtual' && node.targetLinks.filter(link => {\n          return link.target.level - link.source.level === 1 && link.source.type === 'virtual';\n        });\n        const upVirtualNode = upVirtualLink && upVirtualLink.length ? upVirtualLink[0].source : undefined;\n        let k1 = upVirtualNode ? upVirtualNode.levelPos : prevLayerLength; // 分段方法\n        // 拥有上一层级虚节点，检查当前虚节点以前的\n        // 当前虚节点为当前层级最后一个节点，检查最后一个虚节点以后的\n\n        if (upVirtualNode || j === this.nodesByLevel[i].length - 1) {\n          this.nodesByLevel[i].slice(scanPos, j + 1).forEach(curNode => {\n            // 当前层级的上层节点\n            const upCurNodes = curNode.targetLinks.filter(node => node.target.level - node.source.level === 1).map(link => link.source);\n            upCurNodes.forEach(upCurNode => {\n              const pos = upCurNode.levelPos;\n\n              if ((pos < k0 || k1 < pos) && !(upCurNode.type === 'virtual' && curNode.type === 'virtual')) {\n                conflicts.push(find(curNode.targetLinks, link => link.source.id === upCurNode.id && link.target.id === curNode.id));\n              }\n            });\n          });\n          scanPos = j + 1;\n          k0 = k1;\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  verticalAlignment(vert, typeConflicts) {\n    const root = {};\n    const align = {};\n\n    function hasConflict(node1, node2) {\n      for (let i = 0; i < typeConflicts.length; i++) {\n        const link = typeConflicts[i];\n\n        if (link.source.id === node1.id && link.target.id === node2.id || link.source.id === node2.id && link.target.id === node1.id) {\n          return true;\n        }\n      }\n\n      return false;\n    } // 初始化\n\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const {\n          id\n        } = this.nodesByLevel[i][j];\n        root[id] = id;\n        align[id] = id;\n      }\n    }\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      // 因为我们是从 0 计数的，所以这里要改为 -1\n      let r = -1;\n\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const nodeV = this.nodesByLevel[i][j]; // 从上到下取上游邻居，从下到上取上游邻居\n\n        let neighbors = vert === 'u' ? nodeV.targetLinks.filter(link => {\n          return Math.abs(link.target.level - link.source.level) === 1;\n        }).map(link => link.source) : nodeV.sourceLinks.filter(link => {\n          return Math.abs(link.target.level - link.source.level) === 1;\n        }).map(link => link.target);\n\n        if (neighbors && neighbors.length) {\n          neighbors.sort((node1, node2) => {\n            return node1.levelPos - node2.levelPos;\n          }); // 取邻居中位数节点，1 or 2\n\n          const mid = (neighbors.length - 1) / 2;\n\n          for (let z = Math.floor(mid); z <= Math.ceil(mid); z++) {\n            const nodeW = neighbors[z];\n\n            if (align[nodeV.id] === nodeV.id && r < nodeW.levelPos && !hasConflict(nodeV, nodeW)) {\n              align[nodeW.id] = nodeV.id;\n              align[nodeV.id] = root[nodeV.id] = root[nodeW.id];\n              r = nodeW.levelPos;\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      root,\n      align\n    };\n  }\n\n  horizontalCompaction(root, align, horiz) {\n    const sink = {};\n    const shift = {};\n    const x = {}; // 计算块与块间的最大间距，为了适配不同节点宽度\n\n    const blockSpaceMap = new Map();\n    this.nodesByLevel.forEach((nodeLevel, i) => {\n      let uNode;\n      nodeLevel.forEach(vnode => {\n        const vRootNodeId = root[vnode.id];\n\n        if (uNode) {\n          const uRootNodeId = root[uNode.id];\n          const blockSpace = blockSpaceMap.has(`${vRootNodeId}-${uRootNodeId}`) || blockSpaceMap.has(`${uRootNodeId}-${vRootNodeId}`) ? blockSpaceMap.get(`${vRootNodeId}-${uRootNodeId}`) || blockSpaceMap.get(`${uRootNodeId}-${vRootNodeId}`) : 0;\n          const curSpace = vnode.nodeWidth / 2 + this.config.nodeAndNodeSpace + uNode.nodeWidth / 2;\n          blockSpaceMap.set(`${vRootNodeId}-${uRootNodeId}`, Math.max(blockSpace, curSpace));\n          blockSpaceMap.set(`${uRootNodeId}-${vRootNodeId}`, Math.max(blockSpace, curSpace));\n        }\n\n        uNode = vnode;\n      });\n    });\n\n    const placeBlock = node => {\n      if (x[node.id] === undefined) {\n        x[node.id] = 0;\n        let w = node.id;\n\n        do {\n          // 非第一个\n          const curNode = find(this.nodes, node => node.id === w);\n\n          if (curNode.levelPos > 0) {\n            // 同层级左相邻节点\n            const preNode = this.nodesByLevel[curNode.level][curNode.levelPos - 1]; // 取根节点\n\n            const rootId = root[preNode.id];\n            placeBlock(find(this.nodes, node => node.id === rootId));\n\n            if (sink[node.id] === node.id) {\n              sink[node.id] = sink[rootId];\n            }\n\n            if (!blockSpaceMap.has(`${rootId}-${root[node.id]}`) && !blockSpaceMap.has(`${root[node.id]}-${rootId}`)) {\n              throw new Error(`${rootId}, ${root[node.id]}无法获取`);\n            }\n\n            if (sink[node.id] !== sink[rootId]) {\n              shift[sink[rootId]] = Math.min(shift[sink[rootId]], x[node.id] - x[rootId] - (blockSpaceMap.get(`${rootId}-${root[node.id]}`) || blockSpaceMap.get(`${root[node.id]}-${rootId}`)));\n            } else {\n              x[node.id] = Math.max(x[node.id], x[rootId] + (blockSpaceMap.get(`${rootId}-${root[node.id]}`) || blockSpaceMap.get(`${root[node.id]}-${rootId}`)));\n            }\n          }\n\n          w = align[w]; // 块循环结束\n        } while (w !== node.id);\n      }\n    }; // 初始化\n\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const {\n          id\n        } = this.nodesByLevel[i][j];\n        sink[id] = id;\n        shift[id] = Number.MAX_SAFE_INTEGER;\n        x[id] = undefined;\n      }\n    } // placeBlock\n\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const {\n          id\n        } = this.nodesByLevel[i][j];\n\n        if (root[id] === id) {\n          placeBlock(this.nodesByLevel[i][j]);\n        }\n      }\n    } // 整理\n\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const {\n          id\n        } = this.nodesByLevel[i][j];\n        x[id] = x[root[id]];\n\n        if (shift[sink[root[id]]] < Number.MAX_SAFE_INTEGER) {\n          x[id] = x[id] + shift[sink[root[id]]];\n        }\n      }\n    }\n\n    return x;\n  }\n\n  getDirectNodesByLevel(vert, horiz) {\n    if (vert === 'u' && horiz === 'l') {\n      return;\n    }\n\n    if (vert === 'u' && horiz === 'r' || vert === 'd' && horiz === 'r') {\n      this.nodesByLevel = this.nodesByLevel.map((nodeLevel, i) => {\n        return reverseArray(nodeLevel, (node, levelPos) => {\n          node.levelPos = levelPos;\n          return node;\n        });\n      });\n    }\n\n    if (vert === 'd' && horiz === 'l') {\n      this.nodesByLevel = reverseArray(this.nodesByLevel, (nodeLevel, level) => {\n        return reverseArray(nodeLevel, (node, levelPos) => {\n          node.level = level;\n          node.levelPos = levelPos;\n          return node;\n        });\n      });\n    }\n  }\n\n  resetLevel() {\n    this.nodesByLevel = reverseArray(this.nodesByLevel, (nodeLevel, level) => {\n      return reverseArray(nodeLevel, (node, levelPos) => {\n        node.level = level;\n        node.levelPos = levelPos;\n        return node;\n      });\n    });\n  }\n  /**\n   * 节点具体位置确定，算法稳定，能保证相同节点相同边的 DAG 不发生变动\n   * 算法来源：Fast and Simple Horizontal Coordinate Assignment\n   * 将节点从 左、右、上、下 四个方向进行块划分，拉开最小距离，最终取中位值，实现原理暂时不是很了解\n   */\n\n\n  xcordinate() {\n    // 寻找出与（虚拟-虚拟）边交叉的（真实-真实/真实-虚拟）边\n    const typeConflicts = this.findTypeConflicts(); // 四个方向\n\n    const xSet = {};\n    ['u', 'd'].forEach(vert => {\n      ['l', 'r'].forEach(horiz => {\n        /** 对 nodesByLevel 进行转置 */\n        this.getDirectNodesByLevel(vert, horiz); // 相当于块划分\n\n        const {\n          root,\n          align\n        } = this.verticalAlignment(vert, typeConflicts);\n        const x = this.horizontalCompaction(root, align, horiz); // right 方向为负\n\n        if (horiz === 'r') {\n          for (let key in x) {\n            x[key] = -x[key];\n          }\n        }\n\n        xSet[vert + horiz] = x;\n      });\n    });\n    this.resetLevel();\n    const {\n      minSet: smallestWidth,\n      minDirect\n    } = this.findSmallestWidthAlignment(xSet);\n    this.alignCoordinates(xSet, smallestWidth, minDirect);\n    const finalPosSet = this.balance(xSet);\n    let minPos = Infinity;\n    /** 得出节点最后位置 */\n\n    this.nodes.forEach(node => {\n      node.pos = finalPosSet[node.id] - node.nodeWidth / 2;\n\n      if (minPos > node.pos) {\n        minPos = node.pos;\n      }\n    });\n    this.nodes.forEach(node => {\n      node.pos = node.pos - minPos;\n    });\n  }\n  /** 从四个方向的几何中寻找一个宽度最小的 */\n\n\n  findSmallestWidthAlignment(xSet) {\n    let minSet;\n    let minDirect;\n    let minSetValue = Number.MAX_SAFE_INTEGER;\n\n    for (let direction in xSet) {\n      const xs = xSet[direction];\n      let minValue = Number.MAX_SAFE_INTEGER;\n      let maxValue = Number.MIN_SAFE_INTEGER;\n\n      for (let key in xs) {\n        const value = xs[key];\n        const node = find(this.nodes, node => {\n          // 兼容业务方id为number的情况\n          return String(node.id) === String(key);\n        });\n        if (value + node.nodeWidth / 2 > maxValue) maxValue = value + node.nodeWidth / 2;\n        if (value - node.nodeWidth / 2 < minValue) minValue = value - node.nodeWidth / 2;\n      }\n\n      if (maxValue - minValue < minSetValue) {\n        minSetValue = maxValue - minValue;\n        minSet = xs;\n        minDirect = direction;\n      }\n    }\n\n    return {\n      minSet,\n      minDirect\n    };\n  }\n\n  alignCoordinates(xSet, smallestWidth, direct) {\n    let {\n      maxValue: maxAlign,\n      minValue: minAlign\n    } = getObjectMaxMin(smallestWidth);\n    ['u', 'd'].forEach(vert => {\n      ['l', 'r'].forEach(horiz => {\n        let alignment = vert + horiz;\n\n        if (alignment !== direct) {\n          const xs = xSet[alignment];\n          const {\n            maxValue: maxXs,\n            minValue: minXs\n          } = getObjectMaxMin(xs);\n          let delta = horiz === 'l' ? minAlign - minXs : maxAlign - maxXs;\n\n          if (delta) {\n            for (let key in xs) {\n              xs[key] = xs[key] + delta;\n            }\n          }\n        }\n      });\n    });\n  }\n\n  balance(xSet) {\n    const posListSet = {};\n\n    for (let direction in xSet) {\n      for (let key in xSet[direction]) {\n        if (posListSet[key] && posListSet[key].length) {\n          posListSet[key].push(xSet[direction][key]);\n        } else {\n          posListSet[key] = [xSet[direction][key]];\n        }\n      }\n    }\n\n    const finalPosSet = {};\n\n    for (let key in posListSet) {\n      posListSet[key].sort((a, b) => a - b);\n      finalPosSet[key] = (posListSet[key][1] + posListSet[key][2]) / 2;\n    }\n\n    return finalPosSet;\n  }\n\n  calcNodePos() {\n    // 添加跨节点边的虚拟节点\n    this.addVirtualNode(); // 开始迭代变换\n\n    this.ordering();\n  }\n\n  recoverCycle() {\n    this.links.forEach(link => {\n      if (link.isReverse) {\n        this.exchangeLink(link);\n\n        if (link.linkChildren && link.linkChildren.length) {\n          link.linkChildren.forEach(link => {\n            if (link.isReverse) {\n              this.exchangeLink(link);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  clearCycleDfs(node, stack, isFirst) {\n    const lastNodeId = stack[stack.length - 1]; // 当前节点已被遍历，不需要再遍历\n\n    if (lastNodeId) {\n      if (this.dfsVisited.indexOf(`${lastNodeId}_${node.id}`) > -1) {\n        return;\n      }\n\n      this.dfsVisited.push(`${lastNodeId}_${node.id}`);\n    } // 当前节点成环，对边进行逆转标记\n\n\n    if (stack.indexOf(node.id) > -1) {\n      console.warn('当前图中存在环，已被逆转处理');\n      const link = find(this.links, link => {\n        return link.source.id === lastNodeId && link.target.id === node.id;\n      });\n      link.isReverse = true;\n    } // 保证按真实连线进行上下关系\n\n\n    const LinkList = isFirst ? node.sourceLinks.filter(link => !link.isCycleRelation) : node.sourceLinks;\n\n    for (let i = 0; i < LinkList.length; i++) {\n      this.clearCycleDfs(LinkList[i].target, [...stack, node.id], false);\n    }\n\n    return;\n  }\n\n  exchangeLink(link) {\n    const source = link.source;\n    const target = link.target; // 从 sourceLinks 中去除\n\n    source.sourceLinks = source.sourceLinks.filter(link => {\n      return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse;\n    }); // 添加到 targetLinks \n\n    source.targetLinks.push(link); // 从 targetLinks 中去除\n\n    target.targetLinks = target.targetLinks.filter(link => {\n      return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse;\n    });\n    target.sourceLinks.push(link);\n    link.source = target;\n    link.target = source;\n  }\n  /** 利用 dfs 去除环 */\n\n\n  clearCycle() {\n    this.dfsVisited = [];\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      this.clearCycleDfs(this.nodes[i], [], true);\n    }\n\n    this.links.forEach(link => {\n      if (link.isReverse) {\n        this.exchangeLink(link);\n      }\n    });\n  }\n  /**\n   * 确定节点层级\n   * 算法来源：A Technique for Drawing Directed Graphs，2.3 节，主要采用了生成树的做法，原理难懂且实现比较复杂\n   * 实现算法为简要版本，来源于 jdk137/dag，主要通过获取骨干节点后，其余节点根据自己的父子节点层级来决定层级，比较简单\n   */\n\n\n  calcNodeLevels() {\n    this.nodes.forEach(node => {\n      node.linkNumber = node.targetLinks.length + node.sourceLinks.length;\n      node.levelSetted = false;\n    });\n    let shrink = true;\n    let boneNodes = this.nodes; // 去除度为 1 的节点的边，获取骨干节点\n\n    while (shrink) {\n      shrink = false;\n      boneNodes.forEach(node => {\n        if (node.linkNumber === 1) {\n          shrink = true;\n          node.linkNumber = 0;\n          node.sourceLinks.forEach(link => {\n            link.target.linkNumber--;\n          });\n          node.targetLinks.forEach(link => {\n            link.source.linkNumber--;\n          });\n        }\n      });\n      boneNodes = boneNodes.filter(node => {\n        return node.linkNumber > 0;\n      });\n    }\n\n    boneNodes.forEach(node => {\n      node.isBone = true;\n    });\n    let level = 0;\n    let confirmNodeLevelList = boneNodes; // boneNodes > 0 说明当前DAG图成环状，如 1—>2 2->3 1->3\n    // 通过不断遍历节点的下游节点，确定节点层级\n\n    if (boneNodes.length > 0) {\n      while (confirmNodeLevelList.length) {\n        const nextNodes = [];\n        confirmNodeLevelList.forEach(node => {\n          node.level = level;\n          node.sourceLinks.forEach(link => {\n            // @Fix 2018-06-27，需要进行去重处理，不然由于图层级过深，nextNodes 数组会变得很大，导致 crash\n            if (!find(nextNodes, node => {\n              return node.id === link.target.id;\n            })) {\n              nextNodes.push(link.target);\n            }\n          });\n        });\n        confirmNodeLevelList = nextNodes;\n        level++;\n      } // 收集节点的上下游骨干节点\n\n\n      boneNodes.forEach(node => {\n        const parentBoneNode = [];\n        const childrenBoneNode = [];\n        node.targetLinks.forEach(link => {\n          if (link.source.isBone) {\n            parentBoneNode.push(link.source);\n          }\n        });\n        node.sourceLinks.forEach(link => {\n          if (link.target.isBone) {\n            childrenBoneNode.push(link.target);\n          }\n        });\n        node.parentBoneNode = parentBoneNode;\n        node.childrenBoneNode = childrenBoneNode;\n        const minChildLevel = (minBy(node.childrenBoneNode, boneNode => boneNode.level) || {}).level; // 如果没有父节点，当前节点层级就是最上层子节点的上级\n\n        if (node.parentBoneNode.length === 0) {\n          node.level = minChildLevel - 1;\n        }\n\n        if (minChildLevel && minChildLevel - node.level > 1) {\n          // 如果当前节点与最上层子节点相差超过一个层级，就需要进行调整，如果子节点数量少于父节点数量，则当前节点应更加靠近子节点\n          if (node.childrenBoneNode.length < node.parentBoneNode.length) {\n            node.level = minChildLevel - 1;\n          } // 其余情况不需要处理\n\n        }\n      });\n    } else {\n      // 不成环的情况，将第一个节点设为骨干节点\n      this.nodes[0].level = 0;\n      boneNodes.push(this.nodes[0]);\n    }\n\n    boneNodes.forEach(node => {\n      node.levelSetted = true;\n    }); // 处理未成环状的节点，根据他上下游的依赖节点的层级来判断位置\n\n    let waitSetLevelNodes = boneNodes;\n\n    while (waitSetLevelNodes.length) {\n      const tmpNodeList = [];\n      waitSetLevelNodes.forEach(node => {\n        node.sourceLinks.forEach(link => {\n          const targetNode = link.target;\n\n          if (!targetNode.levelSetted) {\n            targetNode.level = node.level + 1;\n            node.levelSetted = true;\n            tmpNodeList.push(targetNode);\n          }\n        });\n        node.targetLinks.forEach(link => {\n          const sourceNode = link.source;\n\n          if (!sourceNode.levelSetted) {\n            sourceNode.level = node.level - 1;\n            node.levelSetted = true;\n            tmpNodeList.push(sourceNode);\n          }\n        });\n      });\n      waitSetLevelNodes = tmpNodeList;\n    } // 归 0 化处理，计算层级可能为负数\n\n\n    const minLevel = minBy(this.nodes, node => node.level).level;\n    this.nodes.forEach(node => {\n      node.level -= minLevel;\n    }); // 算出每个层级中最大的节点高度，以匹配节点高度不同\n\n    const maxLevel = maxBy(this.nodes, node => node.level).level;\n    this.nodesLevelMaxHeight = Array(maxLevel + 1).fill(-Infinity);\n    this.nodes.forEach(node => {\n      if (this.nodesLevelMaxHeight[node.level] < node.nodeHeight) {\n        this.nodesLevelMaxHeight[node.level] = node.nodeHeight;\n      }\n    });\n  }\n\n}\n\nexport default BaseDAG;","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/DAG/BaseDAG.ts"],"names":["LinkGenerator","minBy","find","sumBy","reverseArray","maxBy","getObjectMaxMin","sortNodelevel","crossing","MAX_ITERATIONS","BaseDAG","constructor","nodes","links","selfLinks","config","virtualId","width","height","paddingSum","levelPaddings","levelMap","Map","nodesByLevel","nodesLevelMaxHeight","dfsVisited","linkInstace","slice","sort","nodeA","nodeB","id","linkA","linkB","source","target","destroy","getOutput","left","top","forEach","node","finalPos","x","pos","y","level","reduce","pre","index","nodeHeight","link","linkChildren","length","finalPath","path","child","getFinalPath","concat","getSelfFinalPath","recoverCycle","filter","type","map","view","nodeWidth","info","originInfo","sourceId","targetId","run","clearCycle","calcNodeLevels","calcNodePos","xcordinate","calcLinkPos","calcRealSize","getSize","linkType","DiyLine","LinkClass","calcPosAndPadding","sum","padding","max","curNode","min","addVirtualNode","virtualNodes","virtualLinks","sourceLevel","targetLevel","i","virtualNode","sourceLinks","targetLinks","defaultVirtualNodeWidth","sourceNode","virtualLink","isReverse","push","dfsOrder","indexOf","get","levelPos","_levelPos","set","initOrder","j","undefined","wmedian","medianNodeLevel","nodelevel","parentNode","node1","node2","m","Math","floor","_median","right","count","transpose","bestCount","currentCount","tmpNode","ordering","findTypeConflicts","conflicts","k0","scanPos","prevLayerLength","upVirtualLink","upVirtualNode","k1","upCurNodes","upCurNode","verticalAlignment","vert","typeConflicts","root","align","hasConflict","r","nodeV","neighbors","abs","mid","z","ceil","nodeW","horizontalCompaction","horiz","sink","shift","blockSpaceMap","nodeLevel","uNode","vnode","vRootNodeId","uRootNodeId","blockSpace","has","curSpace","nodeAndNodeSpace","placeBlock","w","preNode","rootId","Error","Number","MAX_SAFE_INTEGER","getDirectNodesByLevel","resetLevel","xSet","key","minSet","smallestWidth","minDirect","findSmallestWidthAlignment","alignCoordinates","finalPosSet","balance","minPos","Infinity","minSetValue","direction","xs","minValue","maxValue","MIN_SAFE_INTEGER","value","String","direct","maxAlign","minAlign","alignment","maxXs","minXs","delta","posListSet","a","b","exchangeLink","clearCycleDfs","stack","isFirst","lastNodeId","console","warn","LinkList","isCycleRelation","linkNumber","levelSetted","shrink","boneNodes","isBone","confirmNodeLevelList","nextNodes","parentBoneNode","childrenBoneNode","minChildLevel","boneNode","waitSetLevelNodes","tmpNodeList","targetNode","minLevel","maxLevel","Array","fill"],"mappings":"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","sourcesContent":["/**\n * 算法优化版本\n * 主要基于 dagre 修改节点顺序与位置算法\n */\n\nimport {\n  InputNode,\n  InputRelation,\n  NodeId,\n  InternalUpGradeNode,\n  InternalUpGradeLink,\n  BaseDAGConfig,\n} from './types';\n\nimport LinkGenerator, { Polyline } from './Link';\nimport {\n  minBy,\n  find,\n  sumBy,\n  reverseArray,\n  maxBy,\n  getObjectMaxMin\n} from '../../Utils/utils';\nimport { sortNodelevel, crossing } from './utils';\n\nconst MAX_ITERATIONS = 24;\n\nclass BaseDAG<\n  Node extends InputNode<Relation>,\n  Relation extends InputRelation\n> {\n  // 去重节点列表，包含虚拟节点\n  private nodes: InternalUpGradeNode<Node, Relation>[];\n  // 去重边列表，不带自环\n  private links: InternalUpGradeLink<Node, Relation>[];\n  // 自环边\n  private selfLinks: InternalUpGradeLink<Node, Relation>[];\n  // 虚拟节点编号\n  private virtualId: number = 0;\n\n  /** 配置项 */\n  private config: BaseDAGConfig;\n\n  // 整个 DAG 的高度与宽度\n  private width: number;\n  private height: number;\n\n  private paddingSum: number[] = [];\n  private levelPaddings: number[] = [];\n\n  // 节点层级初始化排序使用\n  private levelMap = new Map<number, number>();\n  // 按节点层级划分的\n  private nodesByLevel: InternalUpGradeNode<Node, Relation>[][] = [];\n  // 节点层级中 height 最大的节点\n  private nodesLevelMaxHeight: number[] = [];\n  // dfs 节点标记\n  private dfsVisited: NodeId[] = [];\n  // link 实例\n  private linkInstace: any;\n\n  constructor({\n    nodes,\n    links,\n    selfLinks,\n    config\n  }: {\n    nodes: InternalUpGradeNode<Node, Relation>[];\n    links: InternalUpGradeLink<Node, Relation>[];\n    selfLinks: InternalUpGradeLink<Node, Relation>[];\n    config: BaseDAGConfig;\n  }) {\n    this.nodes = nodes.slice().sort((nodeA, nodeB) => {\n      return nodeA.id > nodeB.id ? 1 : -1;\n    });\n    this.links = links.slice().sort((linkA, linkB) => {\n      return `${linkA.source.id}-${linkA.target.id}` >\n        `${linkB.source.id}-${linkB.target.id}`\n        ? 1\n        : -1;\n    });\n    this.selfLinks = selfLinks.slice();\n    this.config = { ...config };\n  }\n\n  destroy() {\n    this.nodes = null;\n    this.links = null;\n    this.selfLinks = null;\n    this.nodesByLevel = null;\n    this.nodesLevelMaxHeight = null;\n  }\n\n  getOutput(left: number, top: number) {\n    // 加整体偏移量\n    this.nodes.forEach(node => {\n      node.finalPos = {\n        x: node.pos + left,\n        // y: this.paddingSum[node.level] + 50 * node.level + top,\n        // 间隔高度 + 节点层高度 + margin.top + 在层级中高度居中\n        y:\n          this.paddingSum[node.level] +\n          top +\n          this.nodesLevelMaxHeight.reduce((pre, height, index) => {\n            if (index < node.level)\n              return pre + this.nodesLevelMaxHeight[index];\n            return pre;\n          }, 0) +\n          (this.nodesLevelMaxHeight[node.level] - node.nodeHeight) / 2\n      };\n    });\n\n    this.links.forEach(link => {\n      if (link.linkChildren && link.linkChildren.length) {\n        link.finalPath = link.linkChildren.reduce((path, child, index) => {\n          if (index === 0) {\n            return this.linkInstace.getFinalPath(child, this.levelPaddings, false, true);\n          }\n          return path.concat(this.linkInstace.getFinalPath(child, this.levelPaddings, index === link.linkChildren.length - 1, false));\n        }, []);\n      } else {\n        link.finalPath = this.linkInstace.getFinalPath(link, this.levelPaddings, true, true);\n      }\n    });\n\n    this.selfLinks.forEach(link => {\n      link.finalPath = this.linkInstace.getSelfFinalPath(link);\n    });\n\n    // 逆转边还原\n    this.recoverCycle();\n\n    return {\n      nodes: this.nodes.filter(node => node.type !== 'virtual').map(node => {\n      // nodes: this.nodes.map(node => {\n        return {\n          id: node.id,\n          view: {\n            x: node.finalPos.x,\n            y: node.finalPos.y\n          },\n          nodeWidth: node.nodeWidth,\n          nodeHeight: node.nodeHeight,\n          info: node.originInfo\n        };\n      }),\n      links: [\n        ...this.links\n          .filter(\n            link =>\n              link.source.type !== 'virtual' && link.target.type !== 'virtual'\n          )\n          .map(link => {\n            return {\n              sourceId: link.source.id,\n              targetId: link.target.id,\n              path: link.finalPath,\n              info: link.originInfo\n            };\n          }),\n        ...this.selfLinks.map(link => {\n          return {\n            sourceId: link.source.id,\n            targetId: link.target.id,\n            path: link.finalPath,\n            info: link.originInfo\n          };\n        })\n      ],\n      pos: {\n        width: this.width,\n        height: this.height\n      }\n    };\n  }\n\n  run() {\n    // 将有向有环图转为为有向无环图\n    this.clearCycle();\n    // 计算节点层级\n    this.calcNodeLevels();\n    // 计算节点位置\n    this.calcNodePos();\n    // 计算节点坐标\n    this.xcordinate();\n    // 计算线的位置，做成插件分离出来，输入所有 node 的信息\n    this.calcLinkPos();\n    // 计算真实尺寸\n    this.calcRealSize();\n\n    return this;\n  }\n\n  getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  calcLinkPos() {\n    const { linkType, DiyLine } = this.config;\n    const LinkClass = LinkGenerator(linkType, DiyLine);\n    this.linkInstace = new LinkClass(this.nodesByLevel, this.selfLinks, this.config);\n    this.levelPaddings = this.linkInstace.calcPosAndPadding();\n  }\n\n  calcRealSize() {\n    let sum = 0;\n    // 累计 padding\n    this.levelPaddings.forEach((padding, index) => {\n      this.paddingSum[index] = sum;\n      sum += padding;\n    });\n\n    // width 和 height 为纯的宽高\n    this.height =\n      this.paddingSum[this.paddingSum.length - 1] +\n      sumBy(this.nodesLevelMaxHeight, height => height);\n    this.width =\n      this.nodes.reduce((max, curNode) => {\n        return curNode.pos + curNode.nodeWidth > max\n          ? curNode.pos + curNode.nodeWidth\n          : max;\n      }, 0) -\n      this.nodes.reduce((min, curNode) => {\n        return curNode.pos < min ? curNode.pos : min;\n      }, 0);\n  }\n\n  addVirtualNode() {\n    const virtualNodes: InternalUpGradeNode<Node, Relation>[] = [];\n    const virtualLinks: InternalUpGradeLink<Node, Relation>[] = [];\n    this.links.forEach(link => {\n      const source = link.source;\n      const target = link.target;\n\n      const sourceLevel = source.level;\n      const targetLevel = target.level;\n\n      link.linkChildren = [];\n      // 跨层级的边上才需要添加虚拟节点\n      if (sourceLevel + 1 < targetLevel) {\n        for (let i = sourceLevel + 1; i < targetLevel; i++) {\n          const virtualNode: InternalUpGradeNode<Node, Relation> = {\n            id: `virtual${this.virtualId++}`,\n            sourceLinks: [],\n            targetLinks: [],\n            type: 'virtual',\n            nodeWidth: this.config.defaultVirtualNodeWidth,\n            nodeHeight: this.nodesLevelMaxHeight[i],\n            originInfo: {} as any,\n            level: i\n          };\n          const sourceNode =\n            i === sourceLevel + 1\n              ? source\n              : virtualNodes[virtualNodes.length - 1];\n          const virtualLink: InternalUpGradeLink<Node, Relation> = {\n            source: sourceNode,\n            target: virtualNode,\n            originInfo: {} as any,\n            isReverse: link.isReverse,\n          };\n          link.linkChildren.push(virtualLink);\n          virtualLinks.push(virtualLink);\n          sourceNode.sourceLinks.push(virtualLink);\n          virtualNode.targetLinks.push(virtualLink);\n          if (i === targetLevel - 1) {\n            const virtualLink: InternalUpGradeLink<Node, Relation> = {\n              source: virtualNode,\n              target,\n              originInfo: {} as any,\n              isReverse: link.isReverse,\n            };\n            link.linkChildren.push(virtualLink);\n            virtualLinks.push(virtualLink);\n            virtualNode.sourceLinks.push(virtualLink);\n            target.targetLinks.push(virtualLink);\n          }\n          virtualNodes.push(virtualNode);\n        }\n      }\n    });\n\n    this.nodes = [...this.nodes, ...virtualNodes];\n    this.links = [...this.links, ...virtualLinks];\n  }\n\n  dfsOrder(node: InternalUpGradeNode<Node, Relation>) {\n    if (this.dfsVisited.indexOf(node.id) > -1) return;\n\n    const pos = this.levelMap.get(node.level);\n    node.levelPos = pos;\n    node._levelPos = pos;\n    this.levelMap.set(node.level, pos + 1);\n    this.dfsVisited.push(node.id);\n\n    node.sourceLinks.forEach(link => {\n      const { source, target } = link;\n\n      // 只处理相邻层级\n      if (target.level - source.level === 1) {\n        this.dfsOrder(target);\n      }\n    });\n  }\n\n  initOrder() {\n    // 分割进入\n    this.nodes.forEach(node => {\n      const level = node.level;\n      if (this.nodesByLevel[level]) {\n        this.nodesByLevel[level].push(node);\n      } else {\n        this.nodesByLevel[level] = [node];\n        this.levelMap.set(level, 0);\n      }\n    });\n\n    // 利用 dfs 来设置 order，树可以保证初始化排序没有交叉\n    this.dfsVisited = [];\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        if (this.nodesByLevel[i][j].levelPos === undefined) {\n          this.dfsOrder(this.nodesByLevel[i][j]);\n        }\n      }\n    }\n  }\n\n  wmedian(index: number) {\n    /**\n     * 节点中位数\n     * @param nodelevel\n     */\n    function medianNodeLevel(nodelevel: InternalUpGradeNode<Node, Relation>[]) {\n      nodelevel.forEach(node => {\n        // 筛选出非跨层级上游节点，并按照 levelPos 排序\n        const parentNode = node.targetLinks\n          .filter(link => {\n            return link.target.level - link.source.level === 1;\n          })\n          .map(link => link.source);\n        parentNode.sort((node1, node2) => {\n          return node1.levelPos - node2.levelPos;\n        });\n\n        const m = Math.floor(parentNode.length / 2);\n        if (parentNode.length === 0) {\n          node._median = -1;\n        } else if (parentNode.length % 2 === 1) {\n          node._median = parentNode[m].levelPos;\n        } else if (parentNode.length === 2) {\n          node._median = (parentNode[0].levelPos + parentNode[1].levelPos) / 2;\n        } else {\n          const left = parentNode[m - 1].levelPos - parentNode[0].levelPos;\n          const right = parentNode[parentNode.length - 1].levelPos - parentNode[m].levelPos;\n          node._median = (parentNode[m - 1].levelPos * right + parentNode[m].levelPos * left) / (left + right);\n        }\n      });\n    }\n\n    // index 为偶，从上到下，index 为奇，从下到上\n    if (index % 2 === 0) {\n      for (let i = 0; i < this.nodesByLevel.length; i++) {\n        const nodelevel = this.nodesByLevel[i];\n        medianNodeLevel(nodelevel);\n        // 根据 _median 重排序\n        this.nodesByLevel[i] = sortNodelevel(nodelevel);\n      }\n      return;\n    } else {\n      for (let i = this.nodesByLevel.length - 1; i >= 0; i--) {\n        const nodelevel = this.nodesByLevel[i];\n        medianNodeLevel(nodelevel);\n        this.nodesByLevel[i] = sortNodelevel(nodelevel);\n      }\n    }\n  }\n\n  // 求全图交叉数量\n  crossing() {\n    let count = 0;\n    for (let i = 1; i < this.nodesByLevel.length; i++) {\n      count += crossing<Node, Relation>(\n        this.nodesByLevel[i - 1],\n        this.nodesByLevel[i]\n      );\n    }\n    return count;\n  }\n\n  // 交换相邻节点位置\n  transpose() {\n    let bestCount = this.crossing();\n    // 这里 i,j 的顺序与 level、_levelPos 的顺序保持一致\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      if (this.nodesByLevel.length === 1) continue;\n      for (let j = 1; j < this.nodesByLevel[i].length; j++) {\n        // 暂时交换位置\n        this.nodesByLevel[i][j]._levelPos = j - 1;\n        this.nodesByLevel[i][j - 1]._levelPos = j;\n        let currentCount = this.crossing();\n        if (currentCount < bestCount) {\n          // 能减少交叉，完成交换\n          const tmpNode = this.nodesByLevel[i][j];\n          this.nodesByLevel[i][j] = this.nodesByLevel[i][j - 1];\n          this.nodesByLevel[i][j - 1] = tmpNode;\n          bestCount = currentCount;\n        } else {\n          // 没有效果，还原\n          this.nodesByLevel[i][j]._levelPos = j;\n          this.nodesByLevel[i][j - 1]._levelPos = j - 1;\n        }\n      }\n    }\n    return bestCount;\n  }\n\n  /**\n   * 确定同层级中节点的先后排列顺序，这里需要尽可能减少边交叉\n   * 算法来源：A Technique for Drawing Directed Graphs.pdf 第3节\n   * 主要思路是根据 dfs 遍历顺序获取一个初始顺序\n   * 然后是启发式算法：从上到下，从下到上遍历，子节点位置由父节点们来决定，同时每次遍历完成后，尝试交换相邻节点的位置，看看是否能够减少边交叉数\n   * 取最小边交叉数的排序，默认为最优解\n   */\n  ordering() {\n    // 按层级排布，并给予初始化排序\n    this.initOrder();\n    let bestCount = this.crossing();\n    if (bestCount !== 0) {\n      for (let i = 0; i <= MAX_ITERATIONS; i++) {\n        this.wmedian(i);\n        const currentCount = this.transpose();\n        if (bestCount > currentCount) {\n          bestCount = currentCount;\n          // 将所有 _levelPos 赋给 levelPos，并排序\n          this.nodesByLevel.forEach((nodelevel, i) => {\n            nodelevel.forEach(node => (node.levelPos = node._levelPos));\n            nodelevel.sort((node1, node2) => {\n              return node1.levelPos - node2.levelPos;\n            });\n          });\n        }\n      }\n    }\n    // 最终以 levelPos 为准\n    this.nodesByLevel.forEach((nodelevel, i) => {\n      nodelevel.sort((node1, node2) => {\n        return node1.levelPos - node2.levelPos;\n      });\n    });\n  }\n\n  findTypeConflicts() {\n    const conflicts: InternalUpGradeLink<Node, Relation>[] = [];\n\n    // 层级\n    for (let i = 1; i < this.nodesByLevel.length; i++) {\n      let k0 = 0;\n      let scanPos = 0;\n      let prevLayerLength = this.nodesByLevel[i - 1].length;\n\n      // 层级中的节点\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        let node = this.nodesByLevel[i][j];\n        // 寻找两个虚节点连成的边，寻找当前虚拟节点的相邻上游的虚拟节点，有且仅有一个\n        const upVirtualLink =\n          node.type === 'virtual' &&\n          node.targetLinks.filter(link => {\n            return (\n              link.target.level - link.source.level === 1 &&\n              link.source.type === 'virtual'\n            );\n          });\n        const upVirtualNode =\n          upVirtualLink && upVirtualLink.length\n            ? upVirtualLink[0].source\n            : undefined;\n        let k1 = upVirtualNode ? upVirtualNode.levelPos : prevLayerLength;\n\n        // 分段方法\n        // 拥有上一层级虚节点，检查当前虚节点以前的\n        // 当前虚节点为当前层级最后一个节点，检查最后一个虚节点以后的\n        if (upVirtualNode || j === this.nodesByLevel[i].length - 1) {\n          this.nodesByLevel[i].slice(scanPos, j + 1).forEach(curNode => {\n            // 当前层级的上层节点\n            const upCurNodes = curNode.targetLinks\n              .filter(node => node.target.level - node.source.level === 1)\n              .map(link => link.source);\n            upCurNodes.forEach(upCurNode => {\n              const pos = upCurNode.levelPos;\n              if (\n                (pos < k0 || k1 < pos) &&\n                !(upCurNode.type === 'virtual' && curNode.type === 'virtual')\n              ) {\n                conflicts.push(\n                  find(\n                    curNode.targetLinks,\n                    link =>\n                      link.source.id === upCurNode.id &&\n                      link.target.id === curNode.id\n                  )\n                );\n              }\n            });\n          });\n          scanPos = j + 1;\n          k0 = k1;\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  verticalAlignment(\n    vert: 'u' | 'd',\n    typeConflicts: InternalUpGradeLink<Node, Relation>[]\n  ) {\n    const root = {} as any;\n    const align = {} as any;\n\n    function hasConflict(\n      node1: InternalUpGradeNode<Node, Relation>,\n      node2: InternalUpGradeNode<Node, Relation>\n    ) {\n      for (let i = 0; i < typeConflicts.length; i++) {\n        const link = typeConflicts[i];\n        if (\n          (link.source.id === node1.id && link.target.id === node2.id) ||\n          (link.source.id === node2.id && link.target.id === node1.id)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // 初始化\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const { id } = this.nodesByLevel[i][j];\n        root[id] = id;\n        align[id] = id;\n      }\n    }\n\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      // 因为我们是从 0 计数的，所以这里要改为 -1\n      let r = -1;\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const nodeV = this.nodesByLevel[i][j];\n        // 从上到下取上游邻居，从下到上取上游邻居\n        let neighbors =\n          vert === 'u'\n            ? nodeV.targetLinks\n                .filter(link => {\n                  return Math.abs(link.target.level - link.source.level) === 1;\n                })\n                .map(link => link.source)\n            : nodeV.sourceLinks\n                .filter(link => {\n                  return Math.abs(link.target.level - link.source.level) === 1;\n                })\n                .map(link => link.target);\n\n        if (neighbors && neighbors.length) {\n          neighbors.sort((node1, node2) => {\n            return node1.levelPos - node2.levelPos;\n          });\n          // 取邻居中位数节点，1 or 2\n          const mid = (neighbors.length - 1) / 2;\n          for (let z = Math.floor(mid); z <= Math.ceil(mid); z++) {\n            const nodeW = neighbors[z];\n            if (\n              align[nodeV.id] === nodeV.id &&\n              r < nodeW.levelPos &&\n              !hasConflict(nodeV, nodeW)\n            ) {\n              align[nodeW.id] = nodeV.id;\n              align[nodeV.id] = root[nodeV.id] = root[nodeW.id];\n              r = nodeW.levelPos;\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      root,\n      align\n    };\n  }\n\n  horizontalCompaction(root: any, align: any, horiz: 'l' | 'r') {\n    const sink = {} as any;\n    const shift = {} as any;\n    const x = {} as any;\n\n    // 计算块与块间的最大间距，为了适配不同节点宽度\n    const blockSpaceMap: Map<string, number> = new Map<string, number>();\n    this.nodesByLevel.forEach((nodeLevel, i) => {\n      let uNode: InternalUpGradeNode<Node, Relation>;\n      nodeLevel.forEach((vnode) => {\n        const vRootNodeId = root[vnode.id];\n        if (uNode) {\n          const uRootNodeId = root[uNode.id];\n          const blockSpace = blockSpaceMap.has(`${vRootNodeId}-${uRootNodeId}`) || blockSpaceMap.has(`${uRootNodeId}-${vRootNodeId}`) ?\n            blockSpaceMap.get(`${vRootNodeId}-${uRootNodeId}`) || blockSpaceMap.get(`${uRootNodeId}-${vRootNodeId}`) : 0;\n          const curSpace = vnode.nodeWidth / 2 + this.config.nodeAndNodeSpace + uNode.nodeWidth / 2;\n          blockSpaceMap.set(`${vRootNodeId}-${uRootNodeId}`, Math.max(blockSpace, curSpace));\n          blockSpaceMap.set(`${uRootNodeId}-${vRootNodeId}`, Math.max(blockSpace, curSpace));\n        }\n        uNode = vnode;\n      });\n    });\n\n    const placeBlock = (node: InternalUpGradeNode<Node, Relation>) => {\n      if (x[node.id] === undefined) {\n        x[node.id] = 0;\n        let w = node.id;\n        do {\n          // 非第一个\n          const curNode = find(this.nodes, node => node.id === w);\n          if (curNode.levelPos > 0) {\n            // 同层级左相邻节点\n            const preNode = this.nodesByLevel[curNode.level][\n              curNode.levelPos - 1\n            ];\n            // 取根节点\n            const rootId = root[preNode.id];\n            placeBlock(find(this.nodes, node => node.id === rootId));\n            if (sink[node.id] === node.id) {\n              sink[node.id] = sink[rootId];\n            }\n            if (!blockSpaceMap.has(`${rootId}-${root[node.id]}`) && !blockSpaceMap.has(`${root[node.id]}-${rootId}`)) {\n              throw new Error(`${rootId}, ${root[node.id]}无法获取`);\n            }\n            if (sink[node.id] !== sink[rootId]) {\n              shift[sink[rootId]] = Math.min(\n                shift[sink[rootId]],\n                x[node.id] - x[rootId] - (blockSpaceMap.get(`${rootId}-${root[node.id]}`) || blockSpaceMap.get(`${root[node.id]}-${rootId}`))\n              );\n            } else {\n              x[node.id] = Math.max(\n                x[node.id],\n                x[rootId] + (blockSpaceMap.get(`${rootId}-${root[node.id]}`) || blockSpaceMap.get(`${root[node.id]}-${rootId}`))\n              );\n            }\n          }\n          w = align[w];\n          // 块循环结束\n        } while (w !== node.id);\n      }\n    };\n\n    // 初始化\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const { id } = this.nodesByLevel[i][j];\n        sink[id] = id;\n        shift[id] = Number.MAX_SAFE_INTEGER;\n        x[id] = undefined;\n      }\n    }\n\n    // placeBlock\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const { id } = this.nodesByLevel[i][j];\n        if (root[id] === id) {\n          placeBlock(this.nodesByLevel[i][j]);\n        }\n      }\n    }\n\n    // 整理\n    for (let i = 0; i < this.nodesByLevel.length; i++) {\n      for (let j = 0; j < this.nodesByLevel[i].length; j++) {\n        const { id } = this.nodesByLevel[i][j];\n        x[id] = x[root[id]];\n        if (shift[sink[root[id]]] < Number.MAX_SAFE_INTEGER) {\n          x[id] = x[id] + shift[sink[root[id]]];\n        }\n      }\n    }\n\n    return x;\n  }\n\n  getDirectNodesByLevel(vert: 'u' | 'd', horiz: 'l' | 'r') {\n    if (vert === 'u' && horiz === 'l') {\n      return;\n    }\n    if ((vert === 'u' && horiz === 'r') || (vert === 'd' && horiz === 'r')) {\n      this.nodesByLevel = this.nodesByLevel.map((nodeLevel, i) => {\n        return reverseArray(nodeLevel, (node, levelPos) => {\n          node.levelPos = levelPos;\n          return node;\n        });\n      });\n    }\n    if (vert === 'd' && horiz === 'l') {\n      this.nodesByLevel = reverseArray(\n        this.nodesByLevel,\n        (nodeLevel, level) => {\n          return reverseArray(nodeLevel, (node, levelPos) => {\n            node.level = level;\n            node.levelPos = levelPos;\n            return node;\n          });\n        }\n      );\n    }\n  }\n\n  resetLevel() {\n    this.nodesByLevel = reverseArray(this.nodesByLevel, (nodeLevel, level) => {\n      return reverseArray(nodeLevel, (node, levelPos) => {\n        node.level = level;\n        node.levelPos = levelPos;\n        return node;\n      });\n    });\n  }\n\n  /**\n   * 节点具体位置确定，算法稳定，能保证相同节点相同边的 DAG 不发生变动\n   * 算法来源：Fast and Simple Horizontal Coordinate Assignment\n   * 将节点从 左、右、上、下 四个方向进行块划分，拉开最小距离，最终取中位值，实现原理暂时不是很了解\n   */\n  xcordinate() {\n    // 寻找出与（虚拟-虚拟）边交叉的（真实-真实/真实-虚拟）边\n    const typeConflicts = this.findTypeConflicts();\n\n    // 四个方向\n    const xSet = {} as any;\n    ['u', 'd'].forEach((vert: 'u' | 'd') => {\n      ['l', 'r'].forEach((horiz: 'l' | 'r') => {\n        /** 对 nodesByLevel 进行转置 */\n        this.getDirectNodesByLevel(vert, horiz);\n\n        // 相当于块划分\n        const { root, align } = this.verticalAlignment(vert, typeConflicts);\n        const x = this.horizontalCompaction(root, align, horiz);\n\n        // right 方向为负\n        if (horiz === 'r') {\n          for (let key in x) {\n            x[key] = -x[key];\n          }\n        }\n\n        xSet[vert + horiz] = x;\n      });\n    });\n\n    this.resetLevel();\n\n    const {\n      minSet: smallestWidth,\n      minDirect\n    } = this.findSmallestWidthAlignment(xSet);\n    this.alignCoordinates(xSet, smallestWidth, minDirect);\n    const finalPosSet = this.balance(xSet);\n\n    let minPos = Infinity;\n    /** 得出节点最后位置 */\n    this.nodes.forEach(node => {\n      node.pos = finalPosSet[node.id] - node.nodeWidth / 2;\n      if (minPos > node.pos) {\n        minPos = node.pos;\n      }\n    });\n    this.nodes.forEach(node => {\n      node.pos = node.pos - minPos;\n    });\n  }\n\n  /** 从四个方向的几何中寻找一个宽度最小的 */\n  findSmallestWidthAlignment(xSet: any) {\n    let minSet;\n    let minDirect;\n    let minSetValue = Number.MAX_SAFE_INTEGER;\n    for (let direction in xSet) {\n      const xs = xSet[direction];\n      let minValue = Number.MAX_SAFE_INTEGER;\n      let maxValue = Number.MIN_SAFE_INTEGER;\n      for (let key in xs) {\n        const value = xs[key];\n        const node = find(this.nodes, (node) => {\n          // 兼容业务方id为number的情况\n          return String(node.id) === String(key);\n        });\n        if (value + (node.nodeWidth / 2) > maxValue) maxValue = value + (node.nodeWidth / 2);\n        if (value - (node.nodeWidth / 2) < minValue) minValue = value - (node.nodeWidth / 2);\n      }\n      if (maxValue - minValue < minSetValue) {\n        minSetValue = maxValue - minValue;\n        minSet = xs;\n        minDirect = direction;\n      }\n    }\n    return {\n      minSet,\n      minDirect\n    };\n  }\n\n  alignCoordinates(xSet: any, smallestWidth: any, direct: string) {\n    let { maxValue: maxAlign, minValue: minAlign } = getObjectMaxMin(\n      smallestWidth\n    );\n\n    ['u', 'd'].forEach((vert: 'u' | 'd') => {\n      ['l', 'r'].forEach((horiz: 'l' | 'r') => {\n        let alignment = vert + horiz;\n        if (alignment !== direct) {\n          const xs = xSet[alignment];\n          const { maxValue: maxXs, minValue: minXs } = getObjectMaxMin(xs);\n          let delta = horiz === 'l' ? minAlign - minXs : maxAlign - maxXs;\n\n          if (delta) {\n            for (let key in xs) {\n              xs[key] = xs[key] + delta;\n            }\n          }\n        }\n      });\n    });\n  }\n\n  balance(xSet: any) {\n    const posListSet = {} as any;\n    for (let direction in xSet) {\n      for (let key in xSet[direction]) {\n        if (posListSet[key] && posListSet[key].length) {\n          posListSet[key].push(xSet[direction][key]);\n        } else {\n          posListSet[key] = [xSet[direction][key]];\n        }\n      }\n    }\n\n    const finalPosSet = {} as any;\n    for (let key in posListSet) {\n      posListSet[key].sort((a: any, b: any) => a - b);\n      finalPosSet[key] = (posListSet[key][1] + posListSet[key][2]) / 2;\n    }\n\n    return finalPosSet;\n  }\n\n  calcNodePos() {\n    // 添加跨节点边的虚拟节点\n    this.addVirtualNode();\n    // 开始迭代变换\n    this.ordering();\n  }\n\n  recoverCycle() {\n    this.links.forEach((link) => {\n      if (link.isReverse) {\n        this.exchangeLink(link);\n        if (link.linkChildren && link.linkChildren.length) {\n          link.linkChildren.forEach((link) => {\n            if (link.isReverse) {\n              this.exchangeLink(link);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  clearCycleDfs(node: InternalUpGradeNode<Node, Relation>, stack: (string | number)[], isFirst: boolean) {\n    const lastNodeId = stack[stack.length - 1];\n    // 当前节点已被遍历，不需要再遍历\n    if (lastNodeId) {\n      if (this.dfsVisited.indexOf(`${lastNodeId}_${node.id}`) > -1) {\n        return;\n      }\n      this.dfsVisited.push(`${lastNodeId}_${node.id}`);\n    }\n\n    // 当前节点成环，对边进行逆转标记\n    if (stack.indexOf(node.id) > -1) {\n      console.warn('当前图中存在环，已被逆转处理');\n      const link = find(this.links, (link) => {\n        return link.source.id === lastNodeId && link.target.id === node.id;\n      });\n      link.isReverse = true;\n    }\n    \n    // 保证按真实连线进行上下关系\n    const LinkList = isFirst ? node.sourceLinks.filter(link => !link.isCycleRelation) : node.sourceLinks;\n    for (let i = 0; i < LinkList.length; i++) {\n      this.clearCycleDfs(LinkList[i].target, [...stack, node.id], false);\n    }\n    return;\n  }\n\n  exchangeLink(link: InternalUpGradeLink<Node, Relation>) {\n    const source = link.source;\n    const target = link.target;\n\n    // 从 sourceLinks 中去除\n    source.sourceLinks = source.sourceLinks.filter(link => {\n      return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse; \n    });\n    // 添加到 targetLinks \n    source.targetLinks.push(link);\n\n    // 从 targetLinks 中去除\n    target.targetLinks = target.targetLinks.filter(link => {\n      return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse;\n    });\n    target.sourceLinks.push(link);\n\n    link.source = target;\n    link.target = source;\n  }\n\n  /** 利用 dfs 去除环 */\n  clearCycle() {\n    this.dfsVisited = [];\n    for (let i = 0; i < this.nodes.length; i++) {\n      this.clearCycleDfs(this.nodes[i], [], true);\n    }\n    this.links.forEach((link) => {\n      if (link.isReverse) {\n        this.exchangeLink(link);\n      }\n    });\n  }\n\n  /**\n   * 确定节点层级\n   * 算法来源：A Technique for Drawing Directed Graphs，2.3 节，主要采用了生成树的做法，原理难懂且实现比较复杂\n   * 实现算法为简要版本，来源于 jdk137/dag，主要通过获取骨干节点后，其余节点根据自己的父子节点层级来决定层级，比较简单\n   */\n  calcNodeLevels() {\n    this.nodes.forEach(node => {\n      node.linkNumber = node.targetLinks.length + node.sourceLinks.length;\n      node.levelSetted = false;\n    });\n\n    let shrink = true;\n    let boneNodes = this.nodes;\n    // 去除度为 1 的节点的边，获取骨干节点\n    while (shrink) {\n      shrink = false;\n      boneNodes.forEach(node => {\n        if (node.linkNumber === 1) {\n          shrink = true;\n          node.linkNumber = 0;\n          node.sourceLinks.forEach(link => {\n            link.target.linkNumber--;\n          });\n          node.targetLinks.forEach(link => {\n            link.source.linkNumber--;\n          });\n        }\n      });\n      boneNodes = boneNodes.filter(node => {\n        return node.linkNumber > 0;\n      });\n    }\n\n    boneNodes.forEach(node => {\n      node.isBone = true;\n    });\n\n    let level = 0;\n    let confirmNodeLevelList = boneNodes;\n    // boneNodes > 0 说明当前DAG图成环状，如 1—>2 2->3 1->3\n    // 通过不断遍历节点的下游节点，确定节点层级\n    if (boneNodes.length > 0) {\n      while (confirmNodeLevelList.length) {\n        const nextNodes: InternalUpGradeNode<Node, Relation>[] = [];\n        confirmNodeLevelList.forEach(node => {\n          node.level = level;\n          node.sourceLinks.forEach(link => {\n            // @Fix 2018-06-27，需要进行去重处理，不然由于图层级过深，nextNodes 数组会变得很大，导致 crash\n            if (!find(nextNodes, (node) => {\n              return node.id === link.target.id;\n            })) {\n              nextNodes.push(link.target);\n            }\n          });\n        });\n        confirmNodeLevelList = nextNodes;\n        level++;\n      }\n      // 收集节点的上下游骨干节点\n      boneNodes.forEach(node => {\n        const parentBoneNode: InternalUpGradeNode<Node, Relation>[] = [];\n        const childrenBoneNode: InternalUpGradeNode<Node, Relation>[] = [];\n        node.targetLinks.forEach(link => {\n          if (link.source.isBone) {\n            parentBoneNode.push(link.source);\n          }\n        });\n        node.sourceLinks.forEach(link => {\n          if (link.target.isBone) {\n            childrenBoneNode.push(link.target);\n          }\n        });\n        node.parentBoneNode = parentBoneNode;\n        node.childrenBoneNode = childrenBoneNode;\n\n        const minChildLevel: number = (\n          minBy(node.childrenBoneNode, boneNode => boneNode.level) ||\n          ({} as InternalUpGradeNode<Node, Relation>)\n        ).level;\n        // 如果没有父节点，当前节点层级就是最上层子节点的上级\n        if (node.parentBoneNode.length === 0) {\n          node.level = minChildLevel - 1;\n        }\n        if (minChildLevel && minChildLevel - node.level > 1) {\n          // 如果当前节点与最上层子节点相差超过一个层级，就需要进行调整，如果子节点数量少于父节点数量，则当前节点应更加靠近子节点\n          if (node.childrenBoneNode.length < node.parentBoneNode.length) {\n            node.level = minChildLevel - 1;\n          }\n          // 其余情况不需要处理\n        }\n      });\n    } else {\n      // 不成环的情况，将第一个节点设为骨干节点\n      this.nodes[0].level = 0;\n      boneNodes.push(this.nodes[0]);\n    }\n\n    boneNodes.forEach(node => {\n      node.levelSetted = true;\n    });\n    // 处理未成环状的节点，根据他上下游的依赖节点的层级来判断位置\n    let waitSetLevelNodes = boneNodes;\n    while (waitSetLevelNodes.length) {\n      const tmpNodeList: InternalUpGradeNode<Node, Relation>[] = [];\n      waitSetLevelNodes.forEach(node => {\n        node.sourceLinks.forEach(link => {\n          const targetNode = link.target;\n          if (!targetNode.levelSetted) {\n            targetNode.level = node.level + 1;\n            node.levelSetted = true;\n            tmpNodeList.push(targetNode);\n          }\n        });\n        node.targetLinks.forEach(link => {\n          const sourceNode = link.source;\n          if (!sourceNode.levelSetted) {\n            sourceNode.level = node.level - 1;\n            node.levelSetted = true;\n            tmpNodeList.push(sourceNode);\n          }\n        });\n      });\n      waitSetLevelNodes = tmpNodeList;\n    }\n\n    // 归 0 化处理，计算层级可能为负数\n    const minLevel: number = minBy(this.nodes, node => node.level).level;\n    this.nodes.forEach(node => {\n      node.level -= minLevel;\n    });\n\n    // 算出每个层级中最大的节点高度，以匹配节点高度不同\n    const maxLevel: number = maxBy(this.nodes, node => node.level).level;\n    this.nodesLevelMaxHeight = Array(maxLevel + 1).fill(-Infinity);\n    this.nodes.forEach(node => {\n      if (this.nodesLevelMaxHeight[node.level] < node.nodeHeight) {\n        this.nodesLevelMaxHeight[node.level] = node.nodeHeight;\n      }\n    });\n  }\n}\n\nexport default BaseDAG;\n"]},"metadata":{},"sourceType":"module"}