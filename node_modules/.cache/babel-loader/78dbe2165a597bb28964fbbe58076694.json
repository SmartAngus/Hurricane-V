{"ast":null,"code":"/**\n * @file 连线生成类\n */\nimport { getRatio } from './utils';\nimport { isCross, crossPoint, distance } from '../../Utils/graph';\nimport { find } from '../../Utils/utils';\nexport class StraightLine {\n  // 层级节点数据\n  // 自环边\n  // 配置\n  constructor(nodesByLevel, selfLinks, config) {\n    this.nodesByLevel = void 0;\n    this.selfLinks = void 0;\n    this.config = void 0;\n    this.nodeLinkByLevelSourceNodeCount = [];\n    this.nodesByLevel = nodesByLevel;\n    this.selfLinks = selfLinks;\n    this.config = config;\n  }\n\n  calcPosAndPadding() {\n    this.nodesByLevel.forEach(nodelevel => {\n      let count = 0;\n      nodelevel.forEach(node => {\n        if (node.sourceLinks && node.sourceLinks.length) {\n          count += node.sourceLinks.filter(link => {\n            return link.target.level - link.source.level === 1;\n          }).length;\n        }\n      });\n      this.nodeLinkByLevelSourceNodeCount.push(count);\n    });\n    const levelPaddings = []; // 每个层级的间距，index = 0，对应 0 ~ 1 层级的高度\n\n    this.nodesByLevel.forEach((nodelevel, level) => {\n      // 最后一层\n      if (level === this.nodesByLevel.length - 1) {\n        levelPaddings[level] = 0;\n      } else {\n        levelPaddings[level] = Math.max(this.nodeLinkByLevelSourceNodeCount[level] * 15, this.config.levelSpace);\n      }\n    });\n    return levelPaddings;\n  }\n\n  getFinalPath(link, levelPaddings, isLast, isFirst) {\n    // 箭头长度\n    const bDis = 6;\n    const angle = 1 / 2;\n    const startPoint = {\n      x: link.source.finalPos.x + link.source.nodeWidth / 2,\n      y: link.source.finalPos.y + link.source.nodeHeight / 2\n    };\n    const endPoint = {\n      x: link.target.finalPos.x + link.target.nodeWidth / 2,\n      y: link.target.finalPos.y + link.target.nodeHeight / 2\n    }; // @Todo 两个相同节点的相互连接边会重合，要考虑一下如何处理这个特殊情况\n\n    if (isFirst && link.isReverse) {\n      const startNodeEdge = [{\n        x: link.source.finalPos.x,\n        y: link.source.finalPos.y\n      }, {\n        x: link.source.finalPos.x + link.source.nodeWidth,\n        y: link.source.finalPos.y\n      }, {\n        x: link.source.finalPos.x + link.source.nodeWidth,\n        y: link.source.finalPos.y + link.source.nodeHeight\n      }, {\n        x: link.source.finalPos.x,\n        y: link.source.finalPos.y + link.source.nodeHeight\n      }];\n      const cPoint = startNodeEdge.reduce((pre, edge, index) => {\n        if (isCross(startNodeEdge[index], startNodeEdge[index === startNodeEdge.length - 1 ? 0 : index + 1], startPoint, endPoint)) {\n          return crossPoint(startNodeEdge[index], startNodeEdge[index === startNodeEdge.length - 1 ? 0 : index + 1], startPoint, endPoint);\n        }\n\n        return pre;\n      }, null); // 向量长度\n\n      const aDis = distance(endPoint, cPoint); // 计算箭头\n\n      const b = (endPoint.x - cPoint.x) * aDis * bDis * 2 * angle;\n      const a = (endPoint.x - cPoint.x) * (endPoint.x - cPoint.x) + (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y);\n      const c = angle * angle * aDis * aDis * bDis * bDis - (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y) * bDis * bDis;\n      const y1 = cPoint.y + (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x1 = (angle * aDis * bDis + (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) * (endPoint.x - cPoint.x)) / (endPoint.y - cPoint.y) + cPoint.x;\n      const y2 = cPoint.y + (b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x2 = ((endPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) - angle * aDis * bDis) / (endPoint.y - cPoint.y) + cPoint.x;\n      return [startPoint, cPoint, {\n        x: x1,\n        y: y1\n      }, cPoint, {\n        x: x2,\n        y: y2\n      }, cPoint, endPoint];\n    }\n\n    if (isLast && !link.isReverse) {\n      const endNodeEdge = [{\n        x: link.target.finalPos.x,\n        y: link.target.finalPos.y\n      }, {\n        x: link.target.finalPos.x + link.target.nodeWidth,\n        y: link.target.finalPos.y\n      }, {\n        x: link.target.finalPos.x + link.target.nodeWidth,\n        y: link.target.finalPos.y + link.target.nodeHeight\n      }, {\n        x: link.target.finalPos.x,\n        y: link.target.finalPos.y + link.target.nodeHeight\n      }]; // 求焦点\n\n      const cPoint = endNodeEdge.reduce((pre, edge, index) => {\n        if (isCross(endNodeEdge[index], endNodeEdge[index === endNodeEdge.length - 1 ? 0 : index + 1], startPoint, endPoint)) {\n          return crossPoint(endNodeEdge[index], endNodeEdge[index === endNodeEdge.length - 1 ? 0 : index + 1], startPoint, endPoint);\n        }\n\n        return pre;\n      }, null); // 向量长度\n\n      const aDis = distance(startPoint, cPoint); // 计算箭头\n\n      const b = (startPoint.x - cPoint.x) * aDis * bDis * 2 * angle;\n      const a = (startPoint.x - cPoint.x) * (startPoint.x - cPoint.x) + (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y);\n      const c = angle * angle * aDis * aDis * bDis * bDis - (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y) * bDis * bDis;\n      const y1 = cPoint.y + (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x1 = (angle * aDis * bDis + (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) * (startPoint.x - cPoint.x)) / (startPoint.y - cPoint.y) + cPoint.x;\n      const y2 = cPoint.y + (b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x2 = ((startPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) - angle * aDis * bDis) / (startPoint.y - cPoint.y) + cPoint.x;\n      return [startPoint, cPoint, {\n        x: x1,\n        y: y1\n      }, cPoint, {\n        x: x2,\n        y: y2\n      }, cPoint, endPoint];\n    }\n\n    return [startPoint, endPoint];\n  }\n\n  getSelfFinalPath(link) {\n    const x0 = link.source.finalPos.x + link.source.nodeWidth / 2;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.source.nodeWidth / 2 - 30;\n    const y1 = link.target.finalPos.y;\n    return [{\n      x: x0,\n      y: y0\n    }, {\n      x: x0,\n      y: y0 + 12\n    }, {\n      x: link.source.finalPos.x - 24,\n      y: y0 + 12\n    }, {\n      x: link.source.finalPos.x - 24,\n      y: y1 - 12\n    }, {\n      x: x1,\n      y: y1 - 12\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x1 - 3,\n      y: y1 - 5\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x1 + 3,\n      y: y1 - 5\n    }, {\n      x: x1,\n      y: y1\n    }];\n  }\n\n}\nexport class Polyline {\n  // 层级节点数据\n  // 自环边\n  // 配置\n  // 水平线防止重合\n  // 节点度的统计\n  constructor(nodesByLevel, selfLinks, config) {\n    this.nodesByLevel = void 0;\n    this.selfLinks = void 0;\n    this.config = void 0;\n    this.turnYMap = void 0;\n    this.nodeLinkByLevelSourceNodeCount = [];\n    this.nodesByLevel = nodesByLevel;\n    this.selfLinks = selfLinks;\n    this.config = config;\n  } // 计算连线起始位置\n  // 计算层级间距\n\n\n  calcPosAndPadding() {\n    this.nodesByLevel.forEach(nodelevel => {\n      let count = -1;\n      nodelevel.forEach(node => {\n        if (node.sourceLinks && node.sourceLinks.length) {\n          node.sourceNodeIndex = ++count;\n        } // 是否存在自环的情况\n\n\n        const selfLink = find(this.selfLinks, link => {\n          return link.source.id === node.id;\n        }); // 当前 node 下游节点数\n\n        const singleLevelSourceLinkCount = node.sourceLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).length; // 当前 node 上游节点数\n\n        const singleLevelTargetLinkCount = node.targetLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).length; // 会形成环的边是特殊的情况，不能合并\n\n        const singleLevelSourceLinks = node.sourceLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).sort((alink, blink) => {\n          return alink.source.levelPos - blink.source.levelPos || (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0);\n        });\n        const sourceCount = node.sourceLinks.filter(link => {\n          return link.isReverse;\n        }).length + 1;\n        let index = 0;\n        singleLevelSourceLinks.forEach(link => {\n          if (link.isReverse) index++;\n          link.sourcePos = (((index + 1) / (sourceCount + 1) - 0.5) * 0.6 + 0.5) * link.source.nodeWidth;\n        });\n        const singleLevelTargetLinks = node.targetLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).sort((alink, blink) => {\n          return alink.source.levelPos - blink.source.levelPos || (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0);\n        });\n        singleLevelTargetLinks.forEach((link, index) => {\n          link.targetPos = (((index + 1) / (singleLevelTargetLinkCount + 1) - 0.5) * 0.6 + 0.5) * link.target.nodeWidth;\n        });\n\n        if (selfLink) {\n          selfLink.sourcePos = ((1 / (singleLevelSourceLinkCount + 2) - 0.5) * 0.6 + 0.5) * node.nodeWidth;\n          selfLink.targetPos = ((1 / (singleLevelTargetLinkCount + 2) - 0.5) * 0.6 + 0.5) * node.nodeWidth;\n        }\n      });\n      this.nodeLinkByLevelSourceNodeCount.push(count + 1);\n    });\n    const levelPaddings = []; // 每个层级的间距，index = 0，对应 0 ~ 1 层级的高度\n\n    this.nodesByLevel.forEach((nodelevel, level) => {\n      // 最后一层\n      if (level === this.nodesByLevel.length - 1) {\n        levelPaddings[level] = 0;\n      } else {\n        // 计算交叉，在这里把 turnY 计算完成，带在 link 里\n        // Aone #17817948 source 与 target 完全不同的水平线的重合是不被允许的\n        // 本质就是交叉的场景，@Todo 先采用一个简单的避免方案\n        const turnYCount = this.getLevelTurnYIndex(level);\n        levelPaddings[level] = Math.max((turnYCount + 1) * this.config.paddingLineSpace, this.config.levelSpace);\n      }\n    });\n    return levelPaddings;\n  } // turnY 确定在哪个位置上\n\n\n  getLevelTurnYIndex(level) {\n    let turnYCount = 0;\n    const nodelevel = this.nodesByLevel[level];\n    this.turnYMap = new Map();\n    nodelevel.forEach((node, index) => {\n      node.sourceLinks.forEach(link => {\n        // 值仅代表顺序\n        let turnYValue = getRatio(link.source.sourceNodeIndex, this.nodeLinkByLevelSourceNodeCount[link.source.level]);\n\n        if (this.turnYMap.has(turnYValue)) {\n          const {\n            allLine,\n            allRecord\n          } = this.turnYMap.get(turnYValue);\n\n          if (!this.config._isLinkMerge && find(allRecord, item => {\n            // 存在交叉，需要调整 turnY\n            return item.source.pos < link.source.pos && item.target.pos > link.target.pos || item.source.pos > link.source.pos && item.target.pos < link.target.pos;\n          })) {\n            // 遍历 allLine，查看是否有起点或是终点相同的节点，存在即 turnYValue 与其保持一致，没有的话，即 max turnYValue + 0.1\n            let maxTurnYValue = -Infinity;\n            let flag = false;\n\n            for (let i = 0; i < allLine.length; i++) {\n              const line = allLine[i];\n              maxTurnYValue = Math.max(line.turnYValue, maxTurnYValue);\n\n              if (line.source.id === link.source.id || line.target.id === link.target.id) {\n                turnYValue = line.turnYValue;\n                link.turnYValue = turnYValue;\n                flag = true;\n                break;\n              }\n            }\n\n            if (!flag) {\n              turnYValue = maxTurnYValue + 0.1;\n              link.turnYValue = turnYValue;\n              turnYCount++;\n              allLine.push(link);\n            }\n          } else {\n            link.turnYValue = turnYValue;\n          }\n\n          allRecord.push(link);\n          this.turnYMap.set(turnYValue, {\n            allLine,\n            allRecord\n          });\n        } else {\n          turnYCount++;\n          link.turnYValue = turnYValue;\n          this.turnYMap.set(turnYValue, {\n            allLine: [link],\n            allRecord: [link]\n          });\n        }\n      });\n    });\n    const valueArr = [...this.turnYMap.keys()].sort();\n    nodelevel.forEach(node => {\n      node.sourceLinks.forEach(link => {\n        link.turnYIndex = valueArr.indexOf(link.turnYValue) + 1;\n        link.turnYCount = turnYCount;\n      });\n    });\n    return turnYCount;\n  }\n\n  getFinalPath(link, levelPaddings, isLast, isFirst) {\n    const x0 = link.source.finalPos.x + link.sourcePos;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.targetPos;\n    const y1 = link.target.finalPos.y; // 水平线位置，很重要\n\n    let turnY = y0 + levelPaddings[link.source.level] * (link.turnYIndex / (link.turnYCount + 1));\n\n    if (isLast && !link.isReverse) {\n      return [{\n        x: x0,\n        y: y0\n      }, {\n        x: x0,\n        y: turnY\n      }, {\n        x: x1,\n        y: turnY\n      }, {\n        x: x1,\n        y: y1\n      }, {\n        x: x1 - 3,\n        y: y1 - 5\n      }, {\n        x: x1,\n        y: y1\n      }, {\n        x: x1 + 3,\n        y: y1 - 5\n      }, {\n        x: x1,\n        y: y1\n      }];\n    }\n\n    if (isFirst && link.isReverse) {\n      return [{\n        x: x1,\n        y: y1\n      }, {\n        x: x1,\n        y: turnY\n      }, {\n        x: x0,\n        y: turnY\n      }, {\n        x: x0,\n        y: y0\n      }, {\n        x: x0 + 3,\n        y: y0 + 5\n      }, {\n        x: x0,\n        y: y0\n      }, {\n        x: x0 - 3,\n        y: y0 + 5\n      }, {\n        x: x0,\n        y: y0\n      }];\n    }\n\n    return [{\n      x: x0,\n      y: y0\n    }, {\n      x: x0,\n      y: turnY\n    }, {\n      x: x1,\n      y: turnY\n    }, {\n      x: x1,\n      y: y1\n    }];\n  }\n\n  getSelfFinalPath(link) {\n    const x0 = link.source.finalPos.x + link.sourcePos;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.targetPos;\n    const y1 = link.target.finalPos.y;\n    return [{\n      x: x0,\n      y: y0\n    }, {\n      x: x0,\n      y: y0 + 12\n    }, {\n      x: link.source.finalPos.x - 24,\n      y: y0 + 12\n    }, {\n      x: link.source.finalPos.x - 24,\n      y: y1 - 12\n    }, {\n      x: x1,\n      y: y1 - 12\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x1 - 3,\n      y: y1 - 5\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x1 + 3,\n      y: y1 - 5\n    }, {\n      x: x1,\n      y: y1\n    }];\n  }\n\n}\n\nfunction LinkGenerator(type, DiyLine) {\n  switch (type) {\n    case 'straightLine':\n      {\n        return StraightLine;\n      }\n\n    case 'polyline':\n      {\n        return Polyline;\n      }\n\n    case 'diy':\n      {\n        return DiyLine;\n      }\n  }\n}\n\nexport default LinkGenerator;","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseLayout/DAG/Link.ts"],"names":["getRatio","isCross","crossPoint","distance","find","StraightLine","constructor","nodesByLevel","selfLinks","config","nodeLinkByLevelSourceNodeCount","calcPosAndPadding","forEach","nodelevel","count","node","sourceLinks","length","filter","link","target","level","source","push","levelPaddings","Math","max","levelSpace","getFinalPath","isLast","isFirst","bDis","angle","startPoint","x","finalPos","nodeWidth","y","nodeHeight","endPoint","isReverse","startNodeEdge","cPoint","reduce","pre","edge","index","aDis","b","a","c","y1","sqrt","x1","y2","x2","endNodeEdge","getSelfFinalPath","x0","y0","Polyline","turnYMap","sourceNodeIndex","selfLink","id","singleLevelSourceLinkCount","singleLevelTargetLinkCount","targetLinks","singleLevelSourceLinks","sort","alink","blink","levelPos","sourceCount","sourcePos","singleLevelTargetLinks","targetPos","turnYCount","getLevelTurnYIndex","paddingLineSpace","Map","turnYValue","has","allLine","allRecord","get","_isLinkMerge","item","pos","maxTurnYValue","Infinity","flag","i","line","set","valueArr","keys","turnYIndex","indexOf","turnY","LinkGenerator","type","DiyLine"],"mappings":"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","sourcesContent":["/**\n * @file 连线生成类\n */\n\nimport {\n  InternalUpGradeNode,\n  InternalUpGradeLink,\n  DAGAIUConfig\n} from './types';\nimport { getRatio } from './utils';\nimport { isCross, crossPoint, distance, Point } from '../../Utils/graph';\nimport { find } from '../../Utils/utils';\n\nexport type LinkType = 'straightLine' | 'polyline' | 'diy';\n\nexport class StraightLine<Node, Relation> {\n  // 层级节点数据\n  private nodesByLevel: InternalUpGradeNode<Node, Relation>[][];\n  // 自环边\n  private selfLinks: InternalUpGradeLink<Node, Relation>[];\n  // 配置\n  private config: DAGAIUConfig;\n\n  private nodeLinkByLevelSourceNodeCount: number[] = [];\n\n  constructor(\n    nodesByLevel: InternalUpGradeNode<Node, Relation>[][],\n    selfLinks: InternalUpGradeLink<Node, Relation>[],\n    config: DAGAIUConfig\n  ) {\n    this.nodesByLevel = nodesByLevel;\n    this.selfLinks = selfLinks;\n    this.config = config;\n  }\n\n  calcPosAndPadding() {\n    this.nodesByLevel.forEach(nodelevel => {\n      let count = 0;\n      nodelevel.forEach(node => {\n        if (node.sourceLinks && node.sourceLinks.length) {\n          count += node.sourceLinks.filter(link => {\n            return link.target.level - link.source.level === 1;\n          }).length;\n        }\n      });\n      this.nodeLinkByLevelSourceNodeCount.push(count);\n    });\n\n    const levelPaddings: number[] = [];\n    // 每个层级的间距，index = 0，对应 0 ~ 1 层级的高度\n    this.nodesByLevel.forEach((nodelevel, level) => {\n      // 最后一层\n      if (level === this.nodesByLevel.length - 1) {\n        levelPaddings[level] = 0;\n      } else {\n        levelPaddings[level] = Math.max(\n          this.nodeLinkByLevelSourceNodeCount[level] * 15,\n          this.config.levelSpace\n        );\n      }\n    });\n    return levelPaddings;\n  }\n\n  getFinalPath(\n    link: InternalUpGradeLink<Node, Relation>,\n    levelPaddings: number[],\n    isLast: boolean,\n    isFirst: boolean\n  ): Point[] {\n    // 箭头长度\n    const bDis = 6;\n    const angle = 1 / 2;\n\n    const startPoint = {\n      x: link.source.finalPos.x + link.source.nodeWidth / 2,\n      y: link.source.finalPos.y + link.source.nodeHeight / 2\n    };\n    const endPoint = {\n      x: link.target.finalPos.x + link.target.nodeWidth / 2,\n      y: link.target.finalPos.y + link.target.nodeHeight / 2\n    };\n\n    // @Todo 两个相同节点的相互连接边会重合，要考虑一下如何处理这个特殊情况\n    if (isFirst && link.isReverse) {\n      const startNodeEdge = [\n        { x: link.source.finalPos.x, y: link.source.finalPos.y },\n        {\n          x: link.source.finalPos.x + link.source.nodeWidth,\n          y: link.source.finalPos.y\n        },\n        {\n          x: link.source.finalPos.x + link.source.nodeWidth,\n          y: link.source.finalPos.y + link.source.nodeHeight\n        },\n        {\n          x: link.source.finalPos.x,\n          y: link.source.finalPos.y + link.source.nodeHeight\n        }\n      ];\n\n      const cPoint = startNodeEdge.reduce((pre, edge, index) => {\n        if (\n          isCross(\n            startNodeEdge[index],\n            startNodeEdge[index === startNodeEdge.length - 1 ? 0 : index + 1],\n            startPoint,\n            endPoint\n          )\n        ) {\n          return crossPoint(\n            startNodeEdge[index],\n            startNodeEdge[index === startNodeEdge.length - 1 ? 0 : index + 1],\n            startPoint,\n            endPoint\n          );\n        }\n        return pre;\n      }, null);\n\n      // 向量长度\n      const aDis = distance(endPoint, cPoint);\n\n      // 计算箭头\n      const b = (endPoint.x - cPoint.x) * aDis * bDis * 2 * angle;\n      const a =\n        (endPoint.x - cPoint.x) * (endPoint.x - cPoint.x) +\n        (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y);\n      const c =\n        angle * angle * aDis * aDis * bDis * bDis -\n        (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y) * bDis * bDis;\n\n      const y1 = cPoint.y + (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x1 =\n        (angle * aDis * bDis +\n          ((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a)) *\n            (endPoint.x - cPoint.x)) /\n          (endPoint.y - cPoint.y) +\n        cPoint.x;\n\n      const y2 = cPoint.y + (b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x2 =\n        (((endPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c))) /\n          (2 * a) -\n          angle * aDis * bDis) /\n          (endPoint.y - cPoint.y) +\n        cPoint.x;\n\n      return [\n        startPoint,\n        cPoint,\n        { x: x1, y: y1 },\n        cPoint,\n        { x: x2, y: y2 },\n        cPoint,\n        endPoint\n      ];\n    }\n\n    if (isLast && !link.isReverse) {\n      const endNodeEdge = [\n        { x: link.target.finalPos.x, y: link.target.finalPos.y },\n        {\n          x: link.target.finalPos.x + link.target.nodeWidth,\n          y: link.target.finalPos.y\n        },\n        {\n          x: link.target.finalPos.x + link.target.nodeWidth,\n          y: link.target.finalPos.y + link.target.nodeHeight\n        },\n        {\n          x: link.target.finalPos.x,\n          y: link.target.finalPos.y + link.target.nodeHeight\n        }\n      ];\n\n      // 求焦点\n      const cPoint = endNodeEdge.reduce((pre, edge, index) => {\n        if (\n          isCross(\n            endNodeEdge[index],\n            endNodeEdge[index === endNodeEdge.length - 1 ? 0 : index + 1],\n            startPoint,\n            endPoint\n          )\n        ) {\n          return crossPoint(\n            endNodeEdge[index],\n            endNodeEdge[index === endNodeEdge.length - 1 ? 0 : index + 1],\n            startPoint,\n            endPoint\n          );\n        }\n        return pre;\n      }, null);\n\n      // 向量长度\n      const aDis = distance(startPoint, cPoint);\n\n      // 计算箭头\n      const b = (startPoint.x - cPoint.x) * aDis * bDis * 2 * angle;\n      const a =\n        (startPoint.x - cPoint.x) * (startPoint.x - cPoint.x) +\n        (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y);\n      const c =\n        angle * angle * aDis * aDis * bDis * bDis -\n        (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y) * bDis * bDis;\n\n      const y1 = cPoint.y + (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x1 =\n        (angle * aDis * bDis +\n          ((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a)) *\n            (startPoint.x - cPoint.x)) /\n          (startPoint.y - cPoint.y) +\n        cPoint.x;\n\n      const y2 = cPoint.y + (b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n      const x2 =\n        (((startPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c))) /\n          (2 * a) -\n          angle * aDis * bDis) /\n          (startPoint.y - cPoint.y) +\n        cPoint.x;\n\n      return [\n        startPoint,\n        cPoint,\n        { x: x1, y: y1 },\n        cPoint,\n        { x: x2, y: y2 },\n        cPoint,\n        endPoint\n      ];\n    }\n\n    return [startPoint, endPoint];\n  }\n\n  getSelfFinalPath(link: InternalUpGradeLink<Node, Relation>): Point[] {\n    const x0 = link.source.finalPos.x + link.source.nodeWidth / 2;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.source.nodeWidth / 2 - 30;\n    const y1 = link.target.finalPos.y;\n\n    return [\n      { x: x0, y: y0 },\n      { x: x0, y: y0 + 12 },\n      { x: link.source.finalPos.x - 24, y: y0 + 12 },\n      { x: link.source.finalPos.x - 24, y: y1 - 12 },\n      { x: x1, y: y1 - 12 },\n      { x: x1, y: y1 },\n      { x: x1 - 3, y: y1 - 5 },\n      { x: x1, y: y1 },\n      { x: x1 + 3, y: y1 - 5 },\n      { x: x1, y: y1 }\n    ];\n  }\n}\n\nexport class Polyline<Node, Relation> {\n  // 层级节点数据\n  private nodesByLevel: InternalUpGradeNode<Node, Relation>[][];\n  // 自环边\n  private selfLinks: InternalUpGradeLink<Node, Relation>[];\n  // 配置\n  private config: DAGAIUConfig;\n  // 水平线防止重合\n  private turnYMap: Map<number, {\n    /** 线的数量 */\n    allLine: Array<InternalUpGradeLink<Node, Relation>>,\n    /** 记录 */\n    allRecord: Array<InternalUpGradeLink<Node, Relation>>\n  }>;\n\n  // 节点度的统计\n  private nodeLinkByLevelSourceNodeCount: number[] = [];\n\n  constructor(\n    nodesByLevel: InternalUpGradeNode<Node, Relation>[][],\n    selfLinks: InternalUpGradeLink<Node, Relation>[],\n    config: DAGAIUConfig\n  ) {\n    this.nodesByLevel = nodesByLevel;\n    this.selfLinks = selfLinks;\n    this.config = config;\n  }\n\n  // 计算连线起始位置\n  // 计算层级间距\n  calcPosAndPadding() {\n    this.nodesByLevel.forEach(nodelevel => {\n      let count = -1;\n      nodelevel.forEach(node => {\n        if (node.sourceLinks && node.sourceLinks.length) {\n          node.sourceNodeIndex = ++count;\n        }\n\n        // 是否存在自环的情况\n        const selfLink = find(this.selfLinks, link => {\n          return link.source.id === node.id;\n        });\n\n        // 当前 node 下游节点数\n        const singleLevelSourceLinkCount = node.sourceLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).length;\n        // 当前 node 上游节点数\n        const singleLevelTargetLinkCount = node.targetLinks.filter(link => {\n          return link.target.level - link.source.level === 1;\n        }).length;\n\n        // 会形成环的边是特殊的情况，不能合并\n        const singleLevelSourceLinks = node.sourceLinks\n          .filter(link => {\n            return link.target.level - link.source.level === 1;\n          })\n          .sort((alink, blink) => {\n            return (\n              alink.source.levelPos - blink.source.levelPos ||\n              (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0)\n            );\n          });\n\n        const sourceCount =\n          node.sourceLinks.filter(link => {\n            return link.isReverse;\n          }).length + 1;\n\n        let index = 0;\n        singleLevelSourceLinks.forEach(link => {\n          if (link.isReverse) index++;\n          link.sourcePos =\n            (((index + 1) / (sourceCount + 1) - 0.5) * 0.6 + 0.5) *\n            link.source.nodeWidth;\n        });\n\n        const singleLevelTargetLinks = node.targetLinks\n          .filter(link => {\n            return link.target.level - link.source.level === 1;\n          })\n          .sort((alink, blink) => {\n            return (\n              alink.source.levelPos - blink.source.levelPos ||\n              (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0)\n            );\n          });\n        singleLevelTargetLinks.forEach((link, index) => {\n          link.targetPos =\n            (((index + 1) / (singleLevelTargetLinkCount + 1) - 0.5) * 0.6 +\n              0.5) *\n            link.target.nodeWidth;\n        });\n\n        if (selfLink) {\n          selfLink.sourcePos =\n            ((1 / (singleLevelSourceLinkCount + 2) - 0.5) * 0.6 + 0.5) *\n            node.nodeWidth;\n          selfLink.targetPos =\n            ((1 / (singleLevelTargetLinkCount + 2) - 0.5) * 0.6 + 0.5) *\n            node.nodeWidth;\n        }\n      });\n      this.nodeLinkByLevelSourceNodeCount.push(count + 1);\n    });\n\n    const levelPaddings = [] as any[];\n    // 每个层级的间距，index = 0，对应 0 ~ 1 层级的高度\n    this.nodesByLevel.forEach((nodelevel, level) => {\n      // 最后一层\n      if (level === this.nodesByLevel.length - 1) {\n        levelPaddings[level] = 0;\n      } else {\n        // 计算交叉，在这里把 turnY 计算完成，带在 link 里\n        // Aone #17817948 source 与 target 完全不同的水平线的重合是不被允许的\n        // 本质就是交叉的场景，@Todo 先采用一个简单的避免方案\n        const turnYCount = this.getLevelTurnYIndex(level);\n        levelPaddings[level] = Math.max(\n          (turnYCount + 1) *\n            this.config.paddingLineSpace,\n          this.config.levelSpace\n        );\n      }\n    });\n    return levelPaddings;\n  }\n\n  // turnY 确定在哪个位置上\n  getLevelTurnYIndex(level: number): number {\n    let turnYCount = 0;\n    const nodelevel = this.nodesByLevel[level];\n    this.turnYMap = new Map();\n    nodelevel.forEach((node, index) => {\n      node.sourceLinks.forEach((link) => {\n        // 值仅代表顺序\n        let turnYValue = getRatio(\n          link.source.sourceNodeIndex,\n          this.nodeLinkByLevelSourceNodeCount[link.source.level]\n        );\n        if (this.turnYMap.has(turnYValue)) {\n          const { allLine, allRecord } = this.turnYMap.get(turnYValue);\n          if (!this.config._isLinkMerge && find(allRecord, (item) => {\n            // 存在交叉，需要调整 turnY\n            return (item.source.pos < link.source.pos\n              && item.target.pos > link.target.pos)\n              || (item.source.pos > link.source.pos\n                && item.target.pos < link.target.pos);\n          })) {\n            // 遍历 allLine，查看是否有起点或是终点相同的节点，存在即 turnYValue 与其保持一致，没有的话，即 max turnYValue + 0.1\n            let maxTurnYValue = -Infinity;\n            let flag = false;\n            for (let i = 0; i < allLine.length; i++) {\n              const line = allLine[i];\n              maxTurnYValue = Math.max(line.turnYValue, maxTurnYValue);\n              if (line.source.id === link.source.id || line.target.id === link.target.id) {\n                turnYValue = line.turnYValue;\n                link.turnYValue = turnYValue;\n                flag = true;\n                break;\n              }\n            }\n            if (!flag) {\n              turnYValue = maxTurnYValue + 0.1;\n              link.turnYValue = turnYValue;\n              turnYCount++;\n              allLine.push(link);\n            }\n          } else {\n            link.turnYValue = turnYValue;\n          }\n\n          allRecord.push(link);\n          this.turnYMap.set(turnYValue, {\n            allLine,\n            allRecord,\n          });\n        } else {\n          turnYCount++;\n          link.turnYValue = turnYValue;\n          this.turnYMap.set(turnYValue, {\n            allLine: [link],\n            allRecord: [link],\n          });\n        }\n      });\n    });\n\n    const valueArr: number[] = [...this.turnYMap.keys()].sort();\n    nodelevel.forEach((node) => {\n      node.sourceLinks.forEach((link) => {\n        link.turnYIndex = valueArr.indexOf(link.turnYValue) + 1;\n        link.turnYCount = turnYCount;\n      });\n    });\n    return turnYCount;\n  }\n\n  getFinalPath(\n    link: InternalUpGradeLink<Node, Relation>,\n    levelPaddings: number[],\n    isLast: boolean,\n    isFirst: boolean\n  ): Point[] {\n    const x0 = link.source.finalPos.x + link.sourcePos;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.targetPos;\n    const y1 = link.target.finalPos.y;\n\n    // 水平线位置，很重要\n    let turnY = y0 + levelPaddings[link.source.level] * (link.turnYIndex / (link.turnYCount + 1));\n\n    if (isLast && !link.isReverse) {\n      return [\n        { x: x0, y: y0 },\n        { x: x0, y: turnY },\n        { x: x1, y: turnY },\n        { x: x1, y: y1 },\n        { x: x1 - 3, y: y1 - 5 },\n        { x: x1, y: y1 },\n        { x: x1 + 3, y: y1 - 5 },\n        { x: x1, y: y1 }\n      ];\n    }\n\n    if (isFirst && link.isReverse) {\n      return [\n        { x: x1, y: y1 },\n        { x: x1, y: turnY },\n        { x: x0, y: turnY },\n        { x: x0, y: y0 },\n        { x: x0 + 3, y: y0 + 5 },\n        { x: x0, y: y0 },\n        { x: x0 - 3, y: y0 + 5 },\n        { x: x0, y: y0 }\n      ];\n    }\n\n    return [\n      { x: x0, y: y0 },\n      { x: x0, y: turnY },\n      { x: x1, y: turnY },\n      { x: x1, y: y1 }\n    ];\n  }\n\n  getSelfFinalPath(link: InternalUpGradeLink<Node, Relation>): Point[] {\n    const x0 = link.source.finalPos.x + link.sourcePos;\n    const y0 = link.source.finalPos.y + link.source.nodeHeight;\n    const x1 = link.target.finalPos.x + link.targetPos;\n    const y1 = link.target.finalPos.y;\n\n    return [\n      { x: x0, y: y0 },\n      { x: x0, y: y0 + 12 },\n      { x: link.source.finalPos.x - 24, y: y0 + 12 },\n      { x: link.source.finalPos.x - 24, y: y1 - 12 },\n      { x: x1, y: y1 - 12 },\n      { x: x1, y: y1 },\n      { x: x1 - 3, y: y1 - 5 },\n      { x: x1, y: y1 },\n      { x: x1 + 3, y: y1 - 5 },\n      { x: x1, y: y1 }\n    ];\n  }\n}\n\nfunction LinkGenerator(type: LinkType, DiyLine?: any) {\n  switch (type) {\n    case 'straightLine': {\n      return StraightLine;\n    }\n    case 'polyline': {\n      return Polyline;\n    }\n    case 'diy': {\n      return DiyLine;\n    }\n  }\n}\n\nexport default LinkGenerator;\n"]},"metadata":{},"sourceType":"module"}