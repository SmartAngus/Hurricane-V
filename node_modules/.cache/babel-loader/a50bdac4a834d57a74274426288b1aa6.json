{"ast":null,"code":"/**\n * @file 图操作\n */\nimport { defaultGraphConfig } from \"./type\";\nimport { find } from '../Utils/utils';\n\n/** 内部索引图节点 */\nclass _GraphVertex {\n  /** 节点识别 id */\n\n  /** 相关联的边，包含同向边和异向边 */\n\n  /** 源信息，与 Vertex[] 对应 */\n  constructor(config) {\n    this.id = void 0;\n    this.edges = [];\n    this.origin = void 0;\n    this.id = config.id;\n    this.edges = config.edges;\n    this.origin = config.origin;\n  } // 根据关联节点 id，获取节点的边\n\n\n  getEdge(id, isDirect) {\n    if (isDirect) {\n      return find(this.edges, edge => {\n        return edge.v.id === id;\n      }) || null;\n    }\n\n    return find(this.edges, edge => {\n      return edge.u.id === id || edge.v.id === id;\n    }) || null;\n  } // 获取节点的所有关联边，有向需要区分入度，出度，默认 out\n\n\n  getEdges(isDirect, direct = 'out') {\n    if (isDirect) {\n      return this.edges.filter(edge => {\n        // 求解下游边\n        if (direct === 'out') {\n          return edge.u.id === this.id;\n        }\n\n        return edge.v.id === this.id;\n      });\n    }\n\n    return this.edges;\n  } // 获取节点的所有关联节点，有向需要区分入度，出度，默认 out\n\n\n  getAdjacentVertexes(isDirect, direct = 'out') {\n    if (isDirect) {\n      return this.getEdges(isDirect, direct).map(edge => {\n        return edge.u.id === this.id ? edge.v : edge.u;\n      });\n    }\n\n    return this.edges.map(edge => {\n      return edge.u.id === this.id ? edge.v : edge.u;\n    });\n  }\n\n}\n/** 内部索引图边 */\n\n\nclass _GraphEdge {\n  /** 一端节点索引 */\n\n  /** 另一端节点索引 */\n\n  /** 源信息，与 Edge[] 对应 */\n  constructor(config) {\n    this.u = void 0;\n    this.v = void 0;\n    this.origin = void 0;\n    this.u = config.u;\n    this.v = config.v;\n    this.origin = config.origin;\n  }\n\n}\n/**\n * 内部存成领接表 边带节点\n */\n\n\nclass Graph {\n  // 外界传入的节点数据\n  // 外界传入的边数据\n  // 内部领接表图\n  // 节点索引 map\n  // 内部图是否构建完成\n  // 图配置\n  // 图节点是否已经访问过了\n  constructor(vertexes, edges, graphConfig = defaultGraphConfig) {\n    this.vertexes = [];\n    this.edges = [];\n    this._graph = [];\n    this._graphMap = new Map();\n    this._graphReady = void 0;\n    this.graphConfig = void 0;\n    this.visited = [];\n    this.vertexes = vertexes;\n    this.edges = edges;\n    this.graphConfig = graphConfig; // @Todo 树图均需要检测是否重复边和重复点\n    // @Todo 是否可以根据数据特征，自动判别有向还是无向？\n\n    if (!this.graphConfig.isDirect) {// @Todo 无向图，不能出现，edge.u === edge.v && edge.v === edge.u 的情况\n    }\n\n    this._graph = this._createGraph();\n  }\n\n  _createGraph() {\n    this._graphReady = false;\n\n    this._graphMap.clear();\n\n    const vertexes = this.vertexes.map(vertex => {\n      return new _GraphVertex({\n        id: vertex.id,\n        edges: [],\n        origin: vertex\n      });\n    });\n    vertexes.forEach(vertex => {\n      this._graphMap.set(vertex.id, vertex);\n    });\n    this.edges.forEach(edge => {\n      const {\n        u,\n        v\n      } = edge;\n      const uVertex = this.getVertex(u);\n      const vVertex = this.getVertex(v);\n      const graphEdge = new _GraphEdge({\n        u: uVertex,\n        v: vVertex,\n        origin: edge\n      });\n      uVertex.edges.push(graphEdge);\n      vVertex.edges.push(graphEdge);\n    });\n    this._graphReady = true;\n    return vertexes;\n  }\n\n  _defaultIsDfs(id) {\n    if (this.visited.includes(id)) {\n      return false;\n    }\n\n    this.visited.push(id);\n    return true;\n  }\n  /** dfs 遍历图，@Todo 先复制树操作的代码，后面再统一 */\n\n\n  dfs(vertex, getAdjacentVertexes, callback, isDfs = () => true, callBackResult = null, _isFirst = true) {\n    if (_isFirst) {\n      this.visited = [];\n    }\n\n    if (!isDfs(vertex.id) || !this._defaultIsDfs(vertex.id)) {\n      return;\n    }\n\n    getAdjacentVertexes(vertex).forEach((node, index) => {\n      const result = callback(vertex, node, callBackResult, index);\n      this.dfs(node, getAdjacentVertexes, callback, isDfs, result, false);\n    });\n\n    if (_isFirst) {\n      this.visited = [];\n    }\n  }\n  /** 获取边 */\n\n\n  getEdge(u, v) {\n    if (!this._graphMap.has(u) || !this._graphMap.has(v)) {\n      return null;\n    }\n\n    const graphNode = this._graphMap.get(u);\n\n    return graphNode.getEdge(v, this.graphConfig.isDirect);\n  }\n  /** 获取节点 */\n\n\n  getVertex(id) {\n    if (!this._graphMap.has(id)) {\n      return null;\n    }\n\n    return this._graphMap.get(id);\n  }\n  /** 获取所有关联节点 */\n\n\n  getAdjacentVertexes(id, direct = 'out') {\n    if (!this._graphMap.has(id)) {\n      return [];\n    }\n\n    return this._graphMap.get(id).getAdjacentVertexes(this.graphConfig.isDirect, direct);\n  }\n  /** 以一个点作为起点，输出图, */\n  // @Todo 无向图有问题\n\n\n  getGraph(nodeId) {\n    const id = nodeId || this.vertexes[0].id;\n\n    if (!this._graphMap.has(id)) {\n      return null;\n    }\n\n    const source = this._graphMap.get(id);\n\n    const tempNodeMap = new Map();\n    const vertexes = { ...source.origin,\n      _id: source.id,\n      _relations: []\n    };\n    tempNodeMap.set(source.id, vertexes);\n    this.dfs(vertexes, vertex => {\n      const _graphNode = this._graphMap.get(vertex.id);\n\n      _graphNode.getEdges(this.graphConfig.isDirect).forEach(edge => {\n        vertex._relations.push({ ...edge.origin,\n          _u: null,\n          _v: null,\n          _origin: edge.origin\n        });\n      });\n\n      return _graphNode.getAdjacentVertexes(this.graphConfig.isDirect).map(_node => {\n        // _node 可能已经存在，需要返回引用，使关联\n        if (tempNodeMap.has(_node.id)) {\n          return tempNodeMap.get(_node.id);\n        }\n\n        const node = { ..._node.origin,\n          _id: _node.id,\n          _relations: [],\n          _origin: _node.origin\n        };\n        tempNodeMap.set(_node.id, node);\n        return node;\n      });\n    }, (source, target) => {\n      const relation = find(source._relations, relation => {\n        // @Todo 边的方向\n        return relation.u === source._id && relation.v === target._id;\n      });\n      relation._u = source;\n      relation._v = target;\n    });\n    tempNodeMap.clear();\n    return vertexes;\n  }\n  /** 更新图节点数据 */\n\n\n  updateVertex(vertex) {\n    if (!this._graphMap.has(vertex.id)) {\n      return;\n    }\n\n    const curVertex = this._graphMap.get(vertex.id);\n\n    curVertex.origin = vertex;\n    this.vertexes = this.vertexes.map(node => {\n      return node.id === vertex.id ? vertex : node;\n    });\n  }\n  /** 更新图边数据 */\n  // @Todo 需要考虑有向无向\n\n\n  updateEdge(edge) {\n    if (!this._graphMap.has(edge.v) || !this._graphMap.has(edge.u)) {\n      return;\n    }\n\n    const curU = this._graphMap.get(edge.u);\n\n    const curEdge = curU.getEdge(edge.v, this.graphConfig.isDirect);\n\n    if (curEdge) {\n      curEdge.origin = edge;\n      this.edges = this.edges.map(e => {\n        if (e.u === edge.u && e.v === edge.v) {\n          return edge;\n        }\n\n        return e;\n      });\n    }\n  }\n  /** 更新图 */\n  // @Todo 需要考虑有向无向\n  // 目前只考虑增，没有考虑减\n\n\n  updateGraph(vertexes, edges, changeVertex = newV => newV, changeEdge = newE => newE) {\n    this._graphReady = false;\n    const newVertexes = vertexes.map(vertex => {\n      if (this._graphMap.has(vertex.id)) {\n        const oldVertex = this._graphMap.get(vertex.id).origin;\n\n        const newVertex = changeVertex(vertex, oldVertex);\n        this.updateVertex(newVertex);\n        return this._graphMap.get(vertex.id);\n      }\n\n      this.vertexes.push(vertex);\n      return new _GraphVertex({\n        id: vertex.id,\n        edges: [],\n        origin: vertex\n      });\n    });\n    newVertexes.forEach(vertex => {\n      if (!this._graphMap.has(vertex.id)) {\n        this._graphMap.set(vertex.id, vertex);\n      }\n    });\n    edges.forEach(edge => {\n      const {\n        u,\n        v\n      } = edge;\n      const uVertex = this.getVertex(u);\n      const vVertex = this.getVertex(v); // 需要去掉重复的边\n      // @Todo 需要考虑有向无向\n\n      if (!this.getEdge(u, v)) {\n        const graphEdge = new _GraphEdge({\n          u: uVertex,\n          v: vVertex,\n          origin: edge\n        });\n        this.edges.push(edge);\n        uVertex.edges.push(graphEdge);\n        vVertex.edges.push(graphEdge);\n      } else {\n        const oldEdge = this.getEdge(u, v).origin;\n        const newEdge = changeEdge(edge, oldEdge);\n        this.updateEdge(newEdge);\n      }\n    });\n    this._graphReady = true;\n  }\n\n}\n\nexport default Graph;","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseGraph/Graph.ts"],"names":["defaultGraphConfig","find","_GraphVertex","constructor","config","id","edges","origin","getEdge","isDirect","edge","v","u","getEdges","direct","filter","getAdjacentVertexes","map","_GraphEdge","Graph","vertexes","graphConfig","_graph","_graphMap","Map","_graphReady","visited","_createGraph","clear","vertex","forEach","set","uVertex","getVertex","vVertex","graphEdge","push","_defaultIsDfs","includes","dfs","callback","isDfs","callBackResult","_isFirst","node","index","result","has","graphNode","get","getGraph","nodeId","source","tempNodeMap","_id","_relations","_graphNode","_u","_v","_origin","_node","target","relation","updateVertex","curVertex","updateEdge","curU","curEdge","e","updateGraph","changeVertex","newV","changeEdge","newE","newVertexes","oldVertex","newVertex","oldEdge","newEdge"],"mappings":"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","sourcesContent":["/**\n * @file 图操作\n */\n\nimport { GraphConfig, defaultGraphConfig, OutputGraphVertex } from \"./type\";\nimport { find } from '../Utils/utils';\nimport { BaseVertex, BaseEdge, Vertex, Edge } from '../type';\n\n/** 内部索引图节点 */\nclass _GraphVertex<V, E> {\n  /** 节点识别 id */\n  id: string;\n  /** 相关联的边，包含同向边和异向边 */\n  edges: _GraphEdge<V, E>[] = [];\n  /** 源信息，与 Vertex[] 对应 */\n  origin: V;\n\n  constructor(config: {\n    id: string;\n    edges: _GraphEdge<V, E>[];\n    origin: V;\n  }) {\n    this.id = config.id;\n    this.edges = config.edges;\n    this.origin = config.origin;\n  }\n\n  // 根据关联节点 id，获取节点的边\n  getEdge(id: string, isDirect: boolean): _GraphEdge<V, E> {\n    if (isDirect) {\n      return find(this.edges, (edge) => {\n        return edge.v.id === id;\n      }) || null;\n    }\n    return find(this.edges, (edge) => {\n      return edge.u.id === id || edge.v.id === id;\n    }) || null;\n  }\n\n  // 获取节点的所有关联边，有向需要区分入度，出度，默认 out\n  getEdges(isDirect: boolean, direct: 'in' | 'out' = 'out'): _GraphEdge<V, E>[] {\n    if (isDirect) {\n      return this.edges.filter(edge => {\n        // 求解下游边\n        if (direct === 'out') {\n          return edge.u.id === this.id;\n        }\n        return edge.v.id === this.id;\n      });\n    }\n    return this.edges;\n  }\n\n  // 获取节点的所有关联节点，有向需要区分入度，出度，默认 out\n  getAdjacentVertexes(isDirect: boolean, direct: 'in' | 'out' = 'out'): _GraphVertex<V, E>[] {\n    if (isDirect) {\n      return this.getEdges(isDirect, direct).map(edge => {\n        return edge.u.id === this.id ? edge.v : edge.u;\n      });\n    }\n    return this.edges.map(edge => {\n      return edge.u.id === this.id ? edge.v : edge.u;\n    });\n  }\n}\n\n/** 内部索引图边 */\nclass _GraphEdge<V, E> {\n  /** 一端节点索引 */\n  u: _GraphVertex<V, E>;\n  /** 另一端节点索引 */\n  v: _GraphVertex<V, E>;\n  /** 源信息，与 Edge[] 对应 */\n  origin: E;\n\n  constructor(config: {\n    u: _GraphVertex<V, E>,\n    v: _GraphVertex<V, E>,\n    origin: E,\n  }) {\n    this.u = config.u;\n    this.v = config.v;\n    this.origin = config.origin;\n  }\n}\n\n/**\n * 内部存成领接表 边带节点\n */\nclass Graph<V extends BaseVertex, E extends BaseEdge> {\n  // 外界传入的节点数据\n  private vertexes: Array<Vertex<V>> = [];\n  // 外界传入的边数据\n  private edges: Array<Edge<E>> = [];\n\n  // 内部领接表图\n  private _graph: _GraphVertex<V, E>[] = [];\n  // 节点索引 map\n  private _graphMap: Map<string, _GraphVertex<V, E>> = new Map();\n  // 内部图是否构建完成\n  private _graphReady: boolean;\n  // 图配置\n  private graphConfig: GraphConfig;\n  // 图节点是否已经访问过了\n  private visited: string[] = [];\n\n  constructor(vertexes: Array<Vertex<V>>, edges: Array<Edge<E>>, graphConfig = defaultGraphConfig) {\n    this.vertexes = vertexes;\n    this.edges = edges;\n    this.graphConfig = graphConfig;\n    // @Todo 树图均需要检测是否重复边和重复点\n    // @Todo 是否可以根据数据特征，自动判别有向还是无向？\n    if (!this.graphConfig.isDirect) {\n      // @Todo 无向图，不能出现，edge.u === edge.v && edge.v === edge.u 的情况\n    }\n    this._graph = this._createGraph();\n  }\n\n  _createGraph(): _GraphVertex<V, E>[] {\n    this._graphReady = false;\n    this._graphMap.clear();\n\n    const vertexes = this.vertexes.map(vertex => {\n      return new _GraphVertex<V, E>({\n        id: vertex.id,\n        edges: [],\n        origin: vertex,\n      });\n    });\n\n    vertexes.forEach((vertex) => {\n      this._graphMap.set(vertex.id, vertex);\n    });\n\n    this.edges.forEach((edge) => {\n      const { u, v } = edge;\n      const uVertex = this.getVertex(u);\n      const vVertex = this.getVertex(v);\n\n      const graphEdge = new _GraphEdge<V, E>({\n        u: uVertex,\n        v: vVertex,\n        origin: edge,\n      });\n\n      uVertex.edges.push(graphEdge);\n      vVertex.edges.push(graphEdge);\n    });\n\n    this._graphReady = true;\n\n    return vertexes;\n  }\n\n  _defaultIsDfs(id: string) {\n    if (this.visited.includes(id)) {\n      return false;\n    }\n    this.visited.push(id);\n    return true;\n  }\n\n  /** dfs 遍历图，@Todo 先复制树操作的代码，后面再统一 */\n  dfs<N extends { id: string }, R>(\n    vertex: N,\n    getAdjacentVertexes: (source: N) => N[],\n    callback: (source: N, target: N, preCallBackResult: R, index: number) => R,\n    isDfs: (id: string) => boolean = () => true,\n    callBackResult: R = null,\n    _isFirst = true,\n  ) {\n    if (_isFirst) {\n      this.visited = [];\n    }\n    if (!isDfs(vertex.id) || !this._defaultIsDfs(vertex.id)) {\n      return;\n    }\n    getAdjacentVertexes(vertex).forEach((node, index) => {\n      const result = callback(vertex, node, callBackResult, index);\n      this.dfs(node, getAdjacentVertexes, callback, isDfs, result, false);\n    });\n    if (_isFirst) {\n      this.visited = [];\n    }\n  }\n\n  /** 获取边 */\n  getEdge(u: string, v: string): _GraphEdge<V, E> {\n    if (!this._graphMap.has(u) || !this._graphMap.has(v)) {\n      return null;\n    }\n    const graphNode = this._graphMap.get(u);\n    return graphNode.getEdge(v, this.graphConfig.isDirect);\n  }\n\n  /** 获取节点 */\n  getVertex(id: string): _GraphVertex<V, E> {\n    if (!this._graphMap.has(id)) {\n      return null;\n    }\n    return this._graphMap.get(id);\n  }\n\n  /** 获取所有关联节点 */\n  getAdjacentVertexes(id: string, direct: 'in' | 'out' = 'out'): _GraphVertex<V, E>[] {\n    if (!this._graphMap.has(id)) {\n      return [];\n    }\n    return this._graphMap.get(id).getAdjacentVertexes(this.graphConfig.isDirect, direct);\n  }\n\n  /** 以一个点作为起点，输出图, */\n  // @Todo 无向图有问题\n  getGraph(nodeId?: string): OutputGraphVertex<Vertex<V>, Edge<E>> {\n    const id = nodeId || this.vertexes[0].id;\n    if (!this._graphMap.has(id)) {\n      return null;\n    }\n\n    const source = this._graphMap.get(id);\n\n    const tempNodeMap: Map<string, OutputGraphVertex<Vertex<V>, Edge<E>>> = new Map();\n    const vertexes: OutputGraphVertex<Vertex<V>, Edge<E>> = {\n      ...(source.origin as any),\n      _id: source.id,\n      _relations: [],\n    };\n    tempNodeMap.set(source.id, vertexes);\n    \n    this.dfs<OutputGraphVertex<Vertex<V>, Edge<E>>, void>(\n      vertexes,\n      (vertex) => {\n        const _graphNode = this._graphMap.get(vertex.id);\n\n        _graphNode.getEdges(this.graphConfig.isDirect).forEach(edge => {\n          vertex._relations.push({\n            ...(edge.origin as any),\n            _u: null,\n            _v: null,\n            _origin: edge.origin,\n          });\n        });\n        \n        return _graphNode.getAdjacentVertexes(this.graphConfig.isDirect).map(_node => {\n          // _node 可能已经存在，需要返回引用，使关联\n          if (tempNodeMap.has(_node.id)) {\n            return tempNodeMap.get(_node.id);\n          }\n          const node = {\n            ...(_node.origin as any),\n            _id: _node.id,\n            _relations: [],\n            _origin: _node.origin,\n          };\n          tempNodeMap.set(_node.id, node);\n          return node;\n        });\n      },\n      (source, target) => {\n        const relation = find(source._relations, (relation) => {\n          // @Todo 边的方向\n          return relation.u === source._id && relation.v === target._id;\n        });\n        relation._u = source;\n        relation._v = target;\n      }\n    );\n\n    tempNodeMap.clear();\n    \n    return vertexes;\n  }\n\n  /** 更新图节点数据 */\n  updateVertex(vertex: V): void {\n    if (!this._graphMap.has(vertex.id)) {\n      return;\n    }\n\n    const curVertex = this._graphMap.get(vertex.id);\n    curVertex.origin = vertex;\n\n    this.vertexes = this.vertexes.map(node => {\n      return node.id === vertex.id ? vertex : node;\n    });\n  }\n\n  /** 更新图边数据 */\n  // @Todo 需要考虑有向无向\n  updateEdge(edge: E): void {\n    if (!this._graphMap.has(edge.v) || !this._graphMap.has(edge.u)) {\n      return;\n    }\n\n    const curU = this._graphMap.get(edge.u);\n    const curEdge = curU.getEdge(edge.v, this.graphConfig.isDirect);\n\n    if (curEdge) {\n      curEdge.origin = edge;\n      this.edges = this.edges.map(e => {\n        if (e.u === edge.u && e.v === edge.v) {\n          return edge;\n        }\n        return e;\n      });\n    }\n  }\n\n  /** 更新图 */\n  // @Todo 需要考虑有向无向\n  // 目前只考虑增，没有考虑减\n  updateGraph(\n    vertexes: Array<Vertex<V>>,\n    edges: Array<Edge<E>>,\n    changeVertex: (newV: V, oldV: V) => V = (newV) => newV,\n    changeEdge: (newE: E, oldE: E) => E = (newE) => newE,\n  ) {\n    this._graphReady = false;\n\n    const newVertexes = vertexes.map(vertex => {\n      if (this._graphMap.has(vertex.id)) {\n        const oldVertex = this._graphMap.get(vertex.id).origin;\n        const newVertex = changeVertex(vertex, oldVertex);\n        this.updateVertex(newVertex);\n        return this._graphMap.get(vertex.id);\n      }\n      this.vertexes.push(vertex);\n      return new _GraphVertex<V, E>({\n        id: vertex.id,\n        edges: [],\n        origin: vertex,\n      });\n    });\n\n    newVertexes.forEach((vertex) => {\n      if (!this._graphMap.has(vertex.id)) {\n        this._graphMap.set(vertex.id, vertex);\n      }\n    });\n\n    edges.forEach((edge) => {\n      const { u, v } = edge;\n      const uVertex = this.getVertex(u);\n      const vVertex = this.getVertex(v);\n\n      // 需要去掉重复的边\n      // @Todo 需要考虑有向无向\n      if (!this.getEdge(u, v)) {\n        const graphEdge = new _GraphEdge<V, E>({\n          u: uVertex,\n          v: vVertex,\n          origin: edge,\n        });\n        this.edges.push(edge);\n        uVertex.edges.push(graphEdge);\n        vVertex.edges.push(graphEdge);\n      } else {\n        const oldEdge = this.getEdge(u, v).origin;\n        const newEdge = changeEdge(edge, oldEdge);\n        this.updateEdge(newEdge);\n      }\n    });\n\n    this._graphReady = true;\n  }\n}\n\nexport default Graph;\n\n"]},"metadata":{},"sourceType":"module"}