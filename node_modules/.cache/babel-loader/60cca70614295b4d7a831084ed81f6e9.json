{"ast":null,"code":"/**\n * @file 树操作\n */\nimport { findIndex, find } from '../Utils/utils';\nconst VIRTUAL_ROOT_ID = Symbol('VIRTUAL_ROOT_ID'); // 内部 Tree 节点\n\nclass _TreeVertex {\n  /** 索引 id */\n\n  /** 节点类型 */\n\n  /** 当前节点层级 */\n\n  /** 父节点关联边 */\n\n  /** 子节点关联边列表 */\n\n  /** 源信息，与 Vertex[] 对应 */\n  constructor(config) {\n    this.id = void 0;\n    this.type = void 0;\n    this.level = void 0;\n    this.parentEdge = void 0;\n    this.childrenEdge = void 0;\n    this.origin = void 0;\n    this.id = config.id;\n    this.type = config.type;\n    this.level = config.level;\n    this.parentEdge = config.parentEdge;\n    this.childrenEdge = config.childrenEdge;\n    this.origin = config.origin;\n  }\n\n  getParent() {\n    return this.parentEdge.parent;\n  }\n\n  getChildrenOriginNode() {\n    return this.childrenEdge.map(childEdge => {\n      return childEdge.child.getOriginNode();\n    });\n  }\n\n  getOriginNode() {\n    return this.origin;\n  }\n\n  getLevel() {\n    return this.level;\n  }\n  /** 获取兄弟节点 */\n\n\n  getSibling() {\n    const sibling = this.parentEdge.parent.getChildrenOriginNode();\n    const index = findIndex(sibling, item => {\n      return item.id === this.id;\n    });\n    return {\n      pre: sibling.slice(0, index),\n      index,\n      next: sibling.slice(index + 1)\n    };\n  }\n\n  isVirtualRoot() {\n    return this.type === 'virtualRoot';\n  }\n\n} // 内部 Tree 边\n\n\nclass _TreeEdge {\n  /** 父节点索引 */\n\n  /** 另一端节点索引 */\n\n  /** 源信息 */\n  constructor(config) {\n    this.parent = void 0;\n    this.child = void 0;\n    this.origin = void 0;\n    this.parent = config.parent;\n    this.child = config.child;\n    this.origin = config.origin;\n  }\n\n} // 获取根节点\n\n\nfunction getRoot(vertexes, edges) {\n  const roots = [];\n\n  for (let i = 0; i < vertexes.length; i++) {\n    const id = vertexes[i].id; // 没有上游节点，说明为根节点\n\n    if (edges.filter(edge => edge.v === id).map(edge => edge.u).length === 0) {\n      roots.push(vertexes[i]);\n    }\n  }\n\n  return roots;\n}\n/**\n * 针对传入的 vertexes, edges 建立一颗索引树\n * CURD 操作时都有两种模式，存在索引树，或不存在\n * 注意：edge的 u，v，表示 v 是 u 的子节点，存在从属关系，无向图的树无法明确生成\n * @Todo 同树同层级子节点的顺序定义\n */\n\n\nclass Tree {\n  // 类的静态方法，是否为树\n  // 类的静态方法，是否为多树\n  // 类的静态方法，解析嵌套结构\n  // 外界传入的节点数据\n  // 外界传入的边数据\n  // 内部索引树\n  // 内部索引 Map\n  // 内部索引树是否已经建立，已建立，使用索引树加速查询\n  // bfs 内部队列\n  constructor(vertexes, edges) {\n    this.vertexes = [];\n    this.edges = [];\n    this._tree = null;\n    this._treeMap = new Map();\n    this._treeReady = false;\n    this._bfsQueue = void 0;\n\n    if (Tree.isTree(vertexes, edges) || Tree.isMulti(vertexes, edges)) {\n      this.vertexes = vertexes;\n      this.edges = edges;\n      this._tree = this._createTree();\n      return;\n    }\n\n    console.error('当前数据无法成树');\n  }\n  /**\n   * 创建链式树，为了多树场景，需要创建一个虚拟根节点\n   */\n\n\n  _createTree() {\n    this._treeReady = false;\n\n    this._treeMap.clear();\n\n    const virtualRoot = this._createVirtualRoot();\n\n    this._treeMap.set(virtualRoot.id, virtualRoot);\n\n    const root = this._getRoot(); // 虚拟根节点与真实根节点产生关联\n\n\n    root.forEach(node => {\n      const treeNode = new _TreeVertex({\n        id: node.id,\n        type: 'realNode',\n        level: virtualRoot.level + 1,\n        parentEdge: null,\n        childrenEdge: [],\n        origin: node\n      });\n\n      this._addChildren(virtualRoot, treeNode);\n\n      this.dfs(treeNode, parent => {\n        const children = this.getChildren(parent.id);\n        return children.map(child => {\n          return new _TreeVertex({\n            id: child.id,\n            type: 'realNode',\n            level: parent.level + 1,\n            parentEdge: null,\n            childrenEdge: [],\n            origin: child\n          });\n        });\n      }, (parent, child) => {\n        if (child) {\n          this._addChildren(parent, child);\n        }\n      });\n    });\n    this._treeReady = true;\n    return virtualRoot;\n  }\n\n  _addChildren(parentNode, childNode) {\n    const isExistChild = find(parentNode.childrenEdge.map(childEdge => {\n      return childEdge.child;\n    }), child => {\n      return child.id === childNode.id;\n    });\n\n    if (!isExistChild) {\n      const edge = this.getEdge(parentNode.origin.id, childNode.origin.id);\n      parentNode.childrenEdge.push(new _TreeEdge({\n        parent: parentNode,\n        child: childNode,\n        origin: edge\n      }));\n      childNode.parentEdge = new _TreeEdge({\n        parent: parentNode,\n        child: childNode,\n        origin: edge\n      });\n\n      this._treeMap.set(childNode.id, childNode);\n    }\n  }\n  /** 创建虚拟根节点 */\n\n\n  _createVirtualRoot() {\n    const id = VIRTUAL_ROOT_ID.toString();\n    return new _TreeVertex({\n      id,\n      parentEdge: null,\n      type: 'virtualRoot',\n      level: 0,\n      childrenEdge: [],\n      origin: {\n        id\n      }\n    });\n  }\n  /** dfs 遍历树 */\n\n\n  dfs(node, getChildren, beforeCallback = () => undefined, isDfs = () => true, callBackResult = null, afterCallback = () => undefined) {\n    if (!isDfs(node.id)) {\n      return;\n    }\n\n    const children = getChildren(node);\n\n    if (children && children.length) {\n      children.forEach(child => {\n        const result = beforeCallback(node, child, callBackResult);\n        this.dfs(child, getChildren, beforeCallback, isDfs, result, afterCallback);\n        afterCallback(node, child, result);\n      });\n    } else {\n      const result = beforeCallback(node, null, callBackResult);\n      afterCallback(node, null, result);\n    }\n  }\n  /** bfs 遍历树 */\n\n\n  bfs(node, getChildren, callback, isBfs = () => true) {\n    if (!isBfs(node.id)) {\n      return;\n    }\n\n    getChildren(node).forEach(child => {\n      callback(node, child);\n    });\n  }\n\n  _getRoot(isVirtual) {\n    if (this._treeReady) {\n      // 返回虚拟根节点\n      if (isVirtual) {\n        return [this._tree.getOriginNode()];\n      }\n\n      return this._tree.getChildrenOriginNode();\n    } else {\n      return getRoot(this.vertexes, this.edges);\n    }\n  }\n  /** 得到树的唯一根节点 */\n\n\n  getSingleRoot() {\n    const roots = this._getRoot();\n\n    return roots[0];\n  }\n  /** 得到树的多重根节点 */\n\n\n  getMultiRoot() {\n    return this._getRoot();\n  }\n  /** 获取当前节点的父节点 */\n\n\n  getParent(id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        const parent = this._treeMap.get(id).getParent(); // 如果父元素是虚拟的根元素\n\n\n        if (parent.isVirtualRoot()) {\n          return null;\n        }\n\n        return parent.getOriginNode();\n      }\n\n      return null;\n    } else {\n      const edgeIdList = this.edges.filter(edge => edge.v === id).map(edge => edge.u);\n\n      if (edgeIdList.length === 0) {\n        return null;\n      }\n\n      return find(this.vertexes, vertex => {\n        return edgeIdList.indexOf(vertex.id) !== -1;\n      });\n    }\n  }\n  /** 得到当前边 */\n\n\n  getEdge(parentId, childId) {\n    const edges = this.edges.filter(edge => {\n      return edge.u === parentId && edge.v === childId;\n    });\n    return edges.length === 0 ? null : edges[0];\n  }\n  /** 得到当前节点 */\n\n\n  getNode(id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getOriginNode();\n      }\n\n      return null;\n    } else {\n      const vertex = this.vertexes.filter(vertex => {\n        return vertex.id === id;\n      });\n      return vertex.length === 0 ? null : vertex[0];\n    }\n  }\n\n  getSibling(id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getSibling();\n      }\n    }\n    /** @todo 有点懒得写 */\n\n\n    return {\n      pre: [],\n      next: [],\n      index: -1\n    };\n  }\n  /** 得到子节点 */\n\n\n  getChildren(id) {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getChildrenOriginNode();\n      }\n\n      return [];\n    } else {\n      if (id === VIRTUAL_ROOT_ID.toString()) {\n        return this._getRoot();\n      }\n\n      const edgeIdList = this.edges.filter(edge => edge.u === id).map(edge => edge.v);\n      return this.vertexes.filter(vertex => {\n        return edgeIdList.indexOf(vertex.id) !== -1;\n      });\n    }\n  }\n  /** 获取节点层级 */\n\n\n  getLevel(id) {\n    if (this._treeMap.has(id)) {\n      return this._treeMap.get(id).getLevel();\n    }\n    /** @Todo 注意异常处理 */\n\n\n    return null;\n  }\n  /** 得到唯一树 */\n\n\n  getSingleTree(id, depth = -1) {\n    if (id && !this._treeMap.has(id)) {\n      return null;\n    }\n\n    return this.getTree(id, depth)[0];\n  }\n  /** 得到树，子树，可定义多少深度 */\n\n\n  getTree(id, depth = -1) {\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    } // 如果没有 id 则默认为根节点\n\n\n    const nodes = id ? [{ ...this._treeMap.get(id).getOriginNode(),\n      children: [],\n      _origin: this._treeMap.get(id).getOriginNode()\n    }] : this._getRoot().map(root => {\n      return { ...root,\n        children: [],\n        _origin: root\n      };\n    });\n    nodes.forEach(node => {\n      this.dfs(node, parent => {\n        const children = this.getChildren(parent.id);\n        return children.map(child => {\n          return { ...child,\n            children: [],\n            _origin: child\n          };\n        });\n      }, (parent, child) => {\n        if (child) {\n          parent.children.push(child);\n        }\n      }, id => {\n        const currentLevel = this._treeMap.get(id).getLevel();\n\n        const level = this._treeMap.get(node.id).getLevel();\n\n        if (depth === -1 || currentLevel - level < depth - 1) {\n          return true;\n        }\n\n        return false;\n      });\n    });\n    return nodes;\n  }\n  /** 使用 BFS 获取子树 */\n\n\n  _getTreeByBFS(id, depth = -1) {\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    } // 如果没有 id 则默认为根节点\n\n\n    const nodes = id ? [{ ...this._treeMap.get(id).getOriginNode(),\n      children: [],\n      _origin: this._treeMap.get(id).getOriginNode()\n    }] : this._getRoot().map(root => {\n      return { ...root,\n        children: [],\n        _origin: root\n      };\n    }); // 深拷贝\n\n    this._bfsQueue = [...nodes];\n\n    while (this._bfsQueue.length !== 0) {\n      const node = this._bfsQueue.shift();\n\n      this.bfs(node, parent => {\n        return this.getChildren(parent.id).map(child => {\n          return { ...child,\n            children: [],\n            _origin: child\n          };\n        });\n      }, (parent, child) => {\n        parent.children.push(child);\n\n        this._bfsQueue.push(child);\n      }, id => {\n        const currentLevel = this._treeMap.get(id).getLevel();\n\n        const level = this._treeMap.get(nodes[0].id).getLevel();\n\n        if (depth === -1 || currentLevel - level < depth - 1) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return nodes;\n  }\n  /**\n   * 获取祖孙节点的路径\n   */\n\n\n  getPath(ancestorId, childId) {\n    const ancestor = this.getNode(ancestorId);\n    if (!ancestor) return [];\n    let path = [];\n    this.dfs(ancestor, p => {\n      return this.getChildren(p.id);\n    }, (p, child, pre) => {\n      if (child) {\n        if (childId === child.id) {\n          path = [...pre, child];\n        }\n\n        return [...pre, child];\n      }\n\n      return pre;\n    }, () => {\n      return path.length === 0;\n    }, [ancestor]);\n    return path;\n  }\n  /**\n   * 获取两节点的最近公共祖先，\n   * 这里先采用在线的算法，离线适用于大量查询场景，暂时还没有\n   */\n\n\n  getNodeRelation(node1, node2) {\n    const root = this._getRoot(true)[0];\n\n    const path1 = this.getPath(root.id, node1);\n    const path2 = this.getPath(root.id, node2);\n    const commonRoot = path1.reduce((pre, item) => {\n      const node = find(path2, i => {\n        return item.id === i.id;\n      });\n\n      if (node) {\n        return node;\n      }\n\n      return pre;\n    }, null);\n\n    if (commonRoot.id === VIRTUAL_ROOT_ID.toString()) {\n      return null;\n    }\n\n    return commonRoot;\n  }\n\n  _translate(vertex) {\n    const vertexResult = [vertex._origin];\n    const edgeResult = [];\n    this.dfs(vertex, parent => {\n      parent.children.forEach(child => {\n        vertexResult.push(child._origin);\n        /** @Todo 这会造成边信息丢失，目前只能用 updateEdge 来补 */\n\n        edgeResult.push({\n          u: parent.id,\n          v: child.id\n        });\n      });\n      return parent.children;\n    }, () => {});\n    return {\n      vertexes: vertexResult,\n      edges: edgeResult\n    };\n  }\n  /**\n   * 添加点，自动增加一条边\n   * 不存在 parentId，即新开一棵树，挂载到虚拟节点上\n   */\n\n\n  addVertex(vertex, parentId = VIRTUAL_ROOT_ID.toString()) {\n    if (!this._treeMap.has(parentId)) {\n      return;\n    }\n\n    this.edges = parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : [...this.edges, {\n      u: parentId,\n      v: vertex.id\n    }];\n    this.vertexes = [...this.vertexes, vertex];\n\n    const parent = this._treeMap.get(parentId);\n\n    const newTreeNode = new _TreeVertex({\n      id: vertex.id,\n      parentEdge: null,\n      type: 'realNode',\n      level: parent.level + 1,\n      childrenEdge: [],\n      origin: vertex\n    });\n\n    this._addChildren(parent, newTreeNode);\n  }\n  /**\n   * 添加子树，自动增加一条边\n   * 不存在 parentId，即新开一棵树，挂载到虚拟节点上\n   */\n\n\n  addChildTree(vertex, parentId = VIRTUAL_ROOT_ID.toString()) {\n    if (!this._treeMap.has(parentId)) {\n      return;\n    } // 虚拟节点与真实节点的边不加入 this.edges\n\n\n    this.edges = parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : [...this.edges, {\n      u: parentId,\n      v: vertex.id\n    }];\n\n    const {\n      vertexes,\n      edges\n    } = this._translate(vertex);\n\n    this.vertexes = [...this.vertexes, ...vertexes];\n    this.edges = [...this.edges, ...edges];\n    this._treeReady = false;\n\n    const parent = this._treeMap.get(parentId);\n\n    this.dfs(parent, parent => {\n      const children = this.getChildren(parent.id);\n      return children.map(child => {\n        return new _TreeVertex({\n          id: child.id,\n          parentEdge: null,\n          type: 'realNode',\n          level: parent.level + 1,\n          childrenEdge: [],\n          origin: child\n        });\n      });\n    }, (parent, child) => {\n      if (child) {\n        this._addChildren(parent, child);\n      }\n    });\n    this._treeReady = true;\n  }\n  /**\n   * 删除节点及其所有下游节点\n   * 返回删除的子树\n   */\n\n\n  deleteVertex(vertexId) {\n    if (!this._treeMap.has(vertexId)) {\n      return null;\n    }\n\n    const childTree = this.getSingleTree(vertexId);\n\n    const parent = this._treeMap.get(vertexId).getParent();\n\n    const {\n      vertexes,\n      edges\n    } = this._translate(childTree);\n\n    this.vertexes = this.vertexes.filter(vertex => {\n      return find(vertexes, item => {\n        return item.id === vertex.id;\n      }) ? false : true;\n    });\n    this.edges = this.edges.filter(edge => {\n      return find(edges, e => {\n        return edge.u === e.u && edge.v === e.v || edge.u === parent.id && edge.v === vertexId;\n      }) ? false : true;\n    }); // 清除 _tree 与 _treeMap\n\n    vertexes.forEach(vertex => {\n      this._treeMap.delete(vertex.id);\n    });\n    parent.childrenEdge = parent.childrenEdge.filter(childEdge => {\n      return childEdge.child.id !== vertexId;\n    });\n    return childTree;\n  }\n  /**\n   * 更新节点\n   */\n\n\n  updateVertex(vertex) {\n    this.vertexes = this.vertexes.map(item => {\n      if (item.id === vertex.id) {\n        return vertex;\n      }\n\n      return item;\n    });\n\n    if (this._treeMap.has(vertex.id)) {\n      // 修改引用\n      const oldVertex = this._treeMap.get(vertex.id);\n\n      oldVertex.origin = vertex;\n    }\n  }\n  /**\n   * 更新边\n   */\n\n\n  updateEdge(edge) {\n    this.edges = this.edges.map(e => {\n      if (e.u === edge.u && e.v === edge.v) {\n        return edge;\n      }\n\n      return e;\n    });\n  }\n  /**\n   * 删除边，同时删除与关联的下游节点\n   * 返回下游子树\n   */\n\n\n  deleteEdge(u, v) {\n    if (!this._treeMap.has(u) || !this._treeMap.has(v)) {\n      return null;\n    }\n\n    this.edges = this.edges.filter(edge => {\n      return edge.u !== u && edge.v !== edge.v;\n    });\n    return this.deleteVertex(v);\n  }\n\n  getVertexes() {\n    return this.vertexes;\n  }\n\n  getEdges() {\n    return this.edges;\n  }\n  /** 获取当前节点所有的叶子节点 */\n\n\n  getLeafVertexes(id, depth = -1) {\n    const {\n      vertexes\n    } = this._translate(this._getTreeByBFS(id, depth)[0]);\n\n    return vertexes.filter(node => {\n      return this.getChildren(node.id).length === 0;\n    });\n  }\n\n} // 判断是否为树\n\n\nTree.isTree = void 0;\nTree.isMulti = void 0;\nTree.parse = void 0;\n\nTree.isTree = (vertexes, edges) => {\n  const visitedList = [];\n\n  function dfs(node) {\n    if (visitedList.indexOf(node.id) !== -1) {\n      return false;\n    }\n\n    visitedList.push(node.id);\n    const edgeIdList = edges.filter(edge => edge.u === node.id).map(edge => edge.v);\n    const children = vertexes.filter(vertex => {\n      return edgeIdList.indexOf(vertex.id) !== -1;\n    });\n\n    for (let i = 0; i < children.length; i++) {\n      if (!dfs(children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // 树必然 n 个节点，n - 1 条边\n\n\n  if (vertexes.length !== edges.length + 1) {\n    return false;\n  } // 不存在环\n\n\n  const roots = getRoot(vertexes, edges);\n\n  if (roots.length === 1) {\n    return dfs(roots[0]);\n  }\n\n  return false;\n}; // 判断是否为多树，寻找出多个根节点，用虚拟根节点连接，能形成一颗树\n\n\nTree.isMulti = (vertexes, edges) => {\n  const roots = getRoot(vertexes, edges);\n\n  if (roots.length <= 1) {\n    return false;\n  }\n\n  const virtualRootId = VIRTUAL_ROOT_ID.toString();\n  return Tree.isTree([...vertexes, {\n    id: virtualRootId\n  }], [...edges, ...roots.map(node => {\n    return {\n      u: virtualRootId,\n      v: node.id\n    };\n  })]);\n};\n/** 解析嵌套的树结构 */\n\n\nTree.parse = (tree, getId, getChildren, getEdge) => {\n  const getIdHandler = getId ? getId : node => {\n    return node.id;\n  };\n  const getChildrenHandler = getChildren ? getChildren : node => {\n    return node.children;\n  };\n  const vertexes = [];\n  const edges = [];\n  const visitedList = [];\n\n  function dfs(node) {\n    const id = getIdHandler(node);\n    node.id = id;\n\n    if (visitedList.indexOf(id) !== -1) {\n      console.error('存在环！');\n      return false;\n    }\n\n    visitedList.push(id);\n    vertexes.push(node);\n    const children = getChildrenHandler(node);\n\n    if (children && children.length) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const childId = getIdHandler(child);\n        child.id = childId;\n        const edge = getEdge ? getEdge(node, child) : {\n          u: id,\n          v: childId\n        };\n        edges.push(edge);\n        dfs(child);\n      }\n    }\n  }\n\n  for (let i = 0; i < tree.length; i++) {\n    dfs(tree[i]);\n  }\n\n  return {\n    vertexes,\n    edges\n  };\n};\n\nexport default Tree;","map":{"version":3,"sources":["/Users/majy/work/bici/code/editor-demo/src/regraph/BaseGraph/Tree.ts"],"names":["findIndex","find","VIRTUAL_ROOT_ID","Symbol","_TreeVertex","constructor","config","id","type","level","parentEdge","childrenEdge","origin","getParent","parent","getChildrenOriginNode","map","childEdge","child","getOriginNode","getLevel","getSibling","sibling","index","item","pre","slice","next","isVirtualRoot","_TreeEdge","getRoot","vertexes","edges","roots","i","length","filter","edge","v","u","push","Tree","_tree","_treeMap","Map","_treeReady","_bfsQueue","isTree","isMulti","_createTree","console","error","clear","virtualRoot","_createVirtualRoot","set","root","_getRoot","forEach","node","treeNode","_addChildren","dfs","children","getChildren","parentNode","childNode","isExistChild","getEdge","toString","beforeCallback","undefined","isDfs","callBackResult","afterCallback","result","bfs","callback","isBfs","isVirtual","getSingleRoot","getMultiRoot","has","get","edgeIdList","vertex","indexOf","parentId","childId","getNode","getSingleTree","depth","getTree","nodes","_origin","currentLevel","_getTreeByBFS","shift","getPath","ancestorId","ancestor","path","p","getNodeRelation","node1","node2","path1","path2","commonRoot","reduce","_translate","vertexResult","edgeResult","addVertex","newTreeNode","addChildTree","deleteVertex","vertexId","childTree","e","delete","updateVertex","oldVertex","updateEdge","deleteEdge","getVertexes","getEdges","getLeafVertexes","parse","visitedList","virtualRootId","tree","getId","getIdHandler","getChildrenHandler"],"mappings":"AAAA;;;AAKA,SAASA,SAAT,EAAoBC,IAApB,QAAgC,gBAAhC;AAGA,MAAMC,eAAe,GAAGC,MAAM,CAAC,iBAAD,CAA9B,C,CAEA;;AACA,MAAMC,WAAN,CAAwB;AACtB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AAGAC,EAAAA,WAAW,CAACC,MAAD,EAOR;AAAA,SAnBHC,EAmBG;AAAA,SAjBHC,IAiBG;AAAA,SAfHC,KAeG;AAAA,SAbHC,UAaG;AAAA,SAXHC,YAWG;AAAA,SATHC,MASG;AACD,SAAKL,EAAL,GAAUD,MAAM,CAACC,EAAjB;AACA,SAAKC,IAAL,GAAYF,MAAM,CAACE,IAAnB;AACA,SAAKC,KAAL,GAAaH,MAAM,CAACG,KAApB;AACA,SAAKC,UAAL,GAAkBJ,MAAM,CAACI,UAAzB;AACA,SAAKC,YAAL,GAAoBL,MAAM,CAACK,YAA3B;AACA,SAAKC,MAAL,GAAcN,MAAM,CAACM,MAArB;AACD;;AAEDC,EAAAA,SAAS,GAAsB;AAC7B,WAAO,KAAKH,UAAL,CAAgBI,MAAvB;AACD;;AAEDC,EAAAA,qBAAqB,GAAQ;AAC3B,WAAO,KAAKJ,YAAL,CAAkBK,GAAlB,CAAsBC,SAAS,IAAI;AACxC,aAAOA,SAAS,CAACC,KAAV,CAAgBC,aAAhB,EAAP;AACD,KAFM,CAAP;AAGD;;AAEDA,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKP,MAAZ;AACD;;AAEDQ,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKX,KAAZ;AACD;AAED;;;AACAY,EAAAA,UAAU,GAAG;AACX,UAAMC,OAAO,GAAG,KAAKZ,UAAL,CAAgBI,MAAhB,CAAuBC,qBAAvB,EAAhB;AACA,UAAMQ,KAAK,GAAGvB,SAAS,CAACsB,OAAD,EAAWE,IAAD,IAAe;AAC9C,aAAOA,IAAI,CAACjB,EAAL,KAAY,KAAKA,EAAxB;AACD,KAFsB,CAAvB;AAGA,WAAO;AACLkB,MAAAA,GAAG,EAAEH,OAAO,CAACI,KAAR,CAAc,CAAd,EAAiBH,KAAjB,CADA;AAELA,MAAAA,KAFK;AAGLI,MAAAA,IAAI,EAAEL,OAAO,CAACI,KAAR,CAAcH,KAAK,GAAG,CAAtB;AAHD,KAAP;AAKD;;AAEDK,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKpB,IAAL,KAAc,aAArB;AACD;;AA/DqB,C,CAkExB;;;AACA,MAAMqB,SAAN,CAAsB;AACpB;;AAEA;;AAEA;AAGAxB,EAAAA,WAAW,CAACC,MAAD,EAA6E;AAAA,SANxFQ,MAMwF;AAAA,SAJxFI,KAIwF;AAAA,SAFxFN,MAEwF;AACtF,SAAKE,MAAL,GAAcR,MAAM,CAACQ,MAArB;AACA,SAAKI,KAAL,GAAaZ,MAAM,CAACY,KAApB;AACA,SAAKN,MAAL,GAAcN,MAAM,CAACM,MAArB;AACD;;AAZmB,C,CAetB;;;AACA,SAASkB,OAAT,CACEC,QADF,EAEEC,KAFF,EAGoB;AAClB,QAAMC,KAAuB,GAAG,EAAhC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACI,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAM3B,EAAE,GAAGwB,QAAQ,CAACG,CAAD,CAAR,CAAY3B,EAAvB,CADwC,CAExC;;AACA,QAAIyB,KAAK,CAACI,MAAN,CAAaC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAW/B,EAAhC,EAAoCS,GAApC,CAAwCqB,IAAI,IAAIA,IAAI,CAACE,CAArD,EAAwDJ,MAAxD,KAAmE,CAAvE,EAA0E;AACxEF,MAAAA,KAAK,CAACO,IAAN,CAAWT,QAAQ,CAACG,CAAD,CAAnB;AACD;AACF;;AACD,SAAOD,KAAP;AACD;AAED;;;;;;;;AAMA,MAAMQ,IAAN,CAAqD;AACnD;AAEA;AAEA;AAQA;AAEA;AAGA;AAEA;AAEA;AAEA;AAGApC,EAAAA,WAAW,CAAC0B,QAAD,EAA6BC,KAA7B,EAAoD;AAAA,SAbvDD,QAauD,GAb1B,EAa0B;AAAA,SAXvDC,KAWuD,GAX/B,EAW+B;AAAA,SARvDU,KAQuD,GAR5B,IAQ4B;AAAA,SANvDC,QAMuD,GANZ,IAAIC,GAAJ,EAMY;AAAA,SAJvDC,UAIuD,GAJjC,KAIiC;AAAA,SAFvDC,SAEuD;;AAC7D,QAAIL,IAAI,CAACM,MAAL,CAAYhB,QAAZ,EAAsBC,KAAtB,KAAgCS,IAAI,CAACO,OAAL,CAAajB,QAAb,EAAuBC,KAAvB,CAApC,EAAmE;AACjE,WAAKD,QAAL,GAAgBA,QAAhB;AACA,WAAKC,KAAL,GAAaA,KAAb;AACA,WAAKU,KAAL,GAAa,KAAKO,WAAL,EAAb;AACA;AACD;;AACDC,IAAAA,OAAO,CAACC,KAAR,CAAc,UAAd;AACD;AAED;;;;;AAGAF,EAAAA,WAAW,GAAG;AACZ,SAAKJ,UAAL,GAAkB,KAAlB;;AACA,SAAKF,QAAL,CAAcS,KAAd;;AAEA,UAAMC,WAAW,GAAG,KAAKC,kBAAL,EAApB;;AACA,SAAKX,QAAL,CAAcY,GAAd,CAAkBF,WAAW,CAAC9C,EAA9B,EAAkC8C,WAAlC;;AACA,UAAMG,IAAI,GAAG,KAAKC,QAAL,EAAb,CANY,CAQZ;;;AACAD,IAAAA,IAAI,CAACE,OAAL,CAAaC,IAAI,IAAI;AACnB,YAAMC,QAA2B,GAAG,IAAIxD,WAAJ,CAAgB;AAClDG,QAAAA,EAAE,EAAEoD,IAAI,CAACpD,EADyC;AAElDC,QAAAA,IAAI,EAAE,UAF4C;AAGlDC,QAAAA,KAAK,EAAE4C,WAAW,CAAC5C,KAAZ,GAAoB,CAHuB;AAIlDC,QAAAA,UAAU,EAAE,IAJsC;AAKlDC,QAAAA,YAAY,EAAE,EALoC;AAMlDC,QAAAA,MAAM,EAAE+C;AAN0C,OAAhB,CAApC;;AAQA,WAAKE,YAAL,CAAkBR,WAAlB,EAA+BO,QAA/B;;AACA,WAAKE,GAAL,CACEF,QADF,EAEE9C,MAAM,IAAI;AACR,cAAMiD,QAAQ,GAAG,KAAKC,WAAL,CAAiBlD,MAAM,CAACP,EAAxB,CAAjB;AACA,eAAOwD,QAAQ,CAAC/C,GAAT,CAAaE,KAAK,IAAI;AAC3B,iBAAO,IAAId,WAAJ,CAAgB;AACrBG,YAAAA,EAAE,EAAEW,KAAK,CAACX,EADW;AAErBC,YAAAA,IAAI,EAAE,UAFe;AAGrBC,YAAAA,KAAK,EAAEK,MAAM,CAACL,KAAP,GAAe,CAHD;AAIrBC,YAAAA,UAAU,EAAE,IAJS;AAKrBC,YAAAA,YAAY,EAAE,EALO;AAMrBC,YAAAA,MAAM,EAAEM;AANa,WAAhB,CAAP;AAQD,SATM,CAAP;AAUD,OAdH,EAeE,CAACJ,MAAD,EAASI,KAAT,KAAmB;AACjB,YAAIA,KAAJ,EAAW;AACT,eAAK2C,YAAL,CAAkB/C,MAAlB,EAA0BI,KAA1B;AACD;AACF,OAnBH;AAqBD,KA/BD;AAiCA,SAAK2B,UAAL,GAAkB,IAAlB;AAEA,WAAOQ,WAAP;AACD;;AAEDQ,EAAAA,YAAY,CAACI,UAAD,EAAgCC,SAAhC,EAA8D;AACxE,UAAMC,YAAY,GAAGlE,IAAI,CACvBgE,UAAU,CAACtD,YAAX,CAAwBK,GAAxB,CAA4BC,SAAS,IAAI;AACvC,aAAOA,SAAS,CAACC,KAAjB;AACD,KAFD,CADuB,EAIvBA,KAAK,IAAI;AACP,aAAOA,KAAK,CAACX,EAAN,KAAa2D,SAAS,CAAC3D,EAA9B;AACD,KANsB,CAAzB;;AAQA,QAAI,CAAC4D,YAAL,EAAmB;AACjB,YAAM9B,IAAI,GAAG,KAAK+B,OAAL,CAAaH,UAAU,CAACrD,MAAX,CAAkBL,EAA/B,EAAmC2D,SAAS,CAACtD,MAAV,CAAiBL,EAApD,CAAb;AACA0D,MAAAA,UAAU,CAACtD,YAAX,CAAwB6B,IAAxB,CACE,IAAIX,SAAJ,CAAc;AACZf,QAAAA,MAAM,EAAEmD,UADI;AAEZ/C,QAAAA,KAAK,EAAEgD,SAFK;AAGZtD,QAAAA,MAAM,EAAEyB;AAHI,OAAd,CADF;AAOA6B,MAAAA,SAAS,CAACxD,UAAV,GAAuB,IAAImB,SAAJ,CAAc;AACnCf,QAAAA,MAAM,EAAEmD,UAD2B;AAEnC/C,QAAAA,KAAK,EAAEgD,SAF4B;AAGnCtD,QAAAA,MAAM,EAAEyB;AAH2B,OAAd,CAAvB;;AAKA,WAAKM,QAAL,CAAcY,GAAd,CAAkBW,SAAS,CAAC3D,EAA5B,EAAgC2D,SAAhC;AACD;AACF;AAED;;;AACAZ,EAAAA,kBAAkB,GAAsB;AACtC,UAAM/C,EAAE,GAAGL,eAAe,CAACmE,QAAhB,EAAX;AACA,WAAO,IAAIjE,WAAJ,CAAgB;AACrBG,MAAAA,EADqB;AAErBG,MAAAA,UAAU,EAAE,IAFS;AAGrBF,MAAAA,IAAI,EAAE,aAHe;AAIrBC,MAAAA,KAAK,EAAE,CAJc;AAKrBE,MAAAA,YAAY,EAAE,EALO;AAMrBC,MAAAA,MAAM,EAAE;AACNL,QAAAA;AADM;AANa,KAAhB,CAAP;AAUD;AAED;;;AACAuD,EAAAA,GAAG,CACDH,IADC,EAEDK,WAFC,EAGDM,cAAgE,GAAG,MAAMC,SAHxE,EAIDC,KAA8B,GAAG,MAAM,IAJtC,EAKDC,cAAiB,GAAG,IALnB,EAMDC,aAAkE,GAAG,MAAMH,SAN1E,EAOD;AACA,QAAI,CAACC,KAAK,CAACb,IAAI,CAACpD,EAAN,CAAV,EAAqB;AACnB;AACD;;AACD,UAAMwD,QAAQ,GAAGC,WAAW,CAACL,IAAD,CAA5B;;AACA,QAAII,QAAQ,IAAIA,QAAQ,CAAC5B,MAAzB,EAAiC;AAC/B4B,MAAAA,QAAQ,CAACL,OAAT,CAAiBxC,KAAK,IAAI;AACxB,cAAMyD,MAAM,GAAGL,cAAc,CAACX,IAAD,EAAOzC,KAAP,EAAcuD,cAAd,CAA7B;AACA,aAAKX,GAAL,CAAS5C,KAAT,EAAgB8C,WAAhB,EAA6BM,cAA7B,EAA6CE,KAA7C,EAAoDG,MAApD,EAA4DD,aAA5D;AACAA,QAAAA,aAAa,CAACf,IAAD,EAAOzC,KAAP,EAAcyD,MAAd,CAAb;AACD,OAJD;AAKD,KAND,MAMO;AACL,YAAMA,MAAM,GAAGL,cAAc,CAACX,IAAD,EAAO,IAAP,EAAac,cAAb,CAA7B;AACAC,MAAAA,aAAa,CAACf,IAAD,EAAO,IAAP,EAAagB,MAAb,CAAb;AACD;AACF;AAED;;;AACAC,EAAAA,GAAG,CACDjB,IADC,EAEDK,WAFC,EAGDa,QAHC,EAIDC,KAA8B,GAAG,MAAM,IAJtC,EAKD;AACA,QAAI,CAACA,KAAK,CAACnB,IAAI,CAACpD,EAAN,CAAV,EAAqB;AACnB;AACD;;AACDyD,IAAAA,WAAW,CAACL,IAAD,CAAX,CAAkBD,OAAlB,CAA0BxC,KAAK,IAAI;AACjC2D,MAAAA,QAAQ,CAAClB,IAAD,EAAOzC,KAAP,CAAR;AACD,KAFD;AAGD;;AAEDuC,EAAAA,QAAQ,CAACsB,SAAD,EAA2B;AACjC,QAAI,KAAKlC,UAAT,EAAqB;AACnB;AACA,UAAIkC,SAAJ,EAAe;AACb,eAAO,CAAC,KAAKrC,KAAL,CAAWvB,aAAX,EAAD,CAAP;AACD;;AACD,aAAO,KAAKuB,KAAL,CAAW3B,qBAAX,EAAP;AACD,KAND,MAMO;AACL,aAAOe,OAAO,CAAO,KAAKC,QAAZ,EAAsB,KAAKC,KAA3B,CAAd;AACD;AACF;AAED;;;AACAgD,EAAAA,aAAa,GAAM;AACjB,UAAM/C,KAAK,GAAG,KAAKwB,QAAL,EAAd;;AACA,WAAOxB,KAAK,CAAC,CAAD,CAAZ;AACD;AAED;;;AACAgD,EAAAA,YAAY,GAAQ;AAClB,WAAO,KAAKxB,QAAL,EAAP;AACD;AAED;;;AACA5C,EAAAA,SAAS,CAACN,EAAD,EAAgB;AACvB,QAAI,KAAKsC,UAAT,EAAqB;AACnB,UAAI,KAAKF,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAJ,EAA2B;AACzB,cAAMO,MAAM,GAAG,KAAK6B,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBM,SAAtB,EAAf,CADyB,CAEzB;;;AACA,YAAIC,MAAM,CAACc,aAAP,EAAJ,EAA4B;AAC1B,iBAAO,IAAP;AACD;;AACD,eAAOd,MAAM,CAACK,aAAP,EAAP;AACD;;AACD,aAAO,IAAP;AACD,KAVD,MAUO;AACL,YAAMiE,UAAU,GAAG,KAAKpD,KAAL,CAAWI,MAAX,CAAkBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAW/B,EAArC,EAAyCS,GAAzC,CAA6CqB,IAAI,IAAIA,IAAI,CAACE,CAA1D,CAAnB;;AACA,UAAI6C,UAAU,CAACjD,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,eAAO,IAAP;AACD;;AACD,aAAOlC,IAAI,CAAC,KAAK8B,QAAN,EAAgBsD,MAAM,IAAI;AACnC,eAAOD,UAAU,CAACE,OAAX,CAAmBD,MAAM,CAAC9E,EAA1B,MAAkC,CAAC,CAA1C;AACD,OAFU,CAAX;AAGD;AACF;AAED;;;AACA6D,EAAAA,OAAO,CAACmB,QAAD,EAAmBC,OAAnB,EAAuC;AAC5C,UAAMxD,KAAK,GAAG,KAAKA,KAAL,CAAWI,MAAX,CAAkBC,IAAI,IAAI;AACtC,aAAOA,IAAI,CAACE,CAAL,KAAWgD,QAAX,IAAuBlD,IAAI,CAACC,CAAL,KAAWkD,OAAzC;AACD,KAFa,CAAd;AAGA,WAAOxD,KAAK,CAACG,MAAN,KAAiB,CAAjB,GAAqB,IAArB,GAA4BH,KAAK,CAAC,CAAD,CAAxC;AACD;AAED;;;AACAyD,EAAAA,OAAO,CAAClF,EAAD,EAAgB;AACrB,QAAI,KAAKsC,UAAT,EAAqB;AACnB,UAAI,KAAKF,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAJ,EAA2B;AACzB,eAAO,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBY,aAAtB,EAAP;AACD;;AACD,aAAO,IAAP;AACD,KALD,MAKO;AACL,YAAMkE,MAAM,GAAG,KAAKtD,QAAL,CAAcK,MAAd,CAAqBiD,MAAM,IAAI;AAC5C,eAAOA,MAAM,CAAC9E,EAAP,KAAcA,EAArB;AACD,OAFc,CAAf;AAGA,aAAO8E,MAAM,CAAClD,MAAP,KAAkB,CAAlB,GAAsB,IAAtB,GAA6BkD,MAAM,CAAC,CAAD,CAA1C;AACD;AACF;;AAEDhE,EAAAA,UAAU,CACRd,EADQ,EAMR;AACA,QAAI,KAAKsC,UAAT,EAAqB;AACnB,UAAI,KAAKF,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAJ,EAA2B;AACzB,eAAO,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBc,UAAtB,EAAP;AACD;AACF;AACD;;;AACA,WAAO;AACLI,MAAAA,GAAG,EAAE,EADA;AAELE,MAAAA,IAAI,EAAE,EAFD;AAGLJ,MAAAA,KAAK,EAAE,CAAC;AAHH,KAAP;AAKD;AAED;;;AACAyC,EAAAA,WAAW,CAACzD,EAAD,EAAkB;AAC3B,QAAI,KAAKsC,UAAT,EAAqB;AACnB,UAAI,KAAKF,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAJ,EAA2B;AACzB,eAAO,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBQ,qBAAtB,EAAP;AACD;;AACD,aAAO,EAAP;AACD,KALD,MAKO;AACL,UAAIR,EAAE,KAAKL,eAAe,CAACmE,QAAhB,EAAX,EAAuC;AACrC,eAAO,KAAKZ,QAAL,EAAP;AACD;;AACD,YAAM2B,UAAU,GAAG,KAAKpD,KAAL,CAAWI,MAAX,CAAkBC,IAAI,IAAIA,IAAI,CAACE,CAAL,KAAWhC,EAArC,EAAyCS,GAAzC,CAA6CqB,IAAI,IAAIA,IAAI,CAACC,CAA1D,CAAnB;AACA,aAAO,KAAKP,QAAL,CAAcK,MAAd,CAAqBiD,MAAM,IAAI;AACpC,eAAOD,UAAU,CAACE,OAAX,CAAmBD,MAAM,CAAC9E,EAA1B,MAAkC,CAAC,CAA1C;AACD,OAFM,CAAP;AAGD;AACF;AAED;;;AACAa,EAAAA,QAAQ,CAACb,EAAD,EAAqB;AAC3B,QAAI,KAAKoC,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAJ,EAA2B;AACzB,aAAO,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBa,QAAtB,EAAP;AACD;AACD;;;AACA,WAAO,IAAP;AACD;AAED;;;AACAsE,EAAAA,aAAa,CAACnF,EAAD,EAAcoF,KAAK,GAAG,CAAC,CAAvB,EAA2C;AACtD,QAAIpF,EAAE,IAAI,CAAC,KAAKoC,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAX,EAAkC;AAChC,aAAO,IAAP;AACD;;AACD,WAAO,KAAKqF,OAAL,CAAarF,EAAb,EAAiBoF,KAAjB,EAAwB,CAAxB,CAAP;AACD;AAED;;;AACAC,EAAAA,OAAO,CAACrF,EAAD,EAAcoF,KAAK,GAAG,CAAC,CAAvB,EAA6C;AAClD,QAAIpF,EAAE,IAAI,CAAC,KAAKoC,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAX,EAAkC;AAChC,aAAO,EAAP;AACD,KAHiD,CAIlD;;;AACA,UAAMsF,KAAK,GAAGtF,EAAE,GACZ,CACE,EACE,GAAI,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBY,aAAtB,EADN;AAEE4C,MAAAA,QAAQ,EAAE,EAFZ;AAGE+B,MAAAA,OAAO,EAAE,KAAKnD,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBY,aAAtB;AAHX,KADF,CADY,GAQZ,KAAKsC,QAAL,GAAgBzC,GAAhB,CAAoBwC,IAAI,IAAI;AAC1B,aAAO,EACL,GAAIA,IADC;AAELO,QAAAA,QAAQ,EAAE,EAFL;AAGL+B,QAAAA,OAAO,EAAEtC;AAHJ,OAAP;AAKD,KAND,CARJ;AAeAqC,IAAAA,KAAK,CAACnC,OAAN,CAAcC,IAAI,IAAI;AACpB,WAAKG,GAAL,CACEH,IADF,EAEE7C,MAAM,IAAI;AACR,cAAMiD,QAAQ,GAAG,KAAKC,WAAL,CAAiBlD,MAAM,CAACP,EAAxB,CAAjB;AACA,eAAOwD,QAAQ,CAAC/C,GAAT,CAAaE,KAAK,IAAI;AAC3B,iBAAO,EACL,GAAIA,KADC;AAEL6C,YAAAA,QAAQ,EAAE,EAFL;AAGL+B,YAAAA,OAAO,EAAE5E;AAHJ,WAAP;AAKD,SANM,CAAP;AAOD,OAXH,EAYE,CAACJ,MAAD,EAASI,KAAT,KAAmB;AACjB,YAAIA,KAAJ,EAAW;AACTJ,UAAAA,MAAM,CAACiD,QAAP,CAAgBvB,IAAhB,CAAqBtB,KAArB;AACD;AACF,OAhBH,EAiBEX,EAAE,IAAI;AACJ,cAAMwF,YAAY,GAAG,KAAKpD,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBa,QAAtB,EAArB;;AACA,cAAMX,KAAK,GAAG,KAAKkC,QAAL,CAAcwC,GAAd,CAAkBxB,IAAI,CAACpD,EAAvB,EAA2Ba,QAA3B,EAAd;;AAEA,YAAIuE,KAAK,KAAK,CAAC,CAAX,IAAgBI,YAAY,GAAGtF,KAAf,GAAuBkF,KAAK,GAAG,CAAnD,EAAsD;AACpD,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD,OAzBH;AA2BD,KA5BD;AA8BA,WAAOE,KAAP;AACD;AAED;;;AACAG,EAAAA,aAAa,CAACzF,EAAD,EAAcoF,KAAK,GAAG,CAAC,CAAvB,EAA6C;AACxD,QAAIpF,EAAE,IAAI,CAAC,KAAKoC,QAAL,CAAcuC,GAAd,CAAkB3E,EAAlB,CAAX,EAAkC;AAChC,aAAO,EAAP;AACD,KAHuD,CAKxD;;;AACA,UAAMsF,KAAK,GAAGtF,EAAE,GACZ,CACE,EACE,GAAI,KAAKoC,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBY,aAAtB,EADN;AAEE4C,MAAAA,QAAQ,EAAE,EAFZ;AAGE+B,MAAAA,OAAO,EAAE,KAAKnD,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBY,aAAtB;AAHX,KADF,CADY,GAQZ,KAAKsC,QAAL,GAAgBzC,GAAhB,CAAoBwC,IAAI,IAAI;AAC1B,aAAO,EACL,GAAIA,IADC;AAELO,QAAAA,QAAQ,EAAE,EAFL;AAGL+B,QAAAA,OAAO,EAAEtC;AAHJ,OAAP;AAKD,KAND,CARJ,CANwD,CAsBxD;;AACA,SAAKV,SAAL,GAAiB,CAAC,GAAG+C,KAAJ,CAAjB;;AAEA,WAAO,KAAK/C,SAAL,CAAeX,MAAf,KAA0B,CAAjC,EAAoC;AAClC,YAAMwB,IAAI,GAAG,KAAKb,SAAL,CAAemD,KAAf,EAAb;;AACA,WAAKrB,GAAL,CACEjB,IADF,EAEE7C,MAAM,IAAI;AACR,eAAO,KAAKkD,WAAL,CAAiBlD,MAAM,CAACP,EAAxB,EAA4BS,GAA5B,CAAgCE,KAAK,IAAI;AAC9C,iBAAO,EACL,GAAIA,KADC;AAEL6C,YAAAA,QAAQ,EAAE,EAFL;AAGL+B,YAAAA,OAAO,EAAE5E;AAHJ,WAAP;AAKD,SANM,CAAP;AAOD,OAVH,EAWE,CAACJ,MAAD,EAASI,KAAT,KAAmB;AACjBJ,QAAAA,MAAM,CAACiD,QAAP,CAAgBvB,IAAhB,CAAqBtB,KAArB;;AACA,aAAK4B,SAAL,CAAeN,IAAf,CAAoBtB,KAApB;AACD,OAdH,EAeEX,EAAE,IAAI;AACJ,cAAMwF,YAAY,GAAG,KAAKpD,QAAL,CAAcwC,GAAd,CAAkB5E,EAAlB,EAAsBa,QAAtB,EAArB;;AACA,cAAMX,KAAK,GAAG,KAAKkC,QAAL,CAAcwC,GAAd,CAAkBU,KAAK,CAAC,CAAD,CAAL,CAAStF,EAA3B,EAA+Ba,QAA/B,EAAd;;AAEA,YAAIuE,KAAK,KAAK,CAAC,CAAX,IAAgBI,YAAY,GAAGtF,KAAf,GAAuBkF,KAAK,GAAG,CAAnD,EAAsD;AACpD,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD,OAvBH;AAyBD;;AAED,WAAOE,KAAP;AACD;AAED;;;;;AAGAK,EAAAA,OAAO,CAACC,UAAD,EAAqBX,OAArB,EAA2C;AAChD,UAAMY,QAAQ,GAAG,KAAKX,OAAL,CAAaU,UAAb,CAAjB;AACA,QAAI,CAACC,QAAL,EAAe,OAAO,EAAP;AACf,QAAIC,IAAS,GAAG,EAAhB;AACA,SAAKvC,GAAL,CACEsC,QADF,EAEEE,CAAC,IAAI;AACH,aAAO,KAAKtC,WAAL,CAAiBsC,CAAC,CAAC/F,EAAnB,CAAP;AACD,KAJH,EAKE,CAAC+F,CAAD,EAAIpF,KAAJ,EAAWO,GAAX,KAAmB;AACjB,UAAIP,KAAJ,EAAW;AACT,YAAIsE,OAAO,KAAKtE,KAAK,CAACX,EAAtB,EAA0B;AACxB8F,UAAAA,IAAI,GAAG,CAAC,GAAG5E,GAAJ,EAASP,KAAT,CAAP;AACD;;AACD,eAAO,CAAC,GAAGO,GAAJ,EAASP,KAAT,CAAP;AACD;;AACD,aAAOO,GAAP;AACD,KAbH,EAcE,MAAM;AACJ,aAAO4E,IAAI,CAAClE,MAAL,KAAgB,CAAvB;AACD,KAhBH,EAiBE,CAACiE,QAAD,CAjBF;AAoBA,WAAOC,IAAP;AACD;AAED;;;;;;AAIAE,EAAAA,eAAe,CAACC,KAAD,EAAgBC,KAAhB,EAAkC;AAC/C,UAAMjD,IAAI,GAAG,KAAKC,QAAL,CAAc,IAAd,EAAoB,CAApB,CAAb;;AACA,UAAMiD,KAAK,GAAG,KAAKR,OAAL,CAAa1C,IAAI,CAACjD,EAAlB,EAAsBiG,KAAtB,CAAd;AACA,UAAMG,KAAK,GAAG,KAAKT,OAAL,CAAa1C,IAAI,CAACjD,EAAlB,EAAsBkG,KAAtB,CAAd;AAEA,UAAMG,UAAU,GAAGF,KAAK,CAACG,MAAN,CAAa,CAACpF,GAAD,EAAMD,IAAN,KAAe;AAC7C,YAAMmC,IAAI,GAAG1D,IAAI,CAAC0G,KAAD,EAAQzE,CAAC,IAAI;AAC5B,eAAOV,IAAI,CAACjB,EAAL,KAAY2B,CAAC,CAAC3B,EAArB;AACD,OAFgB,CAAjB;;AAGA,UAAIoD,IAAJ,EAAU;AACR,eAAOA,IAAP;AACD;;AACD,aAAOlC,GAAP;AACD,KARkB,EAQhB,IARgB,CAAnB;;AAUA,QAAImF,UAAU,CAACrG,EAAX,KAAkBL,eAAe,CAACmE,QAAhB,EAAtB,EAAkD;AAChD,aAAO,IAAP;AACD;;AACD,WAAOuC,UAAP;AACD;;AAEDE,EAAAA,UAAU,CACRzB,MADQ,EAKR;AACA,UAAM0B,YAAiB,GAAG,CAAC1B,MAAM,CAACS,OAAR,CAA1B;AACA,UAAMkB,UAAe,GAAG,EAAxB;AACA,SAAKlD,GAAL,CACEuB,MADF,EAEEvE,MAAM,IAAI;AACRA,MAAAA,MAAM,CAACiD,QAAP,CAAgBL,OAAhB,CAAwBxC,KAAK,IAAI;AAC/B6F,QAAAA,YAAY,CAACvE,IAAb,CAAkBtB,KAAK,CAAC4E,OAAxB;AACA;;AACAkB,QAAAA,UAAU,CAACxE,IAAX,CAAgB;AACdD,UAAAA,CAAC,EAAEzB,MAAM,CAACP,EADI;AAEd+B,UAAAA,CAAC,EAAEpB,KAAK,CAACX;AAFK,SAAhB;AAID,OAPD;AAQA,aAAOO,MAAM,CAACiD,QAAd;AACD,KAZH,EAaE,MAAM,CAAE,CAbV;AAeA,WAAO;AACLhC,MAAAA,QAAQ,EAAEgF,YADL;AAEL/E,MAAAA,KAAK,EAAEgF;AAFF,KAAP;AAID;AAED;;;;;;AAIAC,EAAAA,SAAS,CAAC5B,MAAD,EAAYE,QAAQ,GAAGrF,eAAe,CAACmE,QAAhB,EAAvB,EAAyD;AAChE,QAAI,CAAC,KAAK1B,QAAL,CAAcuC,GAAd,CAAkBK,QAAlB,CAAL,EAAkC;AAChC;AACD;;AAED,SAAKvD,KAAL,GACEuD,QAAQ,KAAKrF,eAAe,CAACmE,QAAhB,EAAb,GAA0C,KAAKrC,KAA/C,GAAuD,CAAC,GAAG,KAAKA,KAAT,EAAgB;AAAEO,MAAAA,CAAC,EAAEgD,QAAL;AAAejD,MAAAA,CAAC,EAAE+C,MAAM,CAAC9E;AAAzB,KAAhB,CADzD;AAEA,SAAKwB,QAAL,GAAgB,CAAC,GAAG,KAAKA,QAAT,EAAmBsD,MAAnB,CAAhB;;AAEA,UAAMvE,MAAM,GAAG,KAAK6B,QAAL,CAAcwC,GAAd,CAAkBI,QAAlB,CAAf;;AACA,UAAM2B,WAAW,GAAG,IAAI9G,WAAJ,CAAsB;AACxCG,MAAAA,EAAE,EAAE8E,MAAM,CAAC9E,EAD6B;AAExCG,MAAAA,UAAU,EAAE,IAF4B;AAGxCF,MAAAA,IAAI,EAAE,UAHkC;AAIxCC,MAAAA,KAAK,EAAEK,MAAM,CAACL,KAAP,GAAe,CAJkB;AAKxCE,MAAAA,YAAY,EAAE,EAL0B;AAMxCC,MAAAA,MAAM,EAAEyE;AANgC,KAAtB,CAApB;;AASA,SAAKxB,YAAL,CAAkB/C,MAAlB,EAA0BoG,WAA1B;AACD;AAED;;;;;;AAIAC,EAAAA,YAAY,CAAC9B,MAAD,EAA0BE,QAAQ,GAAGrF,eAAe,CAACmE,QAAhB,EAArC,EAAuE;AACjF,QAAI,CAAC,KAAK1B,QAAL,CAAcuC,GAAd,CAAkBK,QAAlB,CAAL,EAAkC;AAChC;AACD,KAHgF,CAKjF;;;AACA,SAAKvD,KAAL,GACEuD,QAAQ,KAAKrF,eAAe,CAACmE,QAAhB,EAAb,GAA0C,KAAKrC,KAA/C,GAAuD,CAAC,GAAG,KAAKA,KAAT,EAAgB;AAAEO,MAAAA,CAAC,EAAEgD,QAAL;AAAejD,MAAAA,CAAC,EAAE+C,MAAM,CAAC9E;AAAzB,KAAhB,CADzD;;AAEA,UAAM;AAAEwB,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAAsB,KAAK8E,UAAL,CAAgBzB,MAAhB,CAA5B;;AACA,SAAKtD,QAAL,GAAgB,CAAC,GAAG,KAAKA,QAAT,EAAmB,GAAGA,QAAtB,CAAhB;AACA,SAAKC,KAAL,GAAa,CAAC,GAAG,KAAKA,KAAT,EAAgB,GAAGA,KAAnB,CAAb;AAEA,SAAKa,UAAL,GAAkB,KAAlB;;AAEA,UAAM/B,MAAM,GAAG,KAAK6B,QAAL,CAAcwC,GAAd,CAAkBI,QAAlB,CAAf;;AACA,SAAKzB,GAAL,CACEhD,MADF,EAEEA,MAAM,IAAI;AACR,YAAMiD,QAAQ,GAAG,KAAKC,WAAL,CAAiBlD,MAAM,CAACP,EAAxB,CAAjB;AACA,aAAOwD,QAAQ,CAAC/C,GAAT,CAAaE,KAAK,IAAI;AAC3B,eAAO,IAAId,WAAJ,CAAsB;AAC3BG,UAAAA,EAAE,EAAEW,KAAK,CAACX,EADiB;AAE3BG,UAAAA,UAAU,EAAE,IAFe;AAG3BF,UAAAA,IAAI,EAAE,UAHqB;AAI3BC,UAAAA,KAAK,EAAEK,MAAM,CAACL,KAAP,GAAe,CAJK;AAK3BE,UAAAA,YAAY,EAAE,EALa;AAM3BC,UAAAA,MAAM,EAAEM;AANmB,SAAtB,CAAP;AAQD,OATM,CAAP;AAUD,KAdH,EAeE,CAACJ,MAAD,EAASI,KAAT,KAAmB;AACjB,UAAIA,KAAJ,EAAW;AACT,aAAK2C,YAAL,CAAkB/C,MAAlB,EAA0BI,KAA1B;AACD;AACF,KAnBH;AAsBA,SAAK2B,UAAL,GAAkB,IAAlB;AACD;AAED;;;;;;AAIAuE,EAAAA,YAAY,CAACC,QAAD,EAAoC;AAC9C,QAAI,CAAC,KAAK1E,QAAL,CAAcuC,GAAd,CAAkBmC,QAAlB,CAAL,EAAkC;AAChC,aAAO,IAAP;AACD;;AAED,UAAMC,SAAS,GAAG,KAAK5B,aAAL,CAAmB2B,QAAnB,CAAlB;;AACA,UAAMvG,MAAM,GAAG,KAAK6B,QAAL,CAAcwC,GAAd,CAAkBkC,QAAlB,EAA4BxG,SAA5B,EAAf;;AACA,UAAM;AAAEkB,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAAsB,KAAK8E,UAAL,CAAgBQ,SAAhB,CAA5B;;AAEA,SAAKvF,QAAL,GAAgB,KAAKA,QAAL,CAAcK,MAAd,CAAqBiD,MAAM,IAAI;AAC7C,aAAOpF,IAAI,CAAC8B,QAAD,EAAWP,IAAI,IAAI;AAC5B,eAAOA,IAAI,CAACjB,EAAL,KAAY8E,MAAM,CAAC9E,EAA1B;AACD,OAFU,CAAJ,GAGH,KAHG,GAIH,IAJJ;AAKD,KANe,CAAhB;AAOA,SAAKyB,KAAL,GAAa,KAAKA,KAAL,CAAWI,MAAX,CAAkBC,IAAI,IAAI;AACrC,aAAOpC,IAAI,CAAC+B,KAAD,EAAQuF,CAAC,IAAI;AACtB,eAAQlF,IAAI,CAACE,CAAL,KAAWgF,CAAC,CAAChF,CAAb,IAAkBF,IAAI,CAACC,CAAL,KAAWiF,CAAC,CAACjF,CAAhC,IAAuCD,IAAI,CAACE,CAAL,KAAWzB,MAAM,CAACP,EAAlB,IAAwB8B,IAAI,CAACC,CAAL,KAAW+E,QAAjF;AACD,OAFU,CAAJ,GAGH,KAHG,GAIH,IAJJ;AAKD,KANY,CAAb,CAhB8C,CAwB9C;;AACAtF,IAAAA,QAAQ,CAAC2B,OAAT,CAAiB2B,MAAM,IAAI;AACzB,WAAK1C,QAAL,CAAc6E,MAAd,CAAqBnC,MAAM,CAAC9E,EAA5B;AACD,KAFD;AAGAO,IAAAA,MAAM,CAACH,YAAP,GAAsBG,MAAM,CAACH,YAAP,CAAoByB,MAApB,CAA2BnB,SAAS,IAAI;AAC5D,aAAOA,SAAS,CAACC,KAAV,CAAgBX,EAAhB,KAAuB8G,QAA9B;AACD,KAFqB,CAAtB;AAIA,WAAOC,SAAP;AACD;AAED;;;;;AAGAG,EAAAA,YAAY,CAACpC,MAAD,EAAkB;AAC5B,SAAKtD,QAAL,GAAgB,KAAKA,QAAL,CAAcf,GAAd,CAAkBQ,IAAI,IAAI;AACxC,UAAIA,IAAI,CAACjB,EAAL,KAAY8E,MAAM,CAAC9E,EAAvB,EAA2B;AACzB,eAAO8E,MAAP;AACD;;AACD,aAAO7D,IAAP;AACD,KALe,CAAhB;;AAMA,QAAI,KAAKmB,QAAL,CAAcuC,GAAd,CAAkBG,MAAM,CAAC9E,EAAzB,CAAJ,EAAkC;AAChC;AACA,YAAMmH,SAAS,GAAG,KAAK/E,QAAL,CAAcwC,GAAd,CAAkBE,MAAM,CAAC9E,EAAzB,CAAlB;;AACAmH,MAAAA,SAAS,CAAC9G,MAAV,GAAmByE,MAAnB;AACD;AACF;AAED;;;;;AAGAsC,EAAAA,UAAU,CAACtF,IAAD,EAAgB;AACxB,SAAKL,KAAL,GAAa,KAAKA,KAAL,CAAWhB,GAAX,CAAeuG,CAAC,IAAI;AAC/B,UAAIA,CAAC,CAAChF,CAAF,KAAQF,IAAI,CAACE,CAAb,IAAkBgF,CAAC,CAACjF,CAAF,KAAQD,IAAI,CAACC,CAAnC,EAAsC;AACpC,eAAOD,IAAP;AACD;;AACD,aAAOkF,CAAP;AACD,KALY,CAAb;AAMD;AAED;;;;;;AAIAK,EAAAA,UAAU,CAACrF,CAAD,EAAYD,CAAZ,EAAwC;AAChD,QAAI,CAAC,KAAKK,QAAL,CAAcuC,GAAd,CAAkB3C,CAAlB,CAAD,IAAyB,CAAC,KAAKI,QAAL,CAAcuC,GAAd,CAAkB5C,CAAlB,CAA9B,EAAoD;AAClD,aAAO,IAAP;AACD;;AAED,SAAKN,KAAL,GAAa,KAAKA,KAAL,CAAWI,MAAX,CAAkBC,IAAI,IAAI;AACrC,aAAOA,IAAI,CAACE,CAAL,KAAWA,CAAX,IAAgBF,IAAI,CAACC,CAAL,KAAWD,IAAI,CAACC,CAAvC;AACD,KAFY,CAAb;AAGA,WAAO,KAAK8E,YAAL,CAAkB9E,CAAlB,CAAP;AACD;;AAEDuF,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAK9F,QAAZ;AACD;;AAED+F,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAK9F,KAAZ;AACD;AAED;;;AACA+F,EAAAA,eAAe,CAACxH,EAAD,EAAcoF,KAAK,GAAG,CAAC,CAAvB,EAA+B;AAC5C,UAAM;AAAE5D,MAAAA;AAAF,QAAe,KAAK+E,UAAL,CAAgB,KAAKd,aAAL,CAAmBzF,EAAnB,EAAuBoF,KAAvB,EAA8B,CAA9B,CAAhB,CAArB;;AACA,WAAO5D,QAAQ,CAACK,MAAT,CAAgBuB,IAAI,IAAI;AAC7B,aAAO,KAAKK,WAAL,CAAiBL,IAAI,CAACpD,EAAtB,EAA0B4B,MAA1B,KAAqC,CAA5C;AACD,KAFM,CAAP;AAGD;;AAhpBkD,C,CAmpBrD;;;AAnpBMM,I,CAEGM,M;AAFHN,I,CAIGO,O;AAJHP,I,CAMGuF,K;;AA8oBTvF,IAAI,CAACM,MAAL,GAAc,CAAChB,QAAD,EAAsCC,KAAtC,KAAgF;AAC5F,QAAMiG,WAAqB,GAAG,EAA9B;;AACA,WAASnE,GAAT,CAAaH,IAAb,EAAuC;AACrC,QAAIsE,WAAW,CAAC3C,OAAZ,CAAoB3B,IAAI,CAACpD,EAAzB,MAAiC,CAAC,CAAtC,EAAyC;AACvC,aAAO,KAAP;AACD;;AACD0H,IAAAA,WAAW,CAACzF,IAAZ,CAAiBmB,IAAI,CAACpD,EAAtB;AAEA,UAAM6E,UAAU,GAAGpD,KAAK,CAACI,MAAN,CAAaC,IAAI,IAAIA,IAAI,CAACE,CAAL,KAAWoB,IAAI,CAACpD,EAArC,EAAyCS,GAAzC,CAA6CqB,IAAI,IAAIA,IAAI,CAACC,CAA1D,CAAnB;AACA,UAAMyB,QAAQ,GAAGhC,QAAQ,CAACK,MAAT,CAAgBiD,MAAM,IAAI;AACzC,aAAOD,UAAU,CAACE,OAAX,CAAmBD,MAAM,CAAC9E,EAA1B,MAAkC,CAAC,CAA1C;AACD,KAFgB,CAAjB;;AAIA,SAAK,IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,QAAQ,CAAC5B,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAI,CAAC4B,GAAG,CAACC,QAAQ,CAAC7B,CAAD,CAAT,CAAR,EAAuB;AACrB,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAnB2F,CAqB5F;;;AACA,MAAIH,QAAQ,CAACI,MAAT,KAAoBH,KAAK,CAACG,MAAN,GAAe,CAAvC,EAA0C;AACxC,WAAO,KAAP;AACD,GAxB2F,CAyB5F;;;AACA,QAAMF,KAAK,GAAGH,OAAO,CAAuBC,QAAvB,EAAiCC,KAAjC,CAArB;;AACA,MAAIC,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACtB,WAAO2B,GAAG,CAAC7B,KAAK,CAAC,CAAD,CAAN,CAAV;AACD;;AACD,SAAO,KAAP;AACD,CA/BD,C,CAiCA;;;AACAQ,IAAI,CAACO,OAAL,GAAe,CAACjB,QAAD,EAAsCC,KAAtC,KAAgF;AAC7F,QAAMC,KAAK,GAAGH,OAAO,CAAuBC,QAAvB,EAAiCC,KAAjC,CAArB;;AACA,MAAIC,KAAK,CAACE,MAAN,IAAgB,CAApB,EAAuB;AACrB,WAAO,KAAP;AACD;;AACD,QAAM+F,aAAa,GAAGhI,eAAe,CAACmE,QAAhB,EAAtB;AACA,SAAO5B,IAAI,CAACM,MAAL,CACL,CAAC,GAAGhB,QAAJ,EAAc;AAAExB,IAAAA,EAAE,EAAE2H;AAAN,GAAd,CADK,EAEL,CACE,GAAGlG,KADL,EAEE,GAAGC,KAAK,CAACjB,GAAN,CAAU2C,IAAI,IAAI;AACnB,WAAO;AACLpB,MAAAA,CAAC,EAAE2F,aADE;AAEL5F,MAAAA,CAAC,EAAEqB,IAAI,CAACpD;AAFH,KAAP;AAID,GALE,CAFL,CAFK,CAAP;AAYD,CAlBD;AAoBA;;;AACAkC,IAAI,CAACuF,KAAL,GAAa,CACXG,IADW,EAEXC,KAFW,EAGXpE,WAHW,EAIXI,OAJW,KAKR;AACH,QAAMiE,YAAY,GAAGD,KAAK,GACtBA,KADsB,GAErBzE,IAAD,IAAe;AACb,WAAOA,IAAI,CAACpD,EAAZ;AACD,GAJL;AAKA,QAAM+H,kBAAkB,GAAGtE,WAAW,GAClCA,WADkC,GAEjCL,IAAD,IAAe;AACb,WAAOA,IAAI,CAACI,QAAZ;AACD,GAJL;AAMA,QAAMhC,QAA0B,GAAG,EAAnC;AACA,QAAMC,KAAqB,GAAG,EAA9B;AAEA,QAAMiG,WAAqB,GAAG,EAA9B;;AACA,WAASnE,GAAT,CAAaH,IAAb,EAAsB;AACpB,UAAMpD,EAAE,GAAG8H,YAAY,CAAC1E,IAAD,CAAvB;AACAA,IAAAA,IAAI,CAACpD,EAAL,GAAUA,EAAV;;AACA,QAAI0H,WAAW,CAAC3C,OAAZ,CAAoB/E,EAApB,MAA4B,CAAC,CAAjC,EAAoC;AAClC2C,MAAAA,OAAO,CAACC,KAAR,CAAc,MAAd;AACA,aAAO,KAAP;AACD;;AACD8E,IAAAA,WAAW,CAACzF,IAAZ,CAAiBjC,EAAjB;AAEAwB,IAAAA,QAAQ,CAACS,IAAT,CAAcmB,IAAd;AAEA,UAAMI,QAAa,GAAGuE,kBAAkB,CAAC3E,IAAD,CAAxC;;AACA,QAAII,QAAQ,IAAIA,QAAQ,CAAC5B,MAAzB,EAAiC;AAC/B,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,QAAQ,CAAC5B,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,cAAMhB,KAAK,GAAG6C,QAAQ,CAAC7B,CAAD,CAAtB;AACA,cAAMsD,OAAO,GAAG6C,YAAY,CAACnH,KAAD,CAA5B;AACAA,QAAAA,KAAK,CAACX,EAAN,GAAWiF,OAAX;AAEA,cAAMnD,IAAI,GAAG+B,OAAO,GAChBA,OAAO,CAACT,IAAD,EAAOzC,KAAP,CADS,GAEf;AACCqB,UAAAA,CAAC,EAAEhC,EADJ;AAEC+B,UAAAA,CAAC,EAAEkD;AAFJ,SAFL;AAMAxD,QAAAA,KAAK,CAACQ,IAAN,CAAWH,IAAX;AACAyB,QAAAA,GAAG,CAAC5C,KAAD,CAAH;AACD;AACF;AACF;;AAED,OAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiG,IAAI,CAAChG,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC4B,IAAAA,GAAG,CAACqE,IAAI,CAACjG,CAAD,CAAL,CAAH;AACD;;AAED,SAAO;AACLH,IAAAA,QADK;AAELC,IAAAA;AAFK,GAAP;AAID,CA3DD;;AA6DA,eAAeS,IAAf","sourcesContent":["/**\n * @file 树操作\n */\n\nimport { OutputVertex } from './type';\nimport { findIndex, find } from '../Utils/utils';\nimport { BaseVertex, BaseEdge, Vertex, Edge,  } from '../type';\n\nconst VIRTUAL_ROOT_ID = Symbol('VIRTUAL_ROOT_ID');\n\n// 内部 Tree 节点\nclass _TreeVertex<V, E> {\n  /** 索引 id */\n  id: string;\n  /** 节点类型 */\n  type: 'virtualRoot' | 'realNode';\n  /** 当前节点层级 */\n  level: number;\n  /** 父节点关联边 */\n  parentEdge: _TreeEdge<V, E>;\n  /** 子节点关联边列表 */\n  childrenEdge: _TreeEdge<V, E>[];\n  /** 源信息，与 Vertex[] 对应 */\n  origin: V;\n\n  constructor(config: {\n    id: string;\n    type: 'virtualRoot' | 'realNode';\n    level: number;\n    parentEdge: _TreeEdge<V, E>;\n    childrenEdge: _TreeEdge<V, E>[];\n    origin: V;\n  }) {\n    this.id = config.id;\n    this.type = config.type;\n    this.level = config.level;\n    this.parentEdge = config.parentEdge;\n    this.childrenEdge = config.childrenEdge;\n    this.origin = config.origin;\n  }\n\n  getParent(): _TreeVertex<V, E> {\n    return this.parentEdge.parent;\n  }\n\n  getChildrenOriginNode(): V[] {\n    return this.childrenEdge.map(childEdge => {\n      return childEdge.child.getOriginNode();\n    });\n  }\n\n  getOriginNode() {\n    return this.origin;\n  }\n\n  getLevel() {\n    return this.level;\n  }\n\n  /** 获取兄弟节点 */\n  getSibling() {\n    const sibling = this.parentEdge.parent.getChildrenOriginNode();\n    const index = findIndex(sibling, (item: any) => {\n      return item.id === this.id;\n    });\n    return {\n      pre: sibling.slice(0, index),\n      index,\n      next: sibling.slice(index + 1)\n    };\n  }\n\n  isVirtualRoot() {\n    return this.type === 'virtualRoot';\n  }\n}\n\n// 内部 Tree 边\nclass _TreeEdge<V, E> {\n  /** 父节点索引 */\n  parent: _TreeVertex<V, E>;\n  /** 另一端节点索引 */\n  child: _TreeVertex<V, E>;\n  /** 源信息 */\n  origin: E;\n\n  constructor(config: { parent: _TreeVertex<V, E>; child: _TreeVertex<V, E>; origin: E }) {\n    this.parent = config.parent;\n    this.child = config.child;\n    this.origin = config.origin;\n  }\n}\n\n// 获取根节点\nfunction getRoot<V extends BaseVertex, E extends BaseEdge>(\n  vertexes: Array<Vertex<V>>,\n  edges: Array<Edge<E>>\n): Array<Vertex<V>> {\n  const roots: Array<Vertex<V>> = [];\n  for (let i = 0; i < vertexes.length; i++) {\n    const id = vertexes[i].id;\n    // 没有上游节点，说明为根节点\n    if (edges.filter(edge => edge.v === id).map(edge => edge.u).length === 0) {\n      roots.push(vertexes[i]);\n    }\n  }\n  return roots;\n}\n\n/**\n * 针对传入的 vertexes, edges 建立一颗索引树\n * CURD 操作时都有两种模式，存在索引树，或不存在\n * 注意：edge的 u，v，表示 v 是 u 的子节点，存在从属关系，无向图的树无法明确生成\n * @Todo 同树同层级子节点的顺序定义\n */\nclass Tree<V extends BaseVertex, E extends BaseEdge> {\n  // 类的静态方法，是否为树\n  static isTree: (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>) => boolean;\n  // 类的静态方法，是否为多树\n  static isMulti: (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>) => boolean;\n  // 类的静态方法，解析嵌套结构\n  static parse: <V extends BaseVertex, E extends BaseEdge>(\n    tree: V[],\n    getId?: (node: V) => string,\n    getChildren?: (node: V) => V[],\n    getEdge?: (parent: V, child: V) => E\n  ) => { vertexes: Array<Vertex<V>>; edges: Array<Edge<E>> };\n\n  // 外界传入的节点数据\n  private vertexes: Array<Vertex<V>> = [];\n  // 外界传入的边数据\n  private edges: Array<Edge<E>> = [];\n\n  // 内部索引树\n  private _tree: _TreeVertex<V, E> = null;\n  // 内部索引 Map\n  private _treeMap: Map<string, _TreeVertex<V, E>> = new Map();\n  // 内部索引树是否已经建立，已建立，使用索引树加速查询\n  private _treeReady: boolean = false;\n  // bfs 内部队列\n  private _bfsQueue: OutputVertex<V>[];\n\n  constructor(vertexes: Array<Vertex<V>>, edges: Array<Edge<E>>) {\n    if (Tree.isTree(vertexes, edges) || Tree.isMulti(vertexes, edges)) {\n      this.vertexes = vertexes;\n      this.edges = edges;\n      this._tree = this._createTree();\n      return;\n    }\n    console.error('当前数据无法成树');\n  }\n\n  /**\n   * 创建链式树，为了多树场景，需要创建一个虚拟根节点\n   */\n  _createTree() {\n    this._treeReady = false;\n    this._treeMap.clear();\n\n    const virtualRoot = this._createVirtualRoot();\n    this._treeMap.set(virtualRoot.id, virtualRoot);\n    const root = this._getRoot();\n\n    // 虚拟根节点与真实根节点产生关联\n    root.forEach(node => {\n      const treeNode: _TreeVertex<V, E> = new _TreeVertex({\n        id: node.id,\n        type: 'realNode',\n        level: virtualRoot.level + 1,\n        parentEdge: null,\n        childrenEdge: [],\n        origin: node\n      });\n      this._addChildren(virtualRoot, treeNode);\n      this.dfs<_TreeVertex<V, E>, void>(\n        treeNode,\n        parent => {\n          const children = this.getChildren(parent.id);\n          return children.map(child => {\n            return new _TreeVertex({\n              id: child.id,\n              type: 'realNode',\n              level: parent.level + 1,\n              parentEdge: null,\n              childrenEdge: [],\n              origin: child\n            });\n          });\n        },\n        (parent, child) => {\n          if (child) {\n            this._addChildren(parent, child);\n          }\n        }\n      );\n    });\n\n    this._treeReady = true;\n\n    return virtualRoot;\n  }\n\n  _addChildren(parentNode: _TreeVertex<V, E>, childNode: _TreeVertex<V, E>) {\n    const isExistChild = find(\n      parentNode.childrenEdge.map(childEdge => {\n        return childEdge.child;\n      }),\n      child => {\n        return child.id === childNode.id;\n      }\n    );\n    if (!isExistChild) {\n      const edge = this.getEdge(parentNode.origin.id, childNode.origin.id);\n      parentNode.childrenEdge.push(\n        new _TreeEdge({\n          parent: parentNode,\n          child: childNode,\n          origin: edge\n        })\n      );\n      childNode.parentEdge = new _TreeEdge({\n        parent: parentNode,\n        child: childNode,\n        origin: edge\n      });\n      this._treeMap.set(childNode.id, childNode);\n    }\n  }\n\n  /** 创建虚拟根节点 */\n  _createVirtualRoot(): _TreeVertex<V, E> {\n    const id = VIRTUAL_ROOT_ID.toString();\n    return new _TreeVertex({\n      id,\n      parentEdge: null,\n      type: 'virtualRoot',\n      level: 0,\n      childrenEdge: [],\n      origin: {\n        id\n      } as V\n    });\n  }\n\n  /** dfs 遍历树 */\n  dfs<N extends { id: string }, R>(\n    node: N,\n    getChildren: (parent: N) => N[],\n    beforeCallback: (parent: N, child: N, preCallBackResult: R) => R = () => undefined,\n    isDfs: (id: string) => boolean = () => true,\n    callBackResult: R = null,\n    afterCallback: (parent: N, child: N, preCallBackResult: R) => void = () => undefined\n  ) {\n    if (!isDfs(node.id)) {\n      return;\n    }\n    const children = getChildren(node);\n    if (children && children.length) {\n      children.forEach(child => {\n        const result = beforeCallback(node, child, callBackResult);\n        this.dfs(child, getChildren, beforeCallback, isDfs, result, afterCallback);\n        afterCallback(node, child, result);\n      });\n    } else {\n      const result = beforeCallback(node, null, callBackResult);\n      afterCallback(node, null, result);\n    }\n  }\n\n  /** bfs 遍历树 */\n  bfs<N extends { id: string }>(\n    node: N,\n    getChildren: (parent: N) => N[],\n    callback: (parent: N, child: N) => void,\n    isBfs: (id: string) => boolean = () => true\n  ) {\n    if (!isBfs(node.id)) {\n      return;\n    }\n    getChildren(node).forEach(child => {\n      callback(node, child);\n    });\n  }\n\n  _getRoot(isVirtual?: boolean): V[] {\n    if (this._treeReady) {\n      // 返回虚拟根节点\n      if (isVirtual) {\n        return [this._tree.getOriginNode()];\n      }\n      return this._tree.getChildrenOriginNode();\n    } else {\n      return getRoot<V, E>(this.vertexes, this.edges);\n    }\n  }\n\n  /** 得到树的唯一根节点 */\n  getSingleRoot(): V {\n    const roots = this._getRoot();\n    return roots[0];\n  }\n\n  /** 得到树的多重根节点 */\n  getMultiRoot(): V[] {\n    return this._getRoot();\n  }\n\n  /** 获取当前节点的父节点 */\n  getParent(id: string): V {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        const parent = this._treeMap.get(id).getParent();\n        // 如果父元素是虚拟的根元素\n        if (parent.isVirtualRoot()) {\n          return null;\n        }\n        return parent.getOriginNode();\n      }\n      return null;\n    } else {\n      const edgeIdList = this.edges.filter(edge => edge.v === id).map(edge => edge.u);\n      if (edgeIdList.length === 0) {\n        return null;\n      }\n      return find(this.vertexes, vertex => {\n        return edgeIdList.indexOf(vertex.id) !== -1;\n      });\n    }\n  }\n\n  /** 得到当前边 */\n  getEdge(parentId: string, childId: string): E {\n    const edges = this.edges.filter(edge => {\n      return edge.u === parentId && edge.v === childId;\n    });\n    return edges.length === 0 ? null : edges[0];\n  }\n\n  /** 得到当前节点 */\n  getNode(id: string): V {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getOriginNode();\n      }\n      return null;\n    } else {\n      const vertex = this.vertexes.filter(vertex => {\n        return vertex.id === id;\n      });\n      return vertex.length === 0 ? null : vertex[0];\n    }\n  }\n\n  getSibling(\n    id: string\n  ): {\n    pre: V[];\n    next: V[];\n    index: number;\n  } {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getSibling();\n      }\n    }\n    /** @todo 有点懒得写 */\n    return {\n      pre: [],\n      next: [],\n      index: -1\n    };\n  }\n\n  /** 得到子节点 */\n  getChildren(id: string): V[] {\n    if (this._treeReady) {\n      if (this._treeMap.has(id)) {\n        return this._treeMap.get(id).getChildrenOriginNode();\n      }\n      return [];\n    } else {\n      if (id === VIRTUAL_ROOT_ID.toString()) {\n        return this._getRoot();\n      }\n      const edgeIdList = this.edges.filter(edge => edge.u === id).map(edge => edge.v);\n      return this.vertexes.filter(vertex => {\n        return edgeIdList.indexOf(vertex.id) !== -1;\n      });\n    }\n  }\n\n  /** 获取节点层级 */\n  getLevel(id: string): number {\n    if (this._treeMap.has(id)) {\n      return this._treeMap.get(id).getLevel();\n    }\n    /** @Todo 注意异常处理 */\n    return null;\n  }\n\n  /** 得到唯一树 */\n  getSingleTree(id?: string, depth = -1): OutputVertex<V> {\n    if (id && !this._treeMap.has(id)) {\n      return null;\n    }\n    return this.getTree(id, depth)[0];\n  }\n\n  /** 得到树，子树，可定义多少深度 */\n  getTree(id?: string, depth = -1): OutputVertex<V>[] {\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    }\n    // 如果没有 id 则默认为根节点\n    const nodes = id\n      ? [\n          {\n            ...(this._treeMap.get(id).getOriginNode() as any),\n            children: [],\n            _origin: this._treeMap.get(id).getOriginNode()\n          }\n        ]\n      : this._getRoot().map(root => {\n          return {\n            ...(root as any),\n            children: [],\n            _origin: root\n          };\n        });\n    nodes.forEach(node => {\n      this.dfs<OutputVertex<V>, void>(\n        node,\n        parent => {\n          const children = this.getChildren(parent.id);\n          return children.map(child => {\n            return {\n              ...(child as any),\n              children: [],\n              _origin: child\n            };\n          });\n        },\n        (parent, child) => {\n          if (child) {\n            parent.children.push(child);\n          }\n        },\n        id => {\n          const currentLevel = this._treeMap.get(id).getLevel();\n          const level = this._treeMap.get(node.id).getLevel();\n\n          if (depth === -1 || currentLevel - level < depth - 1) {\n            return true;\n          }\n          return false;\n        }\n      );\n    });\n\n    return nodes;\n  }\n\n  /** 使用 BFS 获取子树 */\n  _getTreeByBFS(id?: string, depth = -1): OutputVertex<V>[] {\n    if (id && !this._treeMap.has(id)) {\n      return [];\n    }\n\n    // 如果没有 id 则默认为根节点\n    const nodes = id\n      ? [\n          {\n            ...(this._treeMap.get(id).getOriginNode() as any),\n            children: [],\n            _origin: this._treeMap.get(id).getOriginNode()\n          }\n        ]\n      : this._getRoot().map(root => {\n          return {\n            ...(root as any),\n            children: [],\n            _origin: root\n          };\n        });\n\n    // 深拷贝\n    this._bfsQueue = [...nodes];\n\n    while (this._bfsQueue.length !== 0) {\n      const node = this._bfsQueue.shift();\n      this.bfs<OutputVertex<V>>(\n        node,\n        parent => {\n          return this.getChildren(parent.id).map(child => {\n            return {\n              ...(child as any),\n              children: [],\n              _origin: child\n            };\n          });\n        },\n        (parent, child) => {\n          parent.children.push(child);\n          this._bfsQueue.push(child);\n        },\n        id => {\n          const currentLevel = this._treeMap.get(id).getLevel();\n          const level = this._treeMap.get(nodes[0].id).getLevel();\n\n          if (depth === -1 || currentLevel - level < depth - 1) {\n            return true;\n          }\n          return false;\n        }\n      );\n    }\n\n    return nodes;\n  }\n\n  /**\n   * 获取祖孙节点的路径\n   */\n  getPath(ancestorId: string, childId: string): V[] {\n    const ancestor = this.getNode(ancestorId);\n    if (!ancestor) return [];\n    let path: V[] = [];\n    this.dfs<V, V[]>(\n      ancestor,\n      p => {\n        return this.getChildren(p.id);\n      },\n      (p, child, pre) => {\n        if (child) {\n          if (childId === child.id) {\n            path = [...pre, child];\n          }\n          return [...pre, child];\n        }\n        return pre;\n      },\n      () => {\n        return path.length === 0;\n      },\n      [ancestor]\n    );\n\n    return path;\n  }\n\n  /**\n   * 获取两节点的最近公共祖先，\n   * 这里先采用在线的算法，离线适用于大量查询场景，暂时还没有\n   */\n  getNodeRelation(node1: string, node2: string): V {\n    const root = this._getRoot(true)[0];\n    const path1 = this.getPath(root.id, node1);\n    const path2 = this.getPath(root.id, node2);\n\n    const commonRoot = path1.reduce((pre, item) => {\n      const node = find(path2, i => {\n        return item.id === i.id;\n      });\n      if (node) {\n        return node;\n      }\n      return pre;\n    }, null);\n\n    if (commonRoot.id === VIRTUAL_ROOT_ID.toString()) {\n      return null;\n    }\n    return commonRoot;\n  }\n\n  _translate(\n    vertex: OutputVertex<V>\n  ): {\n    vertexes: V[];\n    edges: E[];\n  } {\n    const vertexResult: V[] = [vertex._origin];\n    const edgeResult: E[] = [];\n    this.dfs<OutputVertex<V>, void>(\n      vertex,\n      parent => {\n        parent.children.forEach(child => {\n          vertexResult.push(child._origin);\n          /** @Todo 这会造成边信息丢失，目前只能用 updateEdge 来补 */\n          edgeResult.push({\n            u: parent.id,\n            v: child.id\n          } as E);\n        });\n        return parent.children;\n      },\n      () => {}\n    );\n    return {\n      vertexes: vertexResult,\n      edges: edgeResult\n    };\n  }\n\n  /**\n   * 添加点，自动增加一条边\n   * 不存在 parentId，即新开一棵树，挂载到虚拟节点上\n   */\n  addVertex(vertex: V, parentId = VIRTUAL_ROOT_ID.toString()): void {\n    if (!this._treeMap.has(parentId)) {\n      return;\n    }\n\n    this.edges =\n      parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : [...this.edges, { u: parentId, v: vertex.id } as E];\n    this.vertexes = [...this.vertexes, vertex];\n\n    const parent = this._treeMap.get(parentId);\n    const newTreeNode = new _TreeVertex<V, E>({\n      id: vertex.id,\n      parentEdge: null,\n      type: 'realNode',\n      level: parent.level + 1,\n      childrenEdge: [],\n      origin: vertex\n    });\n\n    this._addChildren(parent, newTreeNode);\n  }\n\n  /**\n   * 添加子树，自动增加一条边\n   * 不存在 parentId，即新开一棵树，挂载到虚拟节点上\n   */\n  addChildTree(vertex: OutputVertex<V>, parentId = VIRTUAL_ROOT_ID.toString()): void {\n    if (!this._treeMap.has(parentId)) {\n      return;\n    }\n\n    // 虚拟节点与真实节点的边不加入 this.edges\n    this.edges =\n      parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : [...this.edges, { u: parentId, v: vertex.id } as E];\n    const { vertexes, edges } = this._translate(vertex);\n    this.vertexes = [...this.vertexes, ...vertexes];\n    this.edges = [...this.edges, ...edges];\n\n    this._treeReady = false;\n\n    const parent = this._treeMap.get(parentId);\n    this.dfs<_TreeVertex<V, E>, void>(\n      parent,\n      parent => {\n        const children = this.getChildren(parent.id);\n        return children.map(child => {\n          return new _TreeVertex<V, E>({\n            id: child.id,\n            parentEdge: null,\n            type: 'realNode',\n            level: parent.level + 1,\n            childrenEdge: [],\n            origin: child\n          });\n        });\n      },\n      (parent, child) => {\n        if (child) {\n          this._addChildren(parent, child);\n        }\n      }\n    );\n\n    this._treeReady = true;\n  }\n\n  /**\n   * 删除节点及其所有下游节点\n   * 返回删除的子树\n   */\n  deleteVertex(vertexId: string): OutputVertex<V> {\n    if (!this._treeMap.has(vertexId)) {\n      return null;\n    }\n\n    const childTree = this.getSingleTree(vertexId);\n    const parent = this._treeMap.get(vertexId).getParent();\n    const { vertexes, edges } = this._translate(childTree);\n\n    this.vertexes = this.vertexes.filter(vertex => {\n      return find(vertexes, item => {\n        return item.id === vertex.id;\n      })\n        ? false\n        : true;\n    });\n    this.edges = this.edges.filter(edge => {\n      return find(edges, e => {\n        return (edge.u === e.u && edge.v === e.v) || (edge.u === parent.id && edge.v === vertexId);\n      })\n        ? false\n        : true;\n    });\n\n    // 清除 _tree 与 _treeMap\n    vertexes.forEach(vertex => {\n      this._treeMap.delete(vertex.id);\n    });\n    parent.childrenEdge = parent.childrenEdge.filter(childEdge => {\n      return childEdge.child.id !== vertexId;\n    });\n\n    return childTree;\n  }\n\n  /**\n   * 更新节点\n   */\n  updateVertex(vertex: V): void {\n    this.vertexes = this.vertexes.map(item => {\n      if (item.id === vertex.id) {\n        return vertex;\n      }\n      return item;\n    });\n    if (this._treeMap.has(vertex.id)) {\n      // 修改引用\n      const oldVertex = this._treeMap.get(vertex.id);\n      oldVertex.origin = vertex;\n    }\n  }\n\n  /**\n   * 更新边\n   */\n  updateEdge(edge: E): void {\n    this.edges = this.edges.map(e => {\n      if (e.u === edge.u && e.v === edge.v) {\n        return edge;\n      }\n      return e;\n    });\n  }\n\n  /**\n   * 删除边，同时删除与关联的下游节点\n   * 返回下游子树\n   */\n  deleteEdge(u: string, v: string): OutputVertex<V> {\n    if (!this._treeMap.has(u) || !this._treeMap.has(v)) {\n      return null;\n    }\n\n    this.edges = this.edges.filter(edge => {\n      return edge.u !== u && edge.v !== edge.v;\n    });\n    return this.deleteVertex(v);\n  }\n\n  getVertexes() {\n    return this.vertexes;\n  }\n\n  getEdges() {\n    return this.edges;\n  }\n\n  /** 获取当前节点所有的叶子节点 */\n  getLeafVertexes(id?: string, depth = -1): V[] {\n    const { vertexes } = this._translate(this._getTreeByBFS(id, depth)[0]);\n    return vertexes.filter(node => {\n      return this.getChildren(node.id).length === 0;\n    });\n  }\n}\n\n// 判断是否为树\nTree.isTree = (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>): boolean => {\n  const visitedList: string[] = [];\n  function dfs(node: Vertex<BaseVertex>) {\n    if (visitedList.indexOf(node.id) !== -1) {\n      return false;\n    }\n    visitedList.push(node.id);\n\n    const edgeIdList = edges.filter(edge => edge.u === node.id).map(edge => edge.v);\n    const children = vertexes.filter(vertex => {\n      return edgeIdList.indexOf(vertex.id) !== -1;\n    });\n\n    for (let i = 0; i < children.length; i++) {\n      if (!dfs(children[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // 树必然 n 个节点，n - 1 条边\n  if (vertexes.length !== edges.length + 1) {\n    return false;\n  }\n  // 不存在环\n  const roots = getRoot<BaseVertex, BaseEdge>(vertexes, edges);\n  if (roots.length === 1) {\n    return dfs(roots[0]);\n  }\n  return false;\n};\n\n// 判断是否为多树，寻找出多个根节点，用虚拟根节点连接，能形成一颗树\nTree.isMulti = (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>): boolean => {\n  const roots = getRoot<BaseVertex, BaseEdge>(vertexes, edges);\n  if (roots.length <= 1) {\n    return false;\n  }\n  const virtualRootId = VIRTUAL_ROOT_ID.toString();\n  return Tree.isTree(\n    [...vertexes, { id: virtualRootId }],\n    [\n      ...edges,\n      ...roots.map(node => {\n        return {\n          u: virtualRootId,\n          v: node.id\n        };\n      })\n    ]\n  );\n};\n\n/** 解析嵌套的树结构 */\nTree.parse = <V extends BaseVertex, E extends BaseEdge>(\n  tree: V[],\n  getId?: (node: V) => string,\n  getChildren?: (node: V) => V[],\n  getEdge?: (parent: V, child: V) => E\n) => {\n  const getIdHandler = getId\n    ? getId\n    : (node: any) => {\n        return node.id;\n      };\n  const getChildrenHandler = getChildren\n    ? getChildren\n    : (node: any) => {\n        return node.children;\n      };\n\n  const vertexes: Array<Vertex<V>> = [];\n  const edges: Array<Edge<E>> = [];\n\n  const visitedList: string[] = [];\n  function dfs(node: V) {\n    const id = getIdHandler(node);\n    node.id = id;\n    if (visitedList.indexOf(id) !== -1) {\n      console.error('存在环！');\n      return false;\n    }\n    visitedList.push(id);\n\n    vertexes.push(node);\n\n    const children: V[] = getChildrenHandler(node);\n    if (children && children.length) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const childId = getIdHandler(child);\n        child.id = childId;\n\n        const edge = getEdge\n          ? getEdge(node, child)\n          : ({\n              u: id,\n              v: childId\n            } as E);\n        edges.push(edge);\n        dfs(child);\n      }\n    }\n  }\n\n  for (let i = 0; i < tree.length; i++) {\n    dfs(tree[i]);\n  }\n\n  return {\n    vertexes,\n    edges\n  };\n};\n\nexport default Tree;\n"]},"metadata":{},"sourceType":"module"}