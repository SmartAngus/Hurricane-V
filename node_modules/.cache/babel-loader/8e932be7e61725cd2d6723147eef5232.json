{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar utils_1 = require(\"../Utils/utils\");\n\nvar BaseGroupLayout = function () {\n  function BaseGroupLayout() {}\n\n  BaseGroupLayout.prototype.getNodes = function (nodes) {\n    return nodes.slice().sort(function (nodeA, nodeB) {\n      var nodeAId = Number(nodeA.id);\n      var nodeBId = Number(nodeB.id);\n\n      if (nodeAId < nodeBId) {\n        return -1;\n      } else if (nodeAId > nodeBId) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  BaseGroupLayout.prototype.getGroups = function (groups) {\n    var _this = this;\n\n    return groups.slice().sort(function (groupA, groupB) {\n      var minNodeIdInGroupA = Math.min.apply(Math, tslib_1.__spread(groupA.vertexes.map(function (vertex) {\n        return utils_1.findIndex(_this.nodes, function (node) {\n          return node.id === vertex.id;\n        });\n      })));\n      var minNodeIdInGroupB = Math.min.apply(Math, tslib_1.__spread(groupB.vertexes.map(function (vertex) {\n        return utils_1.findIndex(_this.nodes, function (node) {\n          return node.id === vertex.id;\n        });\n      })));\n\n      if (minNodeIdInGroupA < minNodeIdInGroupB) {\n        return -1;\n      } else if (minNodeIdInGroupA > minNodeIdInGroupB) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  return BaseGroupLayout;\n}();\n\nexports.BaseGroupLayout = BaseGroupLayout;","map":{"version":3,"sources":["../../src/BaseLayout/base.ts"],"names":[],"mappings":";;;;;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAA,eAAA,GAAA,YAAA;AAAA,WAAA,eAAA,GAAA,CA6CC;;AAnCC,EAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,KAAT,EAAgC;AAE9B,WAAO,KAAK,CAAC,KAAN,GAAc,IAAd,CAAmB,UAAC,KAAD,EAAQ,KAAR,EAAa;AACrC,UAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,EAAP,CAAtB;AACA,UAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,EAAP,CAAtB;;AACA,UAAI,OAAO,GAAG,OAAd,EAAuB;AACrB,eAAO,CAAC,CAAR;AACD,OAFD,MAEO,IAAI,OAAO,GAAG,OAAd,EAAuB;AAC5B,eAAO,CAAP;AACD;;AACD,aAAO,CAAP;AACD,KATM,CAAP;AAUD,GAZD;;AAcA,EAAA,eAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,MAAV,EAA0C;AAA1C,QAAA,KAAA,GAAA,IAAA;;AAEE,WAAO,MAAM,CAAC,KAAP,GAAe,IAAf,CAAoB,UAAC,MAAD,EAAS,MAAT,EAAe;AACxC,UAAM,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAQ,KAAR,CAAA,IAAA,EAAI,OAAA,CAAA,QAAA,CACzB,MAAM,CAAC,QAAP,CAAgB,GAAhB,CAAoB,UAAA,MAAA,EAAM;AAC3B,eAAO,OAAA,CAAA,SAAA,CAAU,KAAI,CAAC,KAAf,EAAsB,UAAA,IAAA,EAAI;AAAI,iBAAA,IAAI,CAAC,EAAL,KAAY,MAAM,CAAlB,EAAA;AAAqB,SAAnD,CAAP;AACD,OAFE,CADyB,CAAJ,CAA1B;AAKA,UAAM,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAQ,KAAR,CAAA,IAAA,EAAI,OAAA,CAAA,QAAA,CACzB,MAAM,CAAC,QAAP,CAAgB,GAAhB,CAAoB,UAAA,MAAA,EAAM;AAC3B,eAAO,OAAA,CAAA,SAAA,CAAU,KAAI,CAAC,KAAf,EAAsB,UAAA,IAAA,EAAI;AAAI,iBAAA,IAAI,CAAC,EAAL,KAAY,MAAM,CAAlB,EAAA;AAAqB,SAAnD,CAAP;AACD,OAFE,CADyB,CAAJ,CAA1B;;AAKA,UAAI,iBAAiB,GAAG,iBAAxB,EAA2C;AACzC,eAAO,CAAC,CAAR;AACD,OAFD,MAEO,IAAI,iBAAiB,GAAG,iBAAxB,EAA2C;AAChD,eAAO,CAAP;AACD;;AACD,aAAO,CAAP;AACD,KAjBM,CAAP;AAkBD,GApBD;;AAqBF,SAAA,eAAA;AAAC,CA7CD,EAAA;;AAAa,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"../Utils/utils\");\nvar BaseGroupLayout = (function () {\n    function BaseGroupLayout() {\n    }\n    BaseGroupLayout.prototype.getNodes = function (nodes) {\n        return nodes.slice().sort(function (nodeA, nodeB) {\n            var nodeAId = Number(nodeA.id);\n            var nodeBId = Number(nodeB.id);\n            if (nodeAId < nodeBId) {\n                return -1;\n            }\n            else if (nodeAId > nodeBId) {\n                return 1;\n            }\n            return 0;\n        });\n    };\n    BaseGroupLayout.prototype.getGroups = function (groups) {\n        var _this = this;\n        return groups.slice().sort(function (groupA, groupB) {\n            var minNodeIdInGroupA = Math.min.apply(Math, tslib_1.__spread(groupA.vertexes.map(function (vertex) {\n                return utils_1.findIndex(_this.nodes, function (node) { return node.id === vertex.id; });\n            })));\n            var minNodeIdInGroupB = Math.min.apply(Math, tslib_1.__spread(groupB.vertexes.map(function (vertex) {\n                return utils_1.findIndex(_this.nodes, function (node) { return node.id === vertex.id; });\n            })));\n            if (minNodeIdInGroupA < minNodeIdInGroupB) {\n                return -1;\n            }\n            else if (minNodeIdInGroupA > minNodeIdInGroupB) {\n                return 1;\n            }\n            return 0;\n        });\n    };\n    return BaseGroupLayout;\n}());\nexports.BaseGroupLayout = BaseGroupLayout;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"script"}