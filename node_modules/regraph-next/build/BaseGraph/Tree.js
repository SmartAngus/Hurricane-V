"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("../Utils/utils");
var VIRTUAL_ROOT_ID = Symbol('VIRTUAL_ROOT_ID');
var _TreeVertex = (function () {
    function _TreeVertex(config) {
        this.id = config.id;
        this.type = config.type;
        this.level = config.level;
        this.parentEdge = config.parentEdge;
        this.childrenEdge = config.childrenEdge;
        this.origin = config.origin;
    }
    _TreeVertex.prototype.getParent = function () {
        return this.parentEdge.parent;
    };
    _TreeVertex.prototype.getChildrenOriginNode = function () {
        return this.childrenEdge.map(function (childEdge) {
            return childEdge.child.getOriginNode();
        });
    };
    _TreeVertex.prototype.getOriginNode = function () {
        return this.origin;
    };
    _TreeVertex.prototype.getLevel = function () {
        return this.level;
    };
    _TreeVertex.prototype.getSibling = function () {
        var _this = this;
        var sibling = this.parentEdge.parent.getChildrenOriginNode();
        var index = utils_1.findIndex(sibling, function (item) {
            return item.id === _this.id;
        });
        return {
            pre: sibling.slice(0, index),
            index: index,
            next: sibling.slice(index + 1)
        };
    };
    _TreeVertex.prototype.isVirtualRoot = function () {
        return this.type === 'virtualRoot';
    };
    return _TreeVertex;
}());
var _TreeEdge = (function () {
    function _TreeEdge(config) {
        this.parent = config.parent;
        this.child = config.child;
        this.origin = config.origin;
    }
    return _TreeEdge;
}());
function getRoot(vertexes, edges) {
    var roots = [];
    var _loop_1 = function (i) {
        var id = vertexes[i].id;
        if (edges.filter(function (edge) { return edge.v === id; }).map(function (edge) { return edge.u; }).length === 0) {
            roots.push(vertexes[i]);
        }
    };
    for (var i = 0; i < vertexes.length; i++) {
        _loop_1(i);
    }
    return roots;
}
var Tree = (function () {
    function Tree(vertexes, edges) {
        this.vertexes = [];
        this.edges = [];
        this._tree = null;
        this._treeMap = new Map();
        this._treeReady = false;
        if (Tree.isTree(vertexes, edges) || Tree.isMulti(vertexes, edges)) {
            this.vertexes = vertexes;
            this.edges = edges;
            this._tree = this._createTree();
            return;
        }
        console.error('当前数据无法成树');
    }
    Tree.prototype._createTree = function () {
        var _this = this;
        this._treeReady = false;
        this._treeMap.clear();
        var virtualRoot = this._createVirtualRoot();
        this._treeMap.set(virtualRoot.id, virtualRoot);
        var root = this._getRoot();
        root.forEach(function (node) {
            var treeNode = new _TreeVertex({
                id: node.id,
                type: 'realNode',
                level: virtualRoot.level + 1,
                parentEdge: null,
                childrenEdge: [],
                origin: node
            });
            _this._addChildren(virtualRoot, treeNode);
            _this.dfs(treeNode, function (parent) {
                var children = _this.getChildren(parent.id);
                return children.map(function (child) {
                    return new _TreeVertex({
                        id: child.id,
                        type: 'realNode',
                        level: parent.level + 1,
                        parentEdge: null,
                        childrenEdge: [],
                        origin: child
                    });
                });
            }, function (parent, child) {
                if (child) {
                    _this._addChildren(parent, child);
                }
            });
        });
        this._treeReady = true;
        return virtualRoot;
    };
    Tree.prototype._addChildren = function (parentNode, childNode) {
        var isExistChild = utils_1.find(parentNode.childrenEdge.map(function (childEdge) {
            return childEdge.child;
        }), function (child) {
            return child.id === childNode.id;
        });
        if (!isExistChild) {
            var edge = this.getEdge(parentNode.origin.id, childNode.origin.id);
            parentNode.childrenEdge.push(new _TreeEdge({
                parent: parentNode,
                child: childNode,
                origin: edge
            }));
            childNode.parentEdge = new _TreeEdge({
                parent: parentNode,
                child: childNode,
                origin: edge
            });
            this._treeMap.set(childNode.id, childNode);
        }
    };
    Tree.prototype._createVirtualRoot = function () {
        var id = VIRTUAL_ROOT_ID.toString();
        return new _TreeVertex({
            id: id,
            parentEdge: null,
            type: 'virtualRoot',
            level: 0,
            childrenEdge: [],
            origin: {
                id: id
            }
        });
    };
    Tree.prototype.dfs = function (node, getChildren, beforeCallback, isDfs, callBackResult, afterCallback) {
        var _this = this;
        if (beforeCallback === void 0) { beforeCallback = function () { return undefined; }; }
        if (isDfs === void 0) { isDfs = function () { return true; }; }
        if (callBackResult === void 0) { callBackResult = null; }
        if (afterCallback === void 0) { afterCallback = function () { return undefined; }; }
        if (!isDfs(node.id)) {
            return;
        }
        var children = getChildren(node);
        if (children && children.length) {
            children.forEach(function (child) {
                var result = beforeCallback(node, child, callBackResult);
                _this.dfs(child, getChildren, beforeCallback, isDfs, result, afterCallback);
                afterCallback(node, child, result);
            });
        }
        else {
            var result = beforeCallback(node, null, callBackResult);
            afterCallback(node, null, result);
        }
    };
    Tree.prototype.bfs = function (node, getChildren, callback, isBfs) {
        if (isBfs === void 0) { isBfs = function () { return true; }; }
        if (!isBfs(node.id)) {
            return;
        }
        getChildren(node).forEach(function (child) {
            callback(node, child);
        });
    };
    Tree.prototype._getRoot = function (isVirtual) {
        if (this._treeReady) {
            if (isVirtual) {
                return [this._tree.getOriginNode()];
            }
            return this._tree.getChildrenOriginNode();
        }
        else {
            return getRoot(this.vertexes, this.edges);
        }
    };
    Tree.prototype.getSingleRoot = function () {
        var roots = this._getRoot();
        return roots[0];
    };
    Tree.prototype.getMultiRoot = function () {
        return this._getRoot();
    };
    Tree.prototype.getParent = function (id) {
        if (this._treeReady) {
            if (this._treeMap.has(id)) {
                var parent_1 = this._treeMap.get(id).getParent();
                if (parent_1.isVirtualRoot()) {
                    return null;
                }
                return parent_1.getOriginNode();
            }
            return null;
        }
        else {
            var edgeIdList_1 = this.edges.filter(function (edge) { return edge.v === id; }).map(function (edge) { return edge.u; });
            if (edgeIdList_1.length === 0) {
                return null;
            }
            return utils_1.find(this.vertexes, function (vertex) {
                return edgeIdList_1.indexOf(vertex.id) !== -1;
            });
        }
    };
    Tree.prototype.getEdge = function (parentId, childId) {
        var edges = this.edges.filter(function (edge) {
            return edge.u === parentId && edge.v === childId;
        });
        return edges.length === 0 ? null : edges[0];
    };
    Tree.prototype.getNode = function (id) {
        if (this._treeReady) {
            if (this._treeMap.has(id)) {
                return this._treeMap.get(id).getOriginNode();
            }
            return null;
        }
        else {
            var vertex = this.vertexes.filter(function (vertex) {
                return vertex.id === id;
            });
            return vertex.length === 0 ? null : vertex[0];
        }
    };
    Tree.prototype.getSibling = function (id) {
        if (this._treeReady) {
            if (this._treeMap.has(id)) {
                return this._treeMap.get(id).getSibling();
            }
        }
        return {
            pre: [],
            next: [],
            index: -1
        };
    };
    Tree.prototype.getChildren = function (id) {
        if (this._treeReady) {
            if (this._treeMap.has(id)) {
                return this._treeMap.get(id).getChildrenOriginNode();
            }
            return [];
        }
        else {
            if (id === VIRTUAL_ROOT_ID.toString()) {
                return this._getRoot();
            }
            var edgeIdList_2 = this.edges.filter(function (edge) { return edge.u === id; }).map(function (edge) { return edge.v; });
            return this.vertexes.filter(function (vertex) {
                return edgeIdList_2.indexOf(vertex.id) !== -1;
            });
        }
    };
    Tree.prototype.getLevel = function (id) {
        if (this._treeMap.has(id)) {
            return this._treeMap.get(id).getLevel();
        }
        return null;
    };
    Tree.prototype.getSingleTree = function (id, depth) {
        if (depth === void 0) { depth = -1; }
        if (id && !this._treeMap.has(id)) {
            return null;
        }
        return this.getTree(id, depth)[0];
    };
    Tree.prototype.getTree = function (id, depth) {
        var _this = this;
        if (depth === void 0) { depth = -1; }
        if (id && !this._treeMap.has(id)) {
            return [];
        }
        var nodes = id
            ? [
                tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), { children: [], _origin: this._treeMap.get(id).getOriginNode() })
            ]
            : this._getRoot().map(function (root) {
                return tslib_1.__assign(tslib_1.__assign({}, root), { children: [], _origin: root });
            });
        nodes.forEach(function (node) {
            _this.dfs(node, function (parent) {
                var children = _this.getChildren(parent.id);
                return children.map(function (child) {
                    return tslib_1.__assign(tslib_1.__assign({}, child), { children: [], _origin: child });
                });
            }, function (parent, child) {
                if (child) {
                    parent.children.push(child);
                }
            }, function (id) {
                var currentLevel = _this._treeMap.get(id).getLevel();
                var level = _this._treeMap.get(node.id).getLevel();
                if (depth === -1 || currentLevel - level < depth - 1) {
                    return true;
                }
                return false;
            });
        });
        return nodes;
    };
    Tree.prototype._getTreeByBFS = function (id, depth) {
        var _this = this;
        if (depth === void 0) { depth = -1; }
        if (id && !this._treeMap.has(id)) {
            return [];
        }
        var nodes = id
            ? [
                tslib_1.__assign(tslib_1.__assign({}, this._treeMap.get(id).getOriginNode()), { children: [], _origin: this._treeMap.get(id).getOriginNode() })
            ]
            : this._getRoot().map(function (root) {
                return tslib_1.__assign(tslib_1.__assign({}, root), { children: [], _origin: root });
            });
        this._bfsQueue = tslib_1.__spread(nodes);
        while (this._bfsQueue.length !== 0) {
            var node = this._bfsQueue.shift();
            this.bfs(node, function (parent) {
                return _this.getChildren(parent.id).map(function (child) {
                    return tslib_1.__assign(tslib_1.__assign({}, child), { children: [], _origin: child });
                });
            }, function (parent, child) {
                parent.children.push(child);
                _this._bfsQueue.push(child);
            }, function (id) {
                var currentLevel = _this._treeMap.get(id).getLevel();
                var level = _this._treeMap.get(nodes[0].id).getLevel();
                if (depth === -1 || currentLevel - level < depth - 1) {
                    return true;
                }
                return false;
            });
        }
        return nodes;
    };
    Tree.prototype.getPath = function (ancestorId, childId) {
        var _this = this;
        var ancestor = this.getNode(ancestorId);
        if (!ancestor)
            return [];
        var path = [];
        this.dfs(ancestor, function (p) {
            return _this.getChildren(p.id);
        }, function (p, child, pre) {
            if (child) {
                if (childId === child.id) {
                    path = tslib_1.__spread(pre, [child]);
                }
                return tslib_1.__spread(pre, [child]);
            }
            return pre;
        }, function () {
            return path.length === 0;
        }, [ancestor]);
        return path;
    };
    Tree.prototype.getNodeRelation = function (node1, node2) {
        var root = this._getRoot(true)[0];
        var path1 = this.getPath(root.id, node1);
        var path2 = this.getPath(root.id, node2);
        var commonRoot = path1.reduce(function (pre, item) {
            var node = utils_1.find(path2, function (i) {
                return item.id === i.id;
            });
            if (node) {
                return node;
            }
            return pre;
        }, null);
        if (commonRoot.id === VIRTUAL_ROOT_ID.toString()) {
            return null;
        }
        return commonRoot;
    };
    Tree.prototype._translate = function (vertex) {
        var vertexResult = [vertex._origin];
        var edgeResult = [];
        this.dfs(vertex, function (parent) {
            parent.children.forEach(function (child) {
                vertexResult.push(child._origin);
                edgeResult.push({
                    u: parent.id,
                    v: child.id
                });
            });
            return parent.children;
        }, function () { });
        return {
            vertexes: vertexResult,
            edges: edgeResult
        };
    };
    Tree.prototype.addVertex = function (vertex, parentId) {
        if (parentId === void 0) { parentId = VIRTUAL_ROOT_ID.toString(); }
        if (!this._treeMap.has(parentId)) {
            return;
        }
        this.edges =
            parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{ u: parentId, v: vertex.id }]);
        this.vertexes = tslib_1.__spread(this.vertexes, [vertex]);
        var parent = this._treeMap.get(parentId);
        var newTreeNode = new _TreeVertex({
            id: vertex.id,
            parentEdge: null,
            type: 'realNode',
            level: parent.level + 1,
            childrenEdge: [],
            origin: vertex
        });
        this._addChildren(parent, newTreeNode);
    };
    Tree.prototype.addChildTree = function (vertex, parentId) {
        var _this = this;
        if (parentId === void 0) { parentId = VIRTUAL_ROOT_ID.toString(); }
        if (!this._treeMap.has(parentId)) {
            return;
        }
        this.edges =
            parentId === VIRTUAL_ROOT_ID.toString() ? this.edges : tslib_1.__spread(this.edges, [{ u: parentId, v: vertex.id }]);
        var _a = this._translate(vertex), vertexes = _a.vertexes, edges = _a.edges;
        this.vertexes = tslib_1.__spread(this.vertexes, vertexes);
        this.edges = tslib_1.__spread(this.edges, edges);
        this._treeReady = false;
        var parent = this._treeMap.get(parentId);
        this.dfs(parent, function (parent) {
            var children = _this.getChildren(parent.id);
            return children.map(function (child) {
                return new _TreeVertex({
                    id: child.id,
                    parentEdge: null,
                    type: 'realNode',
                    level: parent.level + 1,
                    childrenEdge: [],
                    origin: child
                });
            });
        }, function (parent, child) {
            if (child) {
                _this._addChildren(parent, child);
            }
        });
        this._treeReady = true;
    };
    Tree.prototype.deleteVertex = function (vertexId) {
        var _this = this;
        if (!this._treeMap.has(vertexId)) {
            return null;
        }
        var childTree = this.getSingleTree(vertexId);
        var parent = this._treeMap.get(vertexId).getParent();
        var _a = this._translate(childTree), vertexes = _a.vertexes, edges = _a.edges;
        this.vertexes = this.vertexes.filter(function (vertex) {
            return utils_1.find(vertexes, function (item) {
                return item.id === vertex.id;
            })
                ? false
                : true;
        });
        this.edges = this.edges.filter(function (edge) {
            return utils_1.find(edges, function (e) {
                return (edge.u === e.u && edge.v === e.v) || (edge.u === parent.id && edge.v === vertexId);
            })
                ? false
                : true;
        });
        vertexes.forEach(function (vertex) {
            _this._treeMap.delete(vertex.id);
        });
        parent.childrenEdge = parent.childrenEdge.filter(function (childEdge) {
            return childEdge.child.id !== vertexId;
        });
        return childTree;
    };
    Tree.prototype.updateVertex = function (vertex) {
        this.vertexes = this.vertexes.map(function (item) {
            if (item.id === vertex.id) {
                return vertex;
            }
            return item;
        });
        if (this._treeMap.has(vertex.id)) {
            var oldVertex = this._treeMap.get(vertex.id);
            oldVertex.origin = vertex;
        }
    };
    Tree.prototype.updateEdge = function (edge) {
        this.edges = this.edges.map(function (e) {
            if (e.u === edge.u && e.v === edge.v) {
                return edge;
            }
            return e;
        });
    };
    Tree.prototype.deleteEdge = function (u, v) {
        if (!this._treeMap.has(u) || !this._treeMap.has(v)) {
            return null;
        }
        this.edges = this.edges.filter(function (edge) {
            return edge.u !== u && edge.v !== edge.v;
        });
        return this.deleteVertex(v);
    };
    Tree.prototype.getVertexes = function () {
        return this.vertexes;
    };
    Tree.prototype.getEdges = function () {
        return this.edges;
    };
    Tree.prototype.getLeafVertexes = function (id, depth) {
        var _this = this;
        if (depth === void 0) { depth = -1; }
        var vertexes = this._translate(this._getTreeByBFS(id, depth)[0]).vertexes;
        return vertexes.filter(function (node) {
            return _this.getChildren(node.id).length === 0;
        });
    };
    return Tree;
}());
Tree.isTree = function (vertexes, edges) {
    var visitedList = [];
    function dfs(node) {
        if (visitedList.indexOf(node.id) !== -1) {
            return false;
        }
        visitedList.push(node.id);
        var edgeIdList = edges.filter(function (edge) { return edge.u === node.id; }).map(function (edge) { return edge.v; });
        var children = vertexes.filter(function (vertex) {
            return edgeIdList.indexOf(vertex.id) !== -1;
        });
        for (var i = 0; i < children.length; i++) {
            if (!dfs(children[i])) {
                return false;
            }
        }
        return true;
    }
    if (vertexes.length !== edges.length + 1) {
        return false;
    }
    var roots = getRoot(vertexes, edges);
    if (roots.length === 1) {
        return dfs(roots[0]);
    }
    return false;
};
Tree.isMulti = function (vertexes, edges) {
    var roots = getRoot(vertexes, edges);
    if (roots.length <= 1) {
        return false;
    }
    var virtualRootId = VIRTUAL_ROOT_ID.toString();
    return Tree.isTree(tslib_1.__spread(vertexes, [{ id: virtualRootId }]), tslib_1.__spread(edges, roots.map(function (node) {
        return {
            u: virtualRootId,
            v: node.id
        };
    })));
};
Tree.parse = function (tree, getId, getChildren, getEdge) {
    var getIdHandler = getId
        ? getId
        : function (node) {
            return node.id;
        };
    var getChildrenHandler = getChildren
        ? getChildren
        : function (node) {
            return node.children;
        };
    var vertexes = [];
    var edges = [];
    var visitedList = [];
    function dfs(node) {
        var id = getIdHandler(node);
        node.id = id;
        if (visitedList.indexOf(id) !== -1) {
            console.error('存在环！');
            return false;
        }
        visitedList.push(id);
        vertexes.push(node);
        var children = getChildrenHandler(node);
        if (children && children.length) {
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var childId = getIdHandler(child);
                child.id = childId;
                var edge = getEdge
                    ? getEdge(node, child)
                    : {
                        u: id,
                        v: childId
                    };
                edges.push(edge);
                dfs(child);
            }
        }
    }
    for (var i = 0; i < tree.length; i++) {
        dfs(tree[i]);
    }
    return {
        vertexes: vertexes,
        edges: edges
    };
};
exports.default = Tree;
//# sourceMappingURL=Tree.js.map