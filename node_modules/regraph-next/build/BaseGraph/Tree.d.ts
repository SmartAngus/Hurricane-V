import { OutputVertex } from './type';
import { BaseVertex, BaseEdge, Vertex, Edge } from '../type';
declare class _TreeVertex<V, E> {
    id: string;
    type: 'virtualRoot' | 'realNode';
    level: number;
    parentEdge: _TreeEdge<V, E>;
    childrenEdge: _TreeEdge<V, E>[];
    origin: V;
    constructor(config: {
        id: string;
        type: 'virtualRoot' | 'realNode';
        level: number;
        parentEdge: _TreeEdge<V, E>;
        childrenEdge: _TreeEdge<V, E>[];
        origin: V;
    });
    getParent(): _TreeVertex<V, E>;
    getChildrenOriginNode(): V[];
    getOriginNode(): V;
    getLevel(): number;
    getSibling(): {
        pre: V[];
        index: number;
        next: V[];
    };
    isVirtualRoot(): boolean;
}
declare class _TreeEdge<V, E> {
    parent: _TreeVertex<V, E>;
    child: _TreeVertex<V, E>;
    origin: E;
    constructor(config: {
        parent: _TreeVertex<V, E>;
        child: _TreeVertex<V, E>;
        origin: E;
    });
}
declare class Tree<V extends BaseVertex, E extends BaseEdge> {
    static isTree: (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>) => boolean;
    static isMulti: (vertexes: Array<Vertex<BaseVertex>>, edges: Array<Edge<BaseEdge>>) => boolean;
    static parse: <V extends BaseVertex, E extends BaseEdge>(tree: V[], getId?: (node: V) => string, getChildren?: (node: V) => V[], getEdge?: (parent: V, child: V) => E) => {
        vertexes: Array<Vertex<V>>;
        edges: Array<Edge<E>>;
    };
    private vertexes;
    private edges;
    private _tree;
    private _treeMap;
    private _treeReady;
    private _bfsQueue;
    constructor(vertexes: Array<Vertex<V>>, edges: Array<Edge<E>>);
    _createTree(): _TreeVertex<V, E>;
    _addChildren(parentNode: _TreeVertex<V, E>, childNode: _TreeVertex<V, E>): void;
    _createVirtualRoot(): _TreeVertex<V, E>;
    dfs<N extends {
        id: string;
    }, R>(node: N, getChildren: (parent: N) => N[], beforeCallback?: (parent: N, child: N, preCallBackResult: R) => R, isDfs?: (id: string) => boolean, callBackResult?: R, afterCallback?: (parent: N, child: N, preCallBackResult: R) => void): void;
    bfs<N extends {
        id: string;
    }>(node: N, getChildren: (parent: N) => N[], callback: (parent: N, child: N) => void, isBfs?: (id: string) => boolean): void;
    _getRoot(isVirtual?: boolean): V[];
    getSingleRoot(): V;
    getMultiRoot(): V[];
    getParent(id: string): V;
    getEdge(parentId: string, childId: string): E;
    getNode(id: string): V;
    getSibling(id: string): {
        pre: V[];
        next: V[];
        index: number;
    };
    getChildren(id: string): V[];
    getLevel(id: string): number;
    getSingleTree(id?: string, depth?: number): OutputVertex<V>;
    getTree(id?: string, depth?: number): OutputVertex<V>[];
    _getTreeByBFS(id?: string, depth?: number): OutputVertex<V>[];
    getPath(ancestorId: string, childId: string): V[];
    getNodeRelation(node1: string, node2: string): V;
    _translate(vertex: OutputVertex<V>): {
        vertexes: V[];
        edges: E[];
    };
    addVertex(vertex: V, parentId?: string): void;
    addChildTree(vertex: OutputVertex<V>, parentId?: string): void;
    deleteVertex(vertexId: string): OutputVertex<V>;
    updateVertex(vertex: V): void;
    updateEdge(edge: E): void;
    deleteEdge(u: string, v: string): OutputVertex<V>;
    getVertexes(): Vertex<V>[];
    getEdges(): Edge<E>[];
    getLeafVertexes(id?: string, depth?: number): V[];
}
export default Tree;
