"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var type_1 = require("./type");
var utils_1 = require("../Utils/utils");
var _GraphVertex = (function () {
    function _GraphVertex(config) {
        this.edges = [];
        this.id = config.id;
        this.edges = config.edges;
        this.origin = config.origin;
    }
    _GraphVertex.prototype.getEdge = function (id, isDirect) {
        if (isDirect) {
            return utils_1.find(this.edges, function (edge) {
                return edge.v.id === id;
            }) || null;
        }
        return utils_1.find(this.edges, function (edge) {
            return edge.u.id === id || edge.v.id === id;
        }) || null;
    };
    _GraphVertex.prototype.getEdges = function (isDirect, direct) {
        var _this = this;
        if (direct === void 0) { direct = 'out'; }
        if (isDirect) {
            return this.edges.filter(function (edge) {
                if (direct === 'out') {
                    return edge.u.id === _this.id;
                }
                return edge.v.id === _this.id;
            });
        }
        return this.edges;
    };
    _GraphVertex.prototype.getAdjacentVertexes = function (isDirect, direct) {
        var _this = this;
        if (direct === void 0) { direct = 'out'; }
        if (isDirect) {
            return this.getEdges(isDirect, direct).map(function (edge) {
                return edge.u.id === _this.id ? edge.v : edge.u;
            });
        }
        return this.edges.map(function (edge) {
            return edge.u.id === _this.id ? edge.v : edge.u;
        });
    };
    return _GraphVertex;
}());
var _GraphEdge = (function () {
    function _GraphEdge(config) {
        this.u = config.u;
        this.v = config.v;
        this.origin = config.origin;
    }
    return _GraphEdge;
}());
var Graph = (function () {
    function Graph(vertexes, edges, graphConfig) {
        if (graphConfig === void 0) { graphConfig = type_1.defaultGraphConfig; }
        this.vertexes = [];
        this.edges = [];
        this._graph = [];
        this._graphMap = new Map();
        this.visited = [];
        this.vertexes = vertexes;
        this.edges = edges;
        this.graphConfig = graphConfig;
        if (!this.graphConfig.isDirect) {
        }
        this._graph = this._createGraph();
    }
    Graph.prototype._createGraph = function () {
        var _this = this;
        this._graphReady = false;
        this._graphMap.clear();
        var vertexes = this.vertexes.map(function (vertex) {
            return new _GraphVertex({
                id: vertex.id,
                edges: [],
                origin: vertex,
            });
        });
        vertexes.forEach(function (vertex) {
            _this._graphMap.set(vertex.id, vertex);
        });
        this.edges.forEach(function (edge) {
            var u = edge.u, v = edge.v;
            var uVertex = _this.getVertex(u);
            var vVertex = _this.getVertex(v);
            var graphEdge = new _GraphEdge({
                u: uVertex,
                v: vVertex,
                origin: edge,
            });
            uVertex.edges.push(graphEdge);
            vVertex.edges.push(graphEdge);
        });
        this._graphReady = true;
        return vertexes;
    };
    Graph.prototype._defaultIsDfs = function (id) {
        if (this.visited.includes(id)) {
            return false;
        }
        this.visited.push(id);
        return true;
    };
    Graph.prototype.dfs = function (vertex, getAdjacentVertexes, callback, isDfs, callBackResult, _isFirst) {
        var _this = this;
        if (isDfs === void 0) { isDfs = function () { return true; }; }
        if (callBackResult === void 0) { callBackResult = null; }
        if (_isFirst === void 0) { _isFirst = true; }
        if (_isFirst) {
            this.visited = [];
        }
        if (!isDfs(vertex.id) || !this._defaultIsDfs(vertex.id)) {
            return;
        }
        getAdjacentVertexes(vertex).forEach(function (node, index) {
            var result = callback(vertex, node, callBackResult, index);
            _this.dfs(node, getAdjacentVertexes, callback, isDfs, result, false);
        });
        if (_isFirst) {
            this.visited = [];
        }
    };
    Graph.prototype.getEdge = function (u, v) {
        if (!this._graphMap.has(u) || !this._graphMap.has(v)) {
            return null;
        }
        var graphNode = this._graphMap.get(u);
        return graphNode.getEdge(v, this.graphConfig.isDirect);
    };
    Graph.prototype.getVertex = function (id) {
        if (!this._graphMap.has(id)) {
            return null;
        }
        return this._graphMap.get(id);
    };
    Graph.prototype.getAdjacentVertexes = function (id, direct) {
        if (direct === void 0) { direct = 'out'; }
        if (!this._graphMap.has(id)) {
            return [];
        }
        return this._graphMap.get(id).getAdjacentVertexes(this.graphConfig.isDirect, direct);
    };
    Graph.prototype.getGraph = function (nodeId) {
        var _this = this;
        var id = nodeId || this.vertexes[0].id;
        if (!this._graphMap.has(id)) {
            return null;
        }
        var source = this._graphMap.get(id);
        var tempNodeMap = new Map();
        var vertexes = tslib_1.__assign(tslib_1.__assign({}, source.origin), { _id: source.id, _relations: [] });
        tempNodeMap.set(source.id, vertexes);
        this.dfs(vertexes, function (vertex) {
            var _graphNode = _this._graphMap.get(vertex.id);
            _graphNode.getEdges(_this.graphConfig.isDirect).forEach(function (edge) {
                vertex._relations.push(tslib_1.__assign(tslib_1.__assign({}, edge.origin), { _u: null, _v: null, _origin: edge.origin }));
            });
            return _graphNode.getAdjacentVertexes(_this.graphConfig.isDirect).map(function (_node) {
                if (tempNodeMap.has(_node.id)) {
                    return tempNodeMap.get(_node.id);
                }
                var node = tslib_1.__assign(tslib_1.__assign({}, _node.origin), { _id: _node.id, _relations: [], _origin: _node.origin });
                tempNodeMap.set(_node.id, node);
                return node;
            });
        }, function (source, target) {
            var relation = utils_1.find(source._relations, function (relation) {
                return relation.u === source._id && relation.v === target._id;
            });
            relation._u = source;
            relation._v = target;
        });
        tempNodeMap.clear();
        return vertexes;
    };
    Graph.prototype.updateVertex = function (vertex) {
        if (!this._graphMap.has(vertex.id)) {
            return;
        }
        var curVertex = this._graphMap.get(vertex.id);
        curVertex.origin = vertex;
        this.vertexes = this.vertexes.map(function (node) {
            return node.id === vertex.id ? vertex : node;
        });
    };
    Graph.prototype.updateEdge = function (edge) {
        if (!this._graphMap.has(edge.v) || !this._graphMap.has(edge.u)) {
            return;
        }
        var curU = this._graphMap.get(edge.u);
        var curEdge = curU.getEdge(edge.v, this.graphConfig.isDirect);
        if (curEdge) {
            curEdge.origin = edge;
            this.edges = this.edges.map(function (e) {
                if (e.u === edge.u && e.v === edge.v) {
                    return edge;
                }
                return e;
            });
        }
    };
    Graph.prototype.updateGraph = function (vertexes, edges, changeVertex, changeEdge) {
        var _this = this;
        if (changeVertex === void 0) { changeVertex = function (newV) { return newV; }; }
        if (changeEdge === void 0) { changeEdge = function (newE) { return newE; }; }
        this._graphReady = false;
        var newVertexes = vertexes.map(function (vertex) {
            if (_this._graphMap.has(vertex.id)) {
                var oldVertex = _this._graphMap.get(vertex.id).origin;
                var newVertex = changeVertex(vertex, oldVertex);
                _this.updateVertex(newVertex);
                return _this._graphMap.get(vertex.id);
            }
            _this.vertexes.push(vertex);
            return new _GraphVertex({
                id: vertex.id,
                edges: [],
                origin: vertex,
            });
        });
        newVertexes.forEach(function (vertex) {
            if (!_this._graphMap.has(vertex.id)) {
                _this._graphMap.set(vertex.id, vertex);
            }
        });
        edges.forEach(function (edge) {
            var u = edge.u, v = edge.v;
            var uVertex = _this.getVertex(u);
            var vVertex = _this.getVertex(v);
            if (!_this.getEdge(u, v)) {
                var graphEdge = new _GraphEdge({
                    u: uVertex,
                    v: vVertex,
                    origin: edge,
                });
                _this.edges.push(edge);
                uVertex.edges.push(graphEdge);
                vVertex.edges.push(graphEdge);
            }
            else {
                var oldEdge = _this.getEdge(u, v).origin;
                var newEdge = changeEdge(edge, oldEdge);
                _this.updateEdge(newEdge);
            }
        });
        this._graphReady = true;
    };
    return Graph;
}());
exports.default = Graph;
//# sourceMappingURL=Graph.js.map