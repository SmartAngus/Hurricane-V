"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var d3_zoom_1 = require("d3-zoom");
var d3Select = require("d3-selection");
var utils_1 = require("./utils");
require("./ReScreen.css");
var MINI_MAP_RATIO = 0.9;
var ANIMATION_TIME = 500;
var ButtonsProps = (function () {
    function ButtonsProps() {
    }
    return ButtonsProps;
}());
exports.ButtonsProps = ButtonsProps;
var MiniMapProps = (function () {
    function MiniMapProps() {
    }
    return MiniMapProps;
}());
var Props = (function () {
    function Props() {
        this.onClick = function () { };
        this.onContextMenu = function () { };
        this.onDragOver = function () { };
        this.onDrop = function () { };
    }
    return Props;
}());
var State = (function () {
    function State() {
    }
    return State;
}());
var ReScreen = (function (_super) {
    tslib_1.__extends(ReScreen, _super);
    function ReScreen(props) {
        var _this = _super.call(this, props) || this;
        _this.useMapWidth = true;
        _this.screenWidth = 0;
        _this.screenHeight = 0;
        _this.screenTransform = d3_zoom_1.zoomIdentity;
        _this.minimapTransform = d3_zoom_1.zoomIdentity;
        _this.transform = d3_zoom_1.zoomIdentity;
        _this.state = {
            screenToMapTransform: d3_zoom_1.zoomIdentity,
            animation: false,
            showMiniMap: false
        };
        _this.handleSyncMiniMapView = function () {
            _this.getScreenToMapTransform();
        };
        _this.getScreenToMapTransform = function () {
            var BBox = _this.getBBox();
            var _a = _this.props, type = _a.type, mapWidth = _a.mapWidth, mapHeight = _a.mapHeight, contentRange = _a.contentRange;
            var x = BBox.x;
            var y = BBox.y;
            _this.useMapWidth = (mapWidth / BBox.width) * BBox.height < mapHeight;
            var k = (_this.useMapWidth ? mapWidth / BBox.width : mapHeight / BBox.height) * MINI_MAP_RATIO;
            var screenToMapTransform;
            if (contentRange && contentRange.length === 2) {
                var x_1 = mapWidth / 2 - (contentRange[0].x + contentRange[1].x) / 2;
                var y_1 = mapHeight / 2 - (contentRange[0].y + contentRange[1].y) / 2;
                var P0 = [mapWidth / 2, mapHeight / 2];
                var P1 = d3_zoom_1.zoomIdentity
                    .translate(x_1, y_1)
                    .scale(1)
                    .invert(P0);
                screenToMapTransform = d3_zoom_1.zoomIdentity.translate(P0[0] - P1[0] * k, P0[1] - P1[1] * k).scale(k);
            }
            else if (type === 'SVG') {
                var xx = -1 * _this.transform.invertX(x);
                var yy = -1 * _this.transform.invertY(y);
                screenToMapTransform = d3_zoom_1.zoomIdentity.translate(xx, yy).scale(k * _this.transform.k);
            }
            else if (type === 'DOM') {
                screenToMapTransform = d3_zoom_1.zoomIdentity.translate(-x, -y).scale(k);
            }
            _this.setState({
                screenToMapTransform: screenToMapTransform
            }, _this.props.resetNeedRefresh);
            _this.props.needMinimap && _this.clReScreenContent(screenToMapTransform);
        };
        _this.applyTransform = function (transform) {
            var _a = _this.props, type = _a.type, mapRectStyle = _a.mapRectStyle;
            var screenToMapTransform = _this.state.screenToMapTransform;
            if (type === 'SVG') {
                _this.screenContent &&
                    _this.screenContent.attr('transform', "translate(" + transform.x + ", " + transform.y + ") scale(" + transform.k + ")");
            }
            else if (type === 'DOM') {
                _this.screenContent &&
                    _this.screenContent.style('transform', "translate(" + transform.x + "px, " + transform.y + "px) scale(" + transform.k + ")");
                _this.screenContent && _this.screenContent.style('transform-origin', '0 0');
            }
            _this.transform = d3_zoom_1.zoomIdentity.translate(transform.x, transform.y).scale(transform.k);
            if (_this.rectRef.current) {
                var strokeWidth = (mapRectStyle || {}).strokeWidth;
                _this.rectRef.current.style.x = -_this.transform.x;
                _this.rectRef.current.style.y = -_this.transform.y;
                _this.rectRef.current.style.transform = "scale(" + 1 / transform.k + ")";
                _this.rectRef.current.style.strokeWidth =
                    strokeWidth !== undefined ? strokeWidth * (1 / screenToMapTransform.k) * transform.k : undefined;
            }
            var showMiniMap = _this.checkShowMiniMap();
            if (showMiniMap !== _this.state.showMiniMap) {
                _this.setState({
                    showMiniMap: showMiniMap
                }, function () {
                    _this.cancelAnimation();
                });
            }
        };
        _this.handleApplyTransform = function (transform) {
            _this.screen.call(_this.screenZoom.transform, d3_zoom_1.zoomIdentity.translate(transform.x, transform.y).scale(transform.k));
            _this.minimap && _this.minimap.call(_this.mapZoom.transform, d3_zoom_1.zoomIdentity);
        };
        _this.handleFullScreen = function () {
            var isFull = document.fullscreenElement || document.webkitFullscreenElement;
            if (isFull) {
                utils_1.exitFullscreen();
            }
            else {
                utils_1.requestFullscreen(_this.screenDOM);
            }
        };
        _this.handleResetPosition = function () {
            _this.screen.call(_this.screenZoom.transform, d3_zoom_1.zoomIdentity);
            _this.minimap && _this.minimap.call(_this.mapZoom.transform, d3_zoom_1.zoomIdentity);
        };
        _this.handleShowAll = function () {
            console.warn('handleShowAll 计划下线，适应画布请添加 contentRange 使用 handleAdapt 方法');
            var _a = _this.props, mapWidth = _a.mapWidth, mapHeight = _a.mapHeight;
            var screenToMapTransform = _this.state.screenToMapTransform;
            var scale = screenToMapTransform.k * (_this.useMapWidth ? _this.screenWidth / mapWidth : _this.screenHeight / mapHeight);
            _this.screen.call(_this.screenZoom.transform, d3_zoom_1.zoomIdentity.scale(scale).translate(screenToMapTransform.x, screenToMapTransform.y));
            _this.minimap && _this.minimap.call(_this.mapZoom.transform, d3_zoom_1.zoomIdentity);
        };
        _this.handleAdapt = function () {
            var contentRange = _this.props.contentRange;
            if (!(contentRange && contentRange.length === 2)) {
                console.warn('请正确传入 contentRange 值');
                return;
            }
            var componentWidth = contentRange[1].x - contentRange[0].x;
            var componentHeight = contentRange[1].y - contentRange[0].y;
            var x = _this.screenWidth / 2 - (contentRange[0].x + contentRange[1].x) / 2;
            var y = _this.screenHeight / 2 - (contentRange[0].y + contentRange[1].y) / 2;
            var scale = Math.min((_this.screenWidth / componentWidth) * MINI_MAP_RATIO, (_this.screenHeight / componentHeight) * MINI_MAP_RATIO, 1);
            var P0 = [_this.screenWidth / 2, _this.screenHeight / 2];
            var P1 = d3_zoom_1.zoomIdentity
                .translate(x, y)
                .scale(1)
                .invert(P0);
            var newTransform = d3_zoom_1.zoomIdentity.translate(P0[0] - P1[0] * scale, P0[1] - P1[1] * scale).scale(scale);
            _this.handleApplyTransform(newTransform);
        };
        _this.handleResetStatus = function () {
            setTimeout(function () {
                _this.getScreenToMapTransform();
                _this.handleResetPosition();
            }, 100);
        };
        _this.handleResize = function (isLarger) {
            var RATE = isLarger ? 1.2 : 0.8;
            var newScale = _this.transform.k * RATE;
            _this.handleResizeTo(newScale / _this.minimapTransform.k);
        };
        _this.handleResizeTo = function (newScale, P0) {
            var screenScale = newScale * _this.minimapTransform.k;
            if (!P0) {
                P0 = [_this.screenWidth / 2, _this.screenHeight / 2];
            }
            var P1 = _this.transform.invert(P0);
            _this.screen.call(_this.screenZoom.transform, d3_zoom_1.zoomIdentity
                .translate(P0[0] - P1[0] * screenScale, P0[1] - P1[1] * screenScale)
                .scale(screenScale));
            _this.minimap && _this.minimap.call(_this.mapZoom.transform, d3_zoom_1.zoomIdentity);
        };
        _this.handleLocation = function (point) {
            _this.setState({
                animation: true
            }, function () {
                var k = _this.transform.k;
                var newTransform = d3_zoom_1.zoomIdentity
                    .translate(-point.x * k + _this.screenWidth / 2, -point.y * k + _this.screenHeight / 2)
                    .scale(k);
                _this.handleApplyTransform(newTransform);
            });
        };
        _this.handleFocusTarget = function (evt, focusEnabled) {
            if (_this.props.focusEnabled !== focusEnabled) {
                return;
            }
            var e = evt.currentTarget;
            var dim = e.getBoundingClientRect();
            var x = evt.clientX - dim.left;
            var y = evt.clientY - dim.top;
            var _a = _this.state.screenToMapTransform, tx = _a.x, ty = _a.y, k = _a.k;
            var cx = x / k - tx;
            var cy = y / k - ty;
            _this.minimap.call(_this.mapZoom.transform, d3_zoom_1.zoomIdentity);
            _this.screenTransform = _this.transform;
            var tx1 = _this.screenWidth / 2 - _this.transform.k * cx;
            var ty1 = _this.screenHeight / 2 - _this.transform.k * cy;
            _this.screen.call(_this.screenZoom.transform, d3_zoom_1.zoomIdentity.translate(tx1, ty1).scale(_this.transform.k));
        };
        _this.rectRef = React.createRef();
        return _this;
    }
    ReScreen.prototype.componentDidMount = function () {
        this.init();
        this.initEvent();
        this.bindZoom();
        this.getScreenHandler();
        this.setState({
            showMiniMap: this.checkShowMiniMap()
        });
    };
    ReScreen.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.needRefresh) {
            this.getScreenToMapTransform();
        }
    };
    ReScreen.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (this.state.showMiniMap !== prevState.showMiniMap) {
            if (this.props.autoHideMiniMap && this.props.onMiniMapShowAndHide) {
                this.props.onMiniMapShowAndHide(this.state.showMiniMap);
            }
        }
        if (this.props.contentRange &&
            this.props.contentRange.length &&
            (prevProps.contentRange.length !== this.props.contentRange.length ||
                prevProps.contentRange[0].x !== this.props.contentRange[0].x ||
                prevProps.contentRange[0].y !== this.props.contentRange[0].y ||
                prevProps.contentRange[1].x !== this.props.contentRange[1].x ||
                prevProps.contentRange[1].y !== this.props.contentRange[1].y)) {
            this.getScreenToMapTransform();
        }
    };
    ReScreen.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.handleBrowserResizeFn);
    };
    ReScreen.prototype.init = function () {
        this.getScreenSize();
        this.getScreenToMapTransform();
    };
    ReScreen.prototype.initEvent = function () {
        this.handleBrowserResizeFn = this.init.bind(this);
        window.addEventListener('resize', this.handleBrowserResizeFn);
    };
    ReScreen.prototype.getScreenHandler = function () {
        var getScreenHandler = this.props.getScreenHandler;
        if (getScreenHandler) {
            getScreenHandler({
                handleFullScreen: this.handleFullScreen,
                handleResetPosition: this.handleResetPosition,
                handleShowAll: this.handleShowAll,
                handleResetStatus: this.handleResetStatus,
                handleResize: this.handleResize,
                handleResizeTo: this.handleResizeTo,
                handleFocusTarget: this.handleFocusTarget,
                handleApplyTransform: this.handleApplyTransform,
                handleAdapt: this.handleAdapt,
                handleLocation: this.handleLocation,
                screenWidth: this.screenWidth,
                screenHeight: this.screenHeight,
                handleSyncMiniMapView: this.handleSyncMiniMapView
            });
        }
    };
    ReScreen.prototype.filter = function (isMiniMap) {
        var enabled = isMiniMap ? this.props.miniMapZoomEnabled : this.props.zoomEnabled;
        if (!enabled) {
            return d3Select.event.type !== 'wheel';
        }
        return !d3Select.event.button;
    };
    ReScreen.prototype.bindZoom = function () {
        var _this = this;
        var _a = this.props, scaleExtent = _a.scaleExtent, translateExtent = _a.translateExtent, draggable = _a.draggable;
        this.screenZoom = d3_zoom_1.zoom()
            .filter(this.filter.bind(this, false))
            .scaleExtent(scaleExtent ? scaleExtent : [0, Infinity])
            .translateExtent(translateExtent
            ? translateExtent
            : [
                [-Infinity, -Infinity],
                [Infinity, Infinity]
            ])
            .on('zoom', function () {
            var scale = d3Select.event.transform.k / _this.minimapTransform.k;
            if (!_this.isZoomValid(scale)) {
                return _this.screen.call(_this.screenZoom.transform, _this.screenTransform);
            }
            if (draggable) {
                _this.screenTransform = d3Select.event.transform;
                _this.handleScreenChange();
            }
        });
        this.screen && this.screen.call(this.screenZoom).on('dblclick.zoom', null);
        if (this.props.needMinimap) {
            this.mapZoom = d3_zoom_1.zoom()
                .filter(this.filter.bind(this, true))
                .on('zoom', function () {
                var scale = _this.screenTransform.k / d3Select.event.transform.k;
                if (!_this.isZoomValid(scale)) {
                    return _this.minimap.call(_this.mapZoom.transform, _this.minimapTransform);
                }
                if (draggable) {
                    _this.minimapTransform = d3Select.event.transform;
                    _this.handleScreenChange();
                }
            });
            this.minimap && this.minimap.call(this.mapZoom).on('dblclick.zoom', null);
        }
    };
    ReScreen.prototype.isZoomValid = function (newScale) {
        var currentScale = this.transform.k;
        if (newScale <= this.props.minZoom && newScale < currentScale) {
            return false;
        }
        if (newScale >= this.props.maxZoom && newScale > currentScale) {
            return false;
        }
        return true;
    };
    ReScreen.prototype.getScreenSize = function () {
        if (!this.ReScreenDOM) {
            return;
        }
        var ReScreenWidth = this.ReScreenDOM.clientWidth;
        var ReScreenHeight = this.ReScreenDOM.clientHeight;
        var _a = this.props, needMinimap = _a.needMinimap, mapPosition = _a.mapPosition, mapWidth = _a.mapWidth, mapHeight = _a.mapHeight, mapPadding = _a.mapPadding;
        if (mapPosition.includes('IN')) {
            this.screenWidth = ReScreenWidth;
            this.screenHeight = ReScreenHeight;
        }
        else {
            this.screenWidth = needMinimap ? ReScreenWidth - mapWidth - mapPadding : ReScreenWidth;
            this.screenHeight = ReScreenHeight;
        }
        if (this.screenWidth < 0) {
            this.screenWidth = 0;
        }
    };
    ReScreen.prototype.getBBox = function () {
        var _a = this.props, type = _a.type, contentRange = _a.contentRange;
        if (contentRange && contentRange.length === 2) {
            return {
                x: contentRange[0].x,
                y: contentRange[0].y,
                width: contentRange[1].x - contentRange[0].x,
                height: contentRange[1].y - contentRange[0].y
            };
        }
        if (type === 'SVG') {
            return this.screenDOM && this.screenDOM.getBBox();
        }
        else if (type === 'DOM') {
            return {
                x: 0,
                y: 0,
                width: this.screenDOM.firstChild.scrollWidth,
                height: this.screenDOM.firstChild.scrollHeight
            };
        }
    };
    ReScreen.prototype.handleScreenChange = function () {
        var screenTransform = this.screenTransform;
        var minimapTransform = this.minimapTransform;
        var transform = d3_zoom_1.zoomIdentity
            .translate(screenTransform.x, screenTransform.y)
            .scale(screenTransform.k)
            .translate((-1 * minimapTransform.x) / minimapTransform.k, (-1 * minimapTransform.y) / minimapTransform.k)
            .scale(1 / minimapTransform.k);
        var finalTransform;
        if (this.props.dragDirection === 'HOR') {
            finalTransform = d3_zoom_1.zoomIdentity.translate(transform.x, 0).scale(transform.k);
        }
        else if (this.props.dragDirection === 'VER') {
            finalTransform = d3_zoom_1.zoomIdentity.translate(0, transform.y).scale(transform.k);
        }
        else {
            finalTransform = transform;
        }
        var onScreenChange = this.props.onScreenChange;
        this.applyTransform(finalTransform);
        onScreenChange && onScreenChange(finalTransform);
    };
    ReScreen.prototype.cancelAnimation = function () {
        var _this = this;
        setTimeout(function () {
            _this.setState({
                animation: false
            });
        }, ANIMATION_TIME);
    };
    ReScreen.prototype.renderButtons = function (Buttons) {
        return React.cloneElement(Buttons, {
            handleFullScreen: this.handleFullScreen,
            handleResetPosition: this.handleResetPosition,
            handleShowAll: this.handleShowAll,
            handleResetStatus: this.handleResetStatus,
            handleResize: this.handleResize,
            screenWidth: this.screenWidth,
            screenHeight: this.screenHeight
        });
    };
    ReScreen.prototype.clReScreenContent = function (screenToMapTransform) {
        if (this.props.minimap || !this.screenDOM) {
            return;
        }
        var screenToMap = "scale(" + screenToMapTransform.k + ") translate(" + screenToMapTransform.x + ", " + screenToMapTransform.y + ")";
        var screenContent = this.screenDOM.cloneNode(true);
        screenContent.style.height = '100%';
        screenContent.style.width = '100%';
        if (this.props.type === 'SVG') {
            screenContent.firstChild.setAttribute('transform', screenToMap);
        }
        else {
            screenContent.firstChild.style.transform = "translate(" + screenToMapTransform.x + "px, " + screenToMapTransform.y + "px) scale(" + screenToMapTransform.k + ")";
            screenContent.firstChild.style.transformOrigin = '0 0';
        }
        var targetNode = document.getElementById('minimap');
        targetNode.innerHTML = '';
        targetNode.appendChild(screenContent);
    };
    ReScreen.prototype.renderCustomMiniMap = function () {
        var screenToMapTransform = this.state.screenToMapTransform;
        var transform = this.transform;
        var screenToMap = "translate(" + screenToMapTransform.x + "px, " + screenToMapTransform.y + "px) scale(" + screenToMapTransform.k + ")";
        if (!this.props.minimap) {
            return null;
        }
        return (React.createElement("div", { style: {
                transform: screenToMap,
                transformOrigin: '0 0'
            } },
            typeof this.props.minimap === 'function'
                ? this.props.minimap({
                    screenToMapTransform: screenToMapTransform,
                    transform: transform
                })
                : React.cloneElement(this.props.minimap, {
                    screenToMapTransform: screenToMapTransform,
                    transform: transform
                }),
            ">"));
    };
    ReScreen.prototype.checkShowMiniMap = function () {
        var _a = this.props, contentRange = _a.contentRange, autoHideMiniMap = _a.autoHideMiniMap, needMinimap = _a.needMinimap;
        var transform = this.transform;
        if (!needMinimap) {
            return false;
        }
        if (!(contentRange && contentRange.length === 2)) {
            console.warn('请正确传入 contentRange 值');
            return true;
        }
        if (!autoHideMiniMap) {
            return true;
        }
        var k = transform.k, x = transform.x, y = transform.y;
        var currRange = [
            { x: (0 - x) / k, y: (0 - y) / k },
            { x: (this.screenWidth - x) / k, y: (this.screenHeight - y) / k }
        ];
        if (currRange[0].x < contentRange[0].x &&
            currRange[0].y < contentRange[0].y &&
            currRange[1].x > contentRange[1].x &&
            currRange[1].y > contentRange[1].y) {
            return false;
        }
        return true;
    };
    ReScreen.prototype.renderMinimap = function (mapWidth, mapHeight, mapPosition) {
        var _this = this;
        var _a = this.state, screenToMapTransform = _a.screenToMapTransform, showMiniMap = _a.showMiniMap;
        var className = 'map-ctrl';
        if (!showMiniMap) {
            className += ' map-ctrl-hidden';
        }
        if (this.state.animation) {
            className += ' map-ctrl-animation';
        }
        return (React.createElement("div", { className: className, onDoubleClick: function (e) { return _this.handleFocusTarget(e, 2); }, onClick: function (e) { return _this.handleFocusTarget(e, 1); }, style: tslib_1.__assign({ width: mapWidth + 'px', height: mapHeight + 'px' }, utils_1.getMapStyle(mapPosition)) },
            React.createElement("div", { id: "minimap", style: { width: '100%', height: '100%' } }, this.renderCustomMiniMap()),
            React.createElement("svg", { className: "map-visible-rect", width: "100%", height: "100%" },
                React.createElement("g", { ref: function (ele) {
                        _this.minimap = d3Select.select(ele);
                    }, transform: "translate(" + screenToMapTransform.x + ", " + screenToMapTransform.y + ") scale(" + screenToMapTransform.k + ")" }, React.createElement("rect", tslib_1.__assign({ width: this.screenWidth, height: this.screenHeight, fill: "rgba(200, 200, 200, .5)", stroke: "none", ref: this.rectRef }, this.props.mapRectStyle))))));
    };
    ReScreen.prototype.renderScreenContent = function () {
        var _this = this;
        var _a = this.props, type = _a.type, screenHeight = _a.screenHeight;
        var width = this.screenWidth || '100%';
        var height = screenHeight ? screenHeight : this.screenHeight || '100%';
        if (type === 'SVG') {
            return React.cloneElement(this.props.children, {
                ref: function (ele) {
                    if (_this.screen) {
                        return;
                    }
                    _this.screenDOM = ele;
                    _this.screen = d3Select.select(ele);
                    if (utils_1.isValidSVG(_this.screen)) {
                        _this.screenContent = d3Select.select(ele && ele.firstChild);
                    }
                    else {
                        return console.log('请确保svg内部用g包裹起来！');
                    }
                },
                width: width,
                height: height
            });
        }
        else if (type === 'DOM') {
            return (React.createElement("div", { style: { width: width, height: height, overflow: 'hidden' }, ref: function (ele) {
                    if (_this.screen) {
                        return;
                    }
                    _this.screenDOM = ele;
                    _this.screen = d3Select.select(ele);
                } }, React.cloneElement(this.props.children, {
                ref: function (ele) {
                    _this.screenContent = d3Select.select(ele);
                }
            })));
        }
        else {
            return null;
        }
    };
    ReScreen.prototype.render = function () {
        var _this = this;
        var _a = this.props, needMinimap = _a.needMinimap, Buttons = _a.Buttons, width = _a.width, height = _a.height, mapWidth = _a.mapWidth, mapHeight = _a.mapHeight, mapPosition = _a.mapPosition;
        var className = this.state.animation ? 'screen screen-animation' : 'screen';
        return (React.createElement("div", { className: "regraph", ref: function (ele) {
                _this.ReScreenDOM = ele;
            }, style: tslib_1.__assign({ width: width,
                height: height }, utils_1.getContainerStyle(mapPosition)), onClick: this.props.onClick, onContextMenu: this.props.onContextMenu, onDrop: this.props.onDrop, onDragOver: this.props.onDragOver },
            React.createElement("div", { className: className },
                this.renderScreenContent(),
                Buttons && this.renderButtons(Buttons)),
            needMinimap && this.renderMinimap(mapWidth, mapHeight, mapPosition)));
    };
    ReScreen.defaultProps = {
        type: 'SVG',
        width: '100%',
        height: '100%',
        needMinimap: true,
        zoomEnabled: true,
        minZoom: 0.01,
        maxZoom: 100,
        dragDirection: 'ALL',
        mapPosition: 'RT',
        mapWidth: 100,
        mapHeight: 100,
        mapPadding: 20,
        autoHideMiniMap: false,
        miniMapZoomEnabled: false,
        draggable: true
    };
    return ReScreen;
}(React.Component));
exports.default = ReScreen;
//# sourceMappingURL=index.js.map