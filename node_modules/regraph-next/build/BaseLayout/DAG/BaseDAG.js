"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Link_1 = require("./Link");
var utils_1 = require("../../Utils/utils");
var utils_2 = require("./utils");
var MAX_ITERATIONS = 24;
var BaseDAG = (function () {
    function BaseDAG(_a) {
        var nodes = _a.nodes, links = _a.links, selfLinks = _a.selfLinks, config = _a.config;
        this.virtualId = 0;
        this.paddingSum = [];
        this.levelPaddings = [];
        this.levelMap = new Map();
        this.nodesByLevel = [];
        this.nodesLevelMaxHeight = [];
        this.dfsVisited = [];
        this.nodes = nodes.slice().sort(function (nodeA, nodeB) {
            return nodeA.id > nodeB.id ? 1 : -1;
        });
        this.links = links.slice().sort(function (linkA, linkB) {
            return linkA.source.id + "-" + linkA.target.id >
                linkB.source.id + "-" + linkB.target.id
                ? 1
                : -1;
        });
        this.selfLinks = selfLinks.slice();
        this.config = tslib_1.__assign({}, config);
    }
    BaseDAG.prototype.destroy = function () {
        this.nodes = null;
        this.links = null;
        this.selfLinks = null;
        this.nodesByLevel = null;
        this.nodesLevelMaxHeight = null;
    };
    BaseDAG.prototype.getOutput = function (left, top) {
        var _this = this;
        this.nodes.forEach(function (node) {
            node.finalPos = {
                x: node.pos + left,
                y: _this.paddingSum[node.level] +
                    top +
                    _this.nodesLevelMaxHeight.reduce(function (pre, height, index) {
                        if (index < node.level)
                            return pre + _this.nodesLevelMaxHeight[index];
                        return pre;
                    }, 0) +
                    (_this.nodesLevelMaxHeight[node.level] - node.nodeHeight) / 2
            };
        });
        this.links.forEach(function (link) {
            if (link.linkChildren && link.linkChildren.length) {
                link.finalPath = link.linkChildren.reduce(function (path, child, index) {
                    if (index === 0) {
                        return _this.linkInstace.getFinalPath(child, _this.levelPaddings, false, true);
                    }
                    return path.concat(_this.linkInstace.getFinalPath(child, _this.levelPaddings, index === link.linkChildren.length - 1, false));
                }, []);
            }
            else {
                link.finalPath = _this.linkInstace.getFinalPath(link, _this.levelPaddings, true, true);
            }
        });
        this.selfLinks.forEach(function (link) {
            link.finalPath = _this.linkInstace.getSelfFinalPath(link);
        });
        this.recoverCycle();
        return {
            nodes: this.nodes.filter(function (node) { return node.type !== 'virtual'; }).map(function (node) {
                return {
                    id: node.id,
                    view: {
                        x: node.finalPos.x,
                        y: node.finalPos.y
                    },
                    nodeWidth: node.nodeWidth,
                    nodeHeight: node.nodeHeight,
                    info: node.originInfo
                };
            }),
            links: tslib_1.__spread(this.links
                .filter(function (link) {
                return link.source.type !== 'virtual' && link.target.type !== 'virtual';
            })
                .map(function (link) {
                return {
                    sourceId: link.source.id,
                    targetId: link.target.id,
                    path: link.finalPath,
                    info: link.originInfo
                };
            }), this.selfLinks.map(function (link) {
                return {
                    sourceId: link.source.id,
                    targetId: link.target.id,
                    path: link.finalPath,
                    info: link.originInfo
                };
            })),
            pos: {
                width: this.width,
                height: this.height
            }
        };
    };
    BaseDAG.prototype.run = function () {
        this.clearCycle();
        this.calcNodeLevels();
        this.calcNodePos();
        this.xcordinate();
        this.calcLinkPos();
        this.calcRealSize();
        return this;
    };
    BaseDAG.prototype.getSize = function () {
        return {
            width: this.width,
            height: this.height
        };
    };
    BaseDAG.prototype.calcLinkPos = function () {
        var _a = this.config, linkType = _a.linkType, DiyLine = _a.DiyLine;
        var LinkClass = Link_1.default(linkType, DiyLine);
        this.linkInstace = new LinkClass(this.nodesByLevel, this.selfLinks, this.config);
        this.levelPaddings = this.linkInstace.calcPosAndPadding();
    };
    BaseDAG.prototype.calcRealSize = function () {
        var _this = this;
        var sum = 0;
        this.levelPaddings.forEach(function (padding, index) {
            _this.paddingSum[index] = sum;
            sum += padding;
        });
        this.height =
            this.paddingSum[this.paddingSum.length - 1] +
                utils_1.sumBy(this.nodesLevelMaxHeight, function (height) { return height; });
        this.width =
            this.nodes.reduce(function (max, curNode) {
                return curNode.pos + curNode.nodeWidth > max
                    ? curNode.pos + curNode.nodeWidth
                    : max;
            }, 0) -
                this.nodes.reduce(function (min, curNode) {
                    return curNode.pos < min ? curNode.pos : min;
                }, 0);
    };
    BaseDAG.prototype.addVirtualNode = function () {
        var _this = this;
        var virtualNodes = [];
        var virtualLinks = [];
        this.links.forEach(function (link) {
            var source = link.source;
            var target = link.target;
            var sourceLevel = source.level;
            var targetLevel = target.level;
            link.linkChildren = [];
            if (sourceLevel + 1 < targetLevel) {
                for (var i = sourceLevel + 1; i < targetLevel; i++) {
                    var virtualNode = {
                        id: "virtual" + _this.virtualId++,
                        sourceLinks: [],
                        targetLinks: [],
                        type: 'virtual',
                        nodeWidth: _this.config.defaultVirtualNodeWidth,
                        nodeHeight: _this.nodesLevelMaxHeight[i],
                        originInfo: {},
                        level: i
                    };
                    var sourceNode = i === sourceLevel + 1
                        ? source
                        : virtualNodes[virtualNodes.length - 1];
                    var virtualLink = {
                        source: sourceNode,
                        target: virtualNode,
                        originInfo: {},
                        isReverse: link.isReverse,
                    };
                    link.linkChildren.push(virtualLink);
                    virtualLinks.push(virtualLink);
                    sourceNode.sourceLinks.push(virtualLink);
                    virtualNode.targetLinks.push(virtualLink);
                    if (i === targetLevel - 1) {
                        var virtualLink_1 = {
                            source: virtualNode,
                            target: target,
                            originInfo: {},
                            isReverse: link.isReverse,
                        };
                        link.linkChildren.push(virtualLink_1);
                        virtualLinks.push(virtualLink_1);
                        virtualNode.sourceLinks.push(virtualLink_1);
                        target.targetLinks.push(virtualLink_1);
                    }
                    virtualNodes.push(virtualNode);
                }
            }
        });
        this.nodes = tslib_1.__spread(this.nodes, virtualNodes);
        this.links = tslib_1.__spread(this.links, virtualLinks);
    };
    BaseDAG.prototype.dfsOrder = function (node) {
        var _this = this;
        if (this.dfsVisited.indexOf(node.id) > -1)
            return;
        var pos = this.levelMap.get(node.level);
        node.levelPos = pos;
        node._levelPos = pos;
        this.levelMap.set(node.level, pos + 1);
        this.dfsVisited.push(node.id);
        node.sourceLinks.forEach(function (link) {
            var source = link.source, target = link.target;
            if (target.level - source.level === 1) {
                _this.dfsOrder(target);
            }
        });
    };
    BaseDAG.prototype.initOrder = function () {
        var _this = this;
        this.nodes.forEach(function (node) {
            var level = node.level;
            if (_this.nodesByLevel[level]) {
                _this.nodesByLevel[level].push(node);
            }
            else {
                _this.nodesByLevel[level] = [node];
                _this.levelMap.set(level, 0);
            }
        });
        this.dfsVisited = [];
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                if (this.nodesByLevel[i][j].levelPos === undefined) {
                    this.dfsOrder(this.nodesByLevel[i][j]);
                }
            }
        }
    };
    BaseDAG.prototype.wmedian = function (index) {
        function medianNodeLevel(nodelevel) {
            nodelevel.forEach(function (node) {
                var parentNode = node.targetLinks
                    .filter(function (link) {
                    return link.target.level - link.source.level === 1;
                })
                    .map(function (link) { return link.source; });
                parentNode.sort(function (node1, node2) {
                    return node1.levelPos - node2.levelPos;
                });
                var m = Math.floor(parentNode.length / 2);
                if (parentNode.length === 0) {
                    node._median = -1;
                }
                else if (parentNode.length % 2 === 1) {
                    node._median = parentNode[m].levelPos;
                }
                else if (parentNode.length === 2) {
                    node._median = (parentNode[0].levelPos + parentNode[1].levelPos) / 2;
                }
                else {
                    var left = parentNode[m - 1].levelPos - parentNode[0].levelPos;
                    var right = parentNode[parentNode.length - 1].levelPos - parentNode[m].levelPos;
                    node._median = (parentNode[m - 1].levelPos * right + parentNode[m].levelPos * left) / (left + right);
                }
            });
        }
        if (index % 2 === 0) {
            for (var i = 0; i < this.nodesByLevel.length; i++) {
                var nodelevel = this.nodesByLevel[i];
                medianNodeLevel(nodelevel);
                this.nodesByLevel[i] = utils_2.sortNodelevel(nodelevel);
            }
            return;
        }
        else {
            for (var i = this.nodesByLevel.length - 1; i >= 0; i--) {
                var nodelevel = this.nodesByLevel[i];
                medianNodeLevel(nodelevel);
                this.nodesByLevel[i] = utils_2.sortNodelevel(nodelevel);
            }
        }
    };
    BaseDAG.prototype.crossing = function () {
        var count = 0;
        for (var i = 1; i < this.nodesByLevel.length; i++) {
            count += utils_2.crossing(this.nodesByLevel[i - 1], this.nodesByLevel[i]);
        }
        return count;
    };
    BaseDAG.prototype.transpose = function () {
        var bestCount = this.crossing();
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            if (this.nodesByLevel.length === 1)
                continue;
            for (var j = 1; j < this.nodesByLevel[i].length; j++) {
                this.nodesByLevel[i][j]._levelPos = j - 1;
                this.nodesByLevel[i][j - 1]._levelPos = j;
                var currentCount = this.crossing();
                if (currentCount < bestCount) {
                    var tmpNode = this.nodesByLevel[i][j];
                    this.nodesByLevel[i][j] = this.nodesByLevel[i][j - 1];
                    this.nodesByLevel[i][j - 1] = tmpNode;
                    bestCount = currentCount;
                }
                else {
                    this.nodesByLevel[i][j]._levelPos = j;
                    this.nodesByLevel[i][j - 1]._levelPos = j - 1;
                }
            }
        }
        return bestCount;
    };
    BaseDAG.prototype.ordering = function () {
        this.initOrder();
        var bestCount = this.crossing();
        if (bestCount !== 0) {
            for (var i = 0; i <= MAX_ITERATIONS; i++) {
                this.wmedian(i);
                var currentCount = this.transpose();
                if (bestCount > currentCount) {
                    bestCount = currentCount;
                    this.nodesByLevel.forEach(function (nodelevel, i) {
                        nodelevel.forEach(function (node) { return (node.levelPos = node._levelPos); });
                        nodelevel.sort(function (node1, node2) {
                            return node1.levelPos - node2.levelPos;
                        });
                    });
                }
            }
        }
        this.nodesByLevel.forEach(function (nodelevel, i) {
            nodelevel.sort(function (node1, node2) {
                return node1.levelPos - node2.levelPos;
            });
        });
    };
    BaseDAG.prototype.findTypeConflicts = function () {
        var conflicts = [];
        var _loop_1 = function (i) {
            var k0 = 0;
            var scanPos = 0;
            var prevLayerLength = this_1.nodesByLevel[i - 1].length;
            var _loop_2 = function (j) {
                var node = this_1.nodesByLevel[i][j];
                var upVirtualLink = node.type === 'virtual' &&
                    node.targetLinks.filter(function (link) {
                        return (link.target.level - link.source.level === 1 &&
                            link.source.type === 'virtual');
                    });
                var upVirtualNode = upVirtualLink && upVirtualLink.length
                    ? upVirtualLink[0].source
                    : undefined;
                var k1 = upVirtualNode ? upVirtualNode.levelPos : prevLayerLength;
                if (upVirtualNode || j === this_1.nodesByLevel[i].length - 1) {
                    this_1.nodesByLevel[i].slice(scanPos, j + 1).forEach(function (curNode) {
                        var upCurNodes = curNode.targetLinks
                            .filter(function (node) { return node.target.level - node.source.level === 1; })
                            .map(function (link) { return link.source; });
                        upCurNodes.forEach(function (upCurNode) {
                            var pos = upCurNode.levelPos;
                            if ((pos < k0 || k1 < pos) &&
                                !(upCurNode.type === 'virtual' && curNode.type === 'virtual')) {
                                conflicts.push(utils_1.find(curNode.targetLinks, function (link) {
                                    return link.source.id === upCurNode.id &&
                                        link.target.id === curNode.id;
                                }));
                            }
                        });
                    });
                    scanPos = j + 1;
                    k0 = k1;
                }
            };
            for (var j = 0; j < this_1.nodesByLevel[i].length; j++) {
                _loop_2(j);
            }
        };
        var this_1 = this;
        for (var i = 1; i < this.nodesByLevel.length; i++) {
            _loop_1(i);
        }
        return conflicts;
    };
    BaseDAG.prototype.verticalAlignment = function (vert, typeConflicts) {
        var root = {};
        var align = {};
        function hasConflict(node1, node2) {
            for (var i = 0; i < typeConflicts.length; i++) {
                var link = typeConflicts[i];
                if ((link.source.id === node1.id && link.target.id === node2.id) ||
                    (link.source.id === node2.id && link.target.id === node1.id)) {
                    return true;
                }
            }
            return false;
        }
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                var id = this.nodesByLevel[i][j].id;
                root[id] = id;
                align[id] = id;
            }
        }
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            var r = -1;
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                var nodeV = this.nodesByLevel[i][j];
                var neighbors = vert === 'u'
                    ? nodeV.targetLinks
                        .filter(function (link) {
                        return Math.abs(link.target.level - link.source.level) === 1;
                    })
                        .map(function (link) { return link.source; })
                    : nodeV.sourceLinks
                        .filter(function (link) {
                        return Math.abs(link.target.level - link.source.level) === 1;
                    })
                        .map(function (link) { return link.target; });
                if (neighbors && neighbors.length) {
                    neighbors.sort(function (node1, node2) {
                        return node1.levelPos - node2.levelPos;
                    });
                    var mid = (neighbors.length - 1) / 2;
                    for (var z = Math.floor(mid); z <= Math.ceil(mid); z++) {
                        var nodeW = neighbors[z];
                        if (align[nodeV.id] === nodeV.id &&
                            r < nodeW.levelPos &&
                            !hasConflict(nodeV, nodeW)) {
                            align[nodeW.id] = nodeV.id;
                            align[nodeV.id] = root[nodeV.id] = root[nodeW.id];
                            r = nodeW.levelPos;
                        }
                    }
                }
            }
        }
        return {
            root: root,
            align: align
        };
    };
    BaseDAG.prototype.horizontalCompaction = function (root, align, horiz) {
        var _this = this;
        var sink = {};
        var shift = {};
        var x = {};
        var blockSpaceMap = new Map();
        this.nodesByLevel.forEach(function (nodeLevel, i) {
            var uNode;
            nodeLevel.forEach(function (vnode) {
                var vRootNodeId = root[vnode.id];
                if (uNode) {
                    var uRootNodeId = root[uNode.id];
                    var blockSpace = blockSpaceMap.has(vRootNodeId + "-" + uRootNodeId) || blockSpaceMap.has(uRootNodeId + "-" + vRootNodeId) ?
                        blockSpaceMap.get(vRootNodeId + "-" + uRootNodeId) || blockSpaceMap.get(uRootNodeId + "-" + vRootNodeId) : 0;
                    var curSpace = vnode.nodeWidth / 2 + _this.config.nodeAndNodeSpace + uNode.nodeWidth / 2;
                    blockSpaceMap.set(vRootNodeId + "-" + uRootNodeId, Math.max(blockSpace, curSpace));
                    blockSpaceMap.set(uRootNodeId + "-" + vRootNodeId, Math.max(blockSpace, curSpace));
                }
                uNode = vnode;
            });
        });
        var placeBlock = function (node) {
            if (x[node.id] === undefined) {
                x[node.id] = 0;
                var w_1 = node.id;
                var _loop_3 = function () {
                    var curNode = utils_1.find(_this.nodes, function (node) { return node.id === w_1; });
                    if (curNode.levelPos > 0) {
                        var preNode = _this.nodesByLevel[curNode.level][curNode.levelPos - 1];
                        var rootId_1 = root[preNode.id];
                        placeBlock(utils_1.find(_this.nodes, function (node) { return node.id === rootId_1; }));
                        if (sink[node.id] === node.id) {
                            sink[node.id] = sink[rootId_1];
                        }
                        if (!blockSpaceMap.has(rootId_1 + "-" + root[node.id]) && !blockSpaceMap.has(root[node.id] + "-" + rootId_1)) {
                            throw new Error(rootId_1 + ", " + root[node.id] + "\u65E0\u6CD5\u83B7\u53D6");
                        }
                        if (sink[node.id] !== sink[rootId_1]) {
                            shift[sink[rootId_1]] = Math.min(shift[sink[rootId_1]], x[node.id] - x[rootId_1] - (blockSpaceMap.get(rootId_1 + "-" + root[node.id]) || blockSpaceMap.get(root[node.id] + "-" + rootId_1)));
                        }
                        else {
                            x[node.id] = Math.max(x[node.id], x[rootId_1] + (blockSpaceMap.get(rootId_1 + "-" + root[node.id]) || blockSpaceMap.get(root[node.id] + "-" + rootId_1)));
                        }
                    }
                    w_1 = align[w_1];
                };
                do {
                    _loop_3();
                } while (w_1 !== node.id);
            }
        };
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                var id = this.nodesByLevel[i][j].id;
                sink[id] = id;
                shift[id] = Number.MAX_SAFE_INTEGER;
                x[id] = undefined;
            }
        }
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                var id = this.nodesByLevel[i][j].id;
                if (root[id] === id) {
                    placeBlock(this.nodesByLevel[i][j]);
                }
            }
        }
        for (var i = 0; i < this.nodesByLevel.length; i++) {
            for (var j = 0; j < this.nodesByLevel[i].length; j++) {
                var id = this.nodesByLevel[i][j].id;
                x[id] = x[root[id]];
                if (shift[sink[root[id]]] < Number.MAX_SAFE_INTEGER) {
                    x[id] = x[id] + shift[sink[root[id]]];
                }
            }
        }
        return x;
    };
    BaseDAG.prototype.getDirectNodesByLevel = function (vert, horiz) {
        if (vert === 'u' && horiz === 'l') {
            return;
        }
        if ((vert === 'u' && horiz === 'r') || (vert === 'd' && horiz === 'r')) {
            this.nodesByLevel = this.nodesByLevel.map(function (nodeLevel, i) {
                return utils_1.reverseArray(nodeLevel, function (node, levelPos) {
                    node.levelPos = levelPos;
                    return node;
                });
            });
        }
        if (vert === 'd' && horiz === 'l') {
            this.nodesByLevel = utils_1.reverseArray(this.nodesByLevel, function (nodeLevel, level) {
                return utils_1.reverseArray(nodeLevel, function (node, levelPos) {
                    node.level = level;
                    node.levelPos = levelPos;
                    return node;
                });
            });
        }
    };
    BaseDAG.prototype.resetLevel = function () {
        this.nodesByLevel = utils_1.reverseArray(this.nodesByLevel, function (nodeLevel, level) {
            return utils_1.reverseArray(nodeLevel, function (node, levelPos) {
                node.level = level;
                node.levelPos = levelPos;
                return node;
            });
        });
    };
    BaseDAG.prototype.xcordinate = function () {
        var _this = this;
        var typeConflicts = this.findTypeConflicts();
        var xSet = {};
        ['u', 'd'].forEach(function (vert) {
            ['l', 'r'].forEach(function (horiz) {
                _this.getDirectNodesByLevel(vert, horiz);
                var _a = _this.verticalAlignment(vert, typeConflicts), root = _a.root, align = _a.align;
                var x = _this.horizontalCompaction(root, align, horiz);
                if (horiz === 'r') {
                    for (var key in x) {
                        x[key] = -x[key];
                    }
                }
                xSet[vert + horiz] = x;
            });
        });
        this.resetLevel();
        var _a = this.findSmallestWidthAlignment(xSet), smallestWidth = _a.minSet, minDirect = _a.minDirect;
        this.alignCoordinates(xSet, smallestWidth, minDirect);
        var finalPosSet = this.balance(xSet);
        var minPos = Infinity;
        this.nodes.forEach(function (node) {
            node.pos = finalPosSet[node.id] - node.nodeWidth / 2;
            if (minPos > node.pos) {
                minPos = node.pos;
            }
        });
        this.nodes.forEach(function (node) {
            node.pos = node.pos - minPos;
        });
    };
    BaseDAG.prototype.findSmallestWidthAlignment = function (xSet) {
        var minSet;
        var minDirect;
        var minSetValue = Number.MAX_SAFE_INTEGER;
        for (var direction in xSet) {
            var xs = xSet[direction];
            var minValue = Number.MAX_SAFE_INTEGER;
            var maxValue = Number.MIN_SAFE_INTEGER;
            var _loop_4 = function (key) {
                var value = xs[key];
                var node = utils_1.find(this_2.nodes, function (node) {
                    return String(node.id) === String(key);
                });
                if (value + (node.nodeWidth / 2) > maxValue)
                    maxValue = value + (node.nodeWidth / 2);
                if (value - (node.nodeWidth / 2) < minValue)
                    minValue = value - (node.nodeWidth / 2);
            };
            var this_2 = this;
            for (var key in xs) {
                _loop_4(key);
            }
            if (maxValue - minValue < minSetValue) {
                minSetValue = maxValue - minValue;
                minSet = xs;
                minDirect = direction;
            }
        }
        return {
            minSet: minSet,
            minDirect: minDirect
        };
    };
    BaseDAG.prototype.alignCoordinates = function (xSet, smallestWidth, direct) {
        var _a = utils_1.getObjectMaxMin(smallestWidth), maxAlign = _a.maxValue, minAlign = _a.minValue;
        ['u', 'd'].forEach(function (vert) {
            ['l', 'r'].forEach(function (horiz) {
                var alignment = vert + horiz;
                if (alignment !== direct) {
                    var xs = xSet[alignment];
                    var _a = utils_1.getObjectMaxMin(xs), maxXs = _a.maxValue, minXs = _a.minValue;
                    var delta = horiz === 'l' ? minAlign - minXs : maxAlign - maxXs;
                    if (delta) {
                        for (var key in xs) {
                            xs[key] = xs[key] + delta;
                        }
                    }
                }
            });
        });
    };
    BaseDAG.prototype.balance = function (xSet) {
        var posListSet = {};
        for (var direction in xSet) {
            for (var key in xSet[direction]) {
                if (posListSet[key] && posListSet[key].length) {
                    posListSet[key].push(xSet[direction][key]);
                }
                else {
                    posListSet[key] = [xSet[direction][key]];
                }
            }
        }
        var finalPosSet = {};
        for (var key in posListSet) {
            posListSet[key].sort(function (a, b) { return a - b; });
            finalPosSet[key] = (posListSet[key][1] + posListSet[key][2]) / 2;
        }
        return finalPosSet;
    };
    BaseDAG.prototype.calcNodePos = function () {
        this.addVirtualNode();
        this.ordering();
    };
    BaseDAG.prototype.recoverCycle = function () {
        var _this = this;
        this.links.forEach(function (link) {
            if (link.isReverse) {
                _this.exchangeLink(link);
                if (link.linkChildren && link.linkChildren.length) {
                    link.linkChildren.forEach(function (link) {
                        if (link.isReverse) {
                            _this.exchangeLink(link);
                        }
                    });
                }
            }
        });
    };
    BaseDAG.prototype.clearCycleDfs = function (node, stack, isFirst) {
        var lastNodeId = stack[stack.length - 1];
        if (lastNodeId) {
            if (this.dfsVisited.indexOf(lastNodeId + "_" + node.id) > -1) {
                return;
            }
            this.dfsVisited.push(lastNodeId + "_" + node.id);
        }
        if (stack.indexOf(node.id) > -1) {
            console.warn('当前图中存在环，已被逆转处理');
            var link = utils_1.find(this.links, function (link) {
                return link.source.id === lastNodeId && link.target.id === node.id;
            });
            link.isReverse = true;
        }
        var LinkList = isFirst ? node.sourceLinks.filter(function (link) { return !link.isCycleRelation; }) : node.sourceLinks;
        for (var i = 0; i < LinkList.length; i++) {
            this.clearCycleDfs(LinkList[i].target, tslib_1.__spread(stack, [node.id]), false);
        }
        return;
    };
    BaseDAG.prototype.exchangeLink = function (link) {
        var source = link.source;
        var target = link.target;
        source.sourceLinks = source.sourceLinks.filter(function (link) {
            return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse;
        });
        source.targetLinks.push(link);
        target.targetLinks = target.targetLinks.filter(function (link) {
            return link.source.id !== source.id || link.target.id !== target.id || !link.isReverse;
        });
        target.sourceLinks.push(link);
        link.source = target;
        link.target = source;
    };
    BaseDAG.prototype.clearCycle = function () {
        var _this = this;
        this.dfsVisited = [];
        for (var i = 0; i < this.nodes.length; i++) {
            this.clearCycleDfs(this.nodes[i], [], true);
        }
        this.links.forEach(function (link) {
            if (link.isReverse) {
                _this.exchangeLink(link);
            }
        });
    };
    BaseDAG.prototype.calcNodeLevels = function () {
        var _this = this;
        this.nodes.forEach(function (node) {
            node.linkNumber = node.targetLinks.length + node.sourceLinks.length;
            node.levelSetted = false;
        });
        var shrink = true;
        var boneNodes = this.nodes;
        while (shrink) {
            shrink = false;
            boneNodes.forEach(function (node) {
                if (node.linkNumber === 1) {
                    shrink = true;
                    node.linkNumber = 0;
                    node.sourceLinks.forEach(function (link) {
                        link.target.linkNumber--;
                    });
                    node.targetLinks.forEach(function (link) {
                        link.source.linkNumber--;
                    });
                }
            });
            boneNodes = boneNodes.filter(function (node) {
                return node.linkNumber > 0;
            });
        }
        boneNodes.forEach(function (node) {
            node.isBone = true;
        });
        var level = 0;
        var confirmNodeLevelList = boneNodes;
        if (boneNodes.length > 0) {
            var _loop_5 = function () {
                var nextNodes = [];
                confirmNodeLevelList.forEach(function (node) {
                    node.level = level;
                    node.sourceLinks.forEach(function (link) {
                        if (!utils_1.find(nextNodes, function (node) {
                            return node.id === link.target.id;
                        })) {
                            nextNodes.push(link.target);
                        }
                    });
                });
                confirmNodeLevelList = nextNodes;
                level++;
            };
            while (confirmNodeLevelList.length) {
                _loop_5();
            }
            boneNodes.forEach(function (node) {
                var parentBoneNode = [];
                var childrenBoneNode = [];
                node.targetLinks.forEach(function (link) {
                    if (link.source.isBone) {
                        parentBoneNode.push(link.source);
                    }
                });
                node.sourceLinks.forEach(function (link) {
                    if (link.target.isBone) {
                        childrenBoneNode.push(link.target);
                    }
                });
                node.parentBoneNode = parentBoneNode;
                node.childrenBoneNode = childrenBoneNode;
                var minChildLevel = (utils_1.minBy(node.childrenBoneNode, function (boneNode) { return boneNode.level; }) ||
                    {}).level;
                if (node.parentBoneNode.length === 0) {
                    node.level = minChildLevel - 1;
                }
                if (minChildLevel && minChildLevel - node.level > 1) {
                    if (node.childrenBoneNode.length < node.parentBoneNode.length) {
                        node.level = minChildLevel - 1;
                    }
                }
            });
        }
        else {
            this.nodes[0].level = 0;
            boneNodes.push(this.nodes[0]);
        }
        boneNodes.forEach(function (node) {
            node.levelSetted = true;
        });
        var waitSetLevelNodes = boneNodes;
        var _loop_6 = function () {
            var tmpNodeList = [];
            waitSetLevelNodes.forEach(function (node) {
                node.sourceLinks.forEach(function (link) {
                    var targetNode = link.target;
                    if (!targetNode.levelSetted) {
                        targetNode.level = node.level + 1;
                        node.levelSetted = true;
                        tmpNodeList.push(targetNode);
                    }
                });
                node.targetLinks.forEach(function (link) {
                    var sourceNode = link.source;
                    if (!sourceNode.levelSetted) {
                        sourceNode.level = node.level - 1;
                        node.levelSetted = true;
                        tmpNodeList.push(sourceNode);
                    }
                });
            });
            waitSetLevelNodes = tmpNodeList;
        };
        while (waitSetLevelNodes.length) {
            _loop_6();
        }
        var minLevel = utils_1.minBy(this.nodes, function (node) { return node.level; }).level;
        this.nodes.forEach(function (node) {
            node.level -= minLevel;
        });
        var maxLevel = utils_1.maxBy(this.nodes, function (node) { return node.level; }).level;
        this.nodesLevelMaxHeight = Array(maxLevel + 1).fill(-Infinity);
        this.nodes.forEach(function (node) {
            if (_this.nodesLevelMaxHeight[node.level] < node.nodeHeight) {
                _this.nodesLevelMaxHeight[node.level] = node.nodeHeight;
            }
        });
    };
    return BaseDAG;
}());
exports.default = BaseDAG;
//# sourceMappingURL=BaseDAG.js.map