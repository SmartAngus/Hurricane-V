"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("./utils");
var graph_1 = require("../../Utils/graph");
var utils_2 = require("../../Utils/utils");
var StraightLine = (function () {
    function StraightLine(nodesByLevel, selfLinks, config) {
        this.nodeLinkByLevelSourceNodeCount = [];
        this.nodesByLevel = nodesByLevel;
        this.selfLinks = selfLinks;
        this.config = config;
    }
    StraightLine.prototype.calcPosAndPadding = function () {
        var _this = this;
        this.nodesByLevel.forEach(function (nodelevel) {
            var count = 0;
            nodelevel.forEach(function (node) {
                if (node.sourceLinks && node.sourceLinks.length) {
                    count += node.sourceLinks.filter(function (link) {
                        return link.target.level - link.source.level === 1;
                    }).length;
                }
            });
            _this.nodeLinkByLevelSourceNodeCount.push(count);
        });
        var levelPaddings = [];
        this.nodesByLevel.forEach(function (nodelevel, level) {
            if (level === _this.nodesByLevel.length - 1) {
                levelPaddings[level] = 0;
            }
            else {
                levelPaddings[level] = Math.max(_this.nodeLinkByLevelSourceNodeCount[level] * 15, _this.config.levelSpace);
            }
        });
        return levelPaddings;
    };
    StraightLine.prototype.getFinalPath = function (link, levelPaddings, isLast, isFirst) {
        var bDis = 6;
        var angle = 1 / 2;
        var startPoint = {
            x: link.source.finalPos.x + link.source.nodeWidth / 2,
            y: link.source.finalPos.y + link.source.nodeHeight / 2
        };
        var endPoint = {
            x: link.target.finalPos.x + link.target.nodeWidth / 2,
            y: link.target.finalPos.y + link.target.nodeHeight / 2
        };
        if (isFirst && link.isReverse) {
            var startNodeEdge_1 = [
                { x: link.source.finalPos.x, y: link.source.finalPos.y },
                {
                    x: link.source.finalPos.x + link.source.nodeWidth,
                    y: link.source.finalPos.y
                },
                {
                    x: link.source.finalPos.x + link.source.nodeWidth,
                    y: link.source.finalPos.y + link.source.nodeHeight
                },
                {
                    x: link.source.finalPos.x,
                    y: link.source.finalPos.y + link.source.nodeHeight
                }
            ];
            var cPoint = startNodeEdge_1.reduce(function (pre, edge, index) {
                if (graph_1.isCross(startNodeEdge_1[index], startNodeEdge_1[index === startNodeEdge_1.length - 1 ? 0 : index + 1], startPoint, endPoint)) {
                    return graph_1.crossPoint(startNodeEdge_1[index], startNodeEdge_1[index === startNodeEdge_1.length - 1 ? 0 : index + 1], startPoint, endPoint);
                }
                return pre;
            }, null);
            var aDis = graph_1.distance(endPoint, cPoint);
            var b = (endPoint.x - cPoint.x) * aDis * bDis * 2 * angle;
            var a = (endPoint.x - cPoint.x) * (endPoint.x - cPoint.x) +
                (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y);
            var c = angle * angle * aDis * aDis * bDis * bDis -
                (endPoint.y - cPoint.y) * (endPoint.y - cPoint.y) * bDis * bDis;
            var y1 = cPoint.y + (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            var x1 = (angle * aDis * bDis +
                ((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a)) *
                    (endPoint.x - cPoint.x)) /
                (endPoint.y - cPoint.y) +
                cPoint.x;
            var y2 = cPoint.y + (b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            var x2 = (((endPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c))) /
                (2 * a) -
                angle * aDis * bDis) /
                (endPoint.y - cPoint.y) +
                cPoint.x;
            return [
                startPoint,
                cPoint,
                { x: x1, y: y1 },
                cPoint,
                { x: x2, y: y2 },
                cPoint,
                endPoint
            ];
        }
        if (isLast && !link.isReverse) {
            var endNodeEdge_1 = [
                { x: link.target.finalPos.x, y: link.target.finalPos.y },
                {
                    x: link.target.finalPos.x + link.target.nodeWidth,
                    y: link.target.finalPos.y
                },
                {
                    x: link.target.finalPos.x + link.target.nodeWidth,
                    y: link.target.finalPos.y + link.target.nodeHeight
                },
                {
                    x: link.target.finalPos.x,
                    y: link.target.finalPos.y + link.target.nodeHeight
                }
            ];
            var cPoint = endNodeEdge_1.reduce(function (pre, edge, index) {
                if (graph_1.isCross(endNodeEdge_1[index], endNodeEdge_1[index === endNodeEdge_1.length - 1 ? 0 : index + 1], startPoint, endPoint)) {
                    return graph_1.crossPoint(endNodeEdge_1[index], endNodeEdge_1[index === endNodeEdge_1.length - 1 ? 0 : index + 1], startPoint, endPoint);
                }
                return pre;
            }, null);
            var aDis = graph_1.distance(startPoint, cPoint);
            var b = (startPoint.x - cPoint.x) * aDis * bDis * 2 * angle;
            var a = (startPoint.x - cPoint.x) * (startPoint.x - cPoint.x) +
                (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y);
            var c = angle * angle * aDis * aDis * bDis * bDis -
                (startPoint.y - cPoint.y) * (startPoint.y - cPoint.y) * bDis * bDis;
            var y1 = cPoint.y + (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            var x1 = (angle * aDis * bDis +
                ((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a)) *
                    (startPoint.x - cPoint.x)) /
                (startPoint.y - cPoint.y) +
                cPoint.x;
            var y2 = cPoint.y + (b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
            var x2 = (((startPoint.x - cPoint.x) * (b - Math.sqrt(b * b - 4 * a * c))) /
                (2 * a) -
                angle * aDis * bDis) /
                (startPoint.y - cPoint.y) +
                cPoint.x;
            return [
                startPoint,
                cPoint,
                { x: x1, y: y1 },
                cPoint,
                { x: x2, y: y2 },
                cPoint,
                endPoint
            ];
        }
        return [startPoint, endPoint];
    };
    StraightLine.prototype.getSelfFinalPath = function (link) {
        var x0 = link.source.finalPos.x + link.source.nodeWidth / 2;
        var y0 = link.source.finalPos.y + link.source.nodeHeight;
        var x1 = link.target.finalPos.x + link.source.nodeWidth / 2 - 30;
        var y1 = link.target.finalPos.y;
        return [
            { x: x0, y: y0 },
            { x: x0, y: y0 + 12 },
            { x: link.source.finalPos.x - 24, y: y0 + 12 },
            { x: link.source.finalPos.x - 24, y: y1 - 12 },
            { x: x1, y: y1 - 12 },
            { x: x1, y: y1 },
            { x: x1 - 3, y: y1 - 5 },
            { x: x1, y: y1 },
            { x: x1 + 3, y: y1 - 5 },
            { x: x1, y: y1 }
        ];
    };
    return StraightLine;
}());
exports.StraightLine = StraightLine;
var Polyline = (function () {
    function Polyline(nodesByLevel, selfLinks, config) {
        this.nodeLinkByLevelSourceNodeCount = [];
        this.nodesByLevel = nodesByLevel;
        this.selfLinks = selfLinks;
        this.config = config;
    }
    Polyline.prototype.calcPosAndPadding = function () {
        var _this = this;
        this.nodesByLevel.forEach(function (nodelevel) {
            var count = -1;
            nodelevel.forEach(function (node) {
                if (node.sourceLinks && node.sourceLinks.length) {
                    node.sourceNodeIndex = ++count;
                }
                var selfLink = utils_2.find(_this.selfLinks, function (link) {
                    return link.source.id === node.id;
                });
                var singleLevelSourceLinkCount = node.sourceLinks.filter(function (link) {
                    return link.target.level - link.source.level === 1;
                }).length;
                var singleLevelTargetLinkCount = node.targetLinks.filter(function (link) {
                    return link.target.level - link.source.level === 1;
                }).length;
                var singleLevelSourceLinks = node.sourceLinks
                    .filter(function (link) {
                    return link.target.level - link.source.level === 1;
                })
                    .sort(function (alink, blink) {
                    return (alink.source.levelPos - blink.source.levelPos ||
                        (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0));
                });
                var sourceCount = node.sourceLinks.filter(function (link) {
                    return link.isReverse;
                }).length + 1;
                var index = 0;
                singleLevelSourceLinks.forEach(function (link) {
                    if (link.isReverse)
                        index++;
                    link.sourcePos =
                        (((index + 1) / (sourceCount + 1) - 0.5) * 0.6 + 0.5) *
                            link.source.nodeWidth;
                });
                var singleLevelTargetLinks = node.targetLinks
                    .filter(function (link) {
                    return link.target.level - link.source.level === 1;
                })
                    .sort(function (alink, blink) {
                    return (alink.source.levelPos - blink.source.levelPos ||
                        (alink.isReverse ? 1 : 0) - (blink.isReverse ? 1 : 0));
                });
                singleLevelTargetLinks.forEach(function (link, index) {
                    link.targetPos =
                        (((index + 1) / (singleLevelTargetLinkCount + 1) - 0.5) * 0.6 +
                            0.5) *
                            link.target.nodeWidth;
                });
                if (selfLink) {
                    selfLink.sourcePos =
                        ((1 / (singleLevelSourceLinkCount + 2) - 0.5) * 0.6 + 0.5) *
                            node.nodeWidth;
                    selfLink.targetPos =
                        ((1 / (singleLevelTargetLinkCount + 2) - 0.5) * 0.6 + 0.5) *
                            node.nodeWidth;
                }
            });
            _this.nodeLinkByLevelSourceNodeCount.push(count + 1);
        });
        var levelPaddings = [];
        this.nodesByLevel.forEach(function (nodelevel, level) {
            if (level === _this.nodesByLevel.length - 1) {
                levelPaddings[level] = 0;
            }
            else {
                var turnYCount = _this.getLevelTurnYIndex(level);
                levelPaddings[level] = Math.max((turnYCount + 1) *
                    _this.config.paddingLineSpace, _this.config.levelSpace);
            }
        });
        return levelPaddings;
    };
    Polyline.prototype.getLevelTurnYIndex = function (level) {
        var _this = this;
        var turnYCount = 0;
        var nodelevel = this.nodesByLevel[level];
        this.turnYMap = new Map();
        nodelevel.forEach(function (node, index) {
            node.sourceLinks.forEach(function (link) {
                var turnYValue = utils_1.getRatio(link.source.sourceNodeIndex, _this.nodeLinkByLevelSourceNodeCount[link.source.level]);
                if (_this.turnYMap.has(turnYValue)) {
                    var _a = _this.turnYMap.get(turnYValue), allLine = _a.allLine, allRecord = _a.allRecord;
                    if (!_this.config._isLinkMerge && utils_2.find(allRecord, function (item) {
                        return (item.source.pos < link.source.pos
                            && item.target.pos > link.target.pos)
                            || (item.source.pos > link.source.pos
                                && item.target.pos < link.target.pos);
                    })) {
                        var maxTurnYValue = -Infinity;
                        var flag = false;
                        for (var i = 0; i < allLine.length; i++) {
                            var line = allLine[i];
                            maxTurnYValue = Math.max(line.turnYValue, maxTurnYValue);
                            if (line.source.id === link.source.id || line.target.id === link.target.id) {
                                turnYValue = line.turnYValue;
                                link.turnYValue = turnYValue;
                                flag = true;
                                break;
                            }
                        }
                        if (!flag) {
                            turnYValue = maxTurnYValue + 0.1;
                            link.turnYValue = turnYValue;
                            turnYCount++;
                            allLine.push(link);
                        }
                    }
                    else {
                        link.turnYValue = turnYValue;
                    }
                    allRecord.push(link);
                    _this.turnYMap.set(turnYValue, {
                        allLine: allLine,
                        allRecord: allRecord,
                    });
                }
                else {
                    turnYCount++;
                    link.turnYValue = turnYValue;
                    _this.turnYMap.set(turnYValue, {
                        allLine: [link],
                        allRecord: [link],
                    });
                }
            });
        });
        var valueArr = tslib_1.__spread(this.turnYMap.keys()).sort();
        nodelevel.forEach(function (node) {
            node.sourceLinks.forEach(function (link) {
                link.turnYIndex = valueArr.indexOf(link.turnYValue) + 1;
                link.turnYCount = turnYCount;
            });
        });
        return turnYCount;
    };
    Polyline.prototype.getFinalPath = function (link, levelPaddings, isLast, isFirst) {
        var x0 = link.source.finalPos.x + link.sourcePos;
        var y0 = link.source.finalPos.y + link.source.nodeHeight;
        var x1 = link.target.finalPos.x + link.targetPos;
        var y1 = link.target.finalPos.y;
        var turnY = y0 + levelPaddings[link.source.level] * (link.turnYIndex / (link.turnYCount + 1));
        if (isLast && !link.isReverse) {
            return [
                { x: x0, y: y0 },
                { x: x0, y: turnY },
                { x: x1, y: turnY },
                { x: x1, y: y1 },
                { x: x1 - 3, y: y1 - 5 },
                { x: x1, y: y1 },
                { x: x1 + 3, y: y1 - 5 },
                { x: x1, y: y1 }
            ];
        }
        if (isFirst && link.isReverse) {
            return [
                { x: x1, y: y1 },
                { x: x1, y: turnY },
                { x: x0, y: turnY },
                { x: x0, y: y0 },
                { x: x0 + 3, y: y0 + 5 },
                { x: x0, y: y0 },
                { x: x0 - 3, y: y0 + 5 },
                { x: x0, y: y0 }
            ];
        }
        return [
            { x: x0, y: y0 },
            { x: x0, y: turnY },
            { x: x1, y: turnY },
            { x: x1, y: y1 }
        ];
    };
    Polyline.prototype.getSelfFinalPath = function (link) {
        var x0 = link.source.finalPos.x + link.sourcePos;
        var y0 = link.source.finalPos.y + link.source.nodeHeight;
        var x1 = link.target.finalPos.x + link.targetPos;
        var y1 = link.target.finalPos.y;
        return [
            { x: x0, y: y0 },
            { x: x0, y: y0 + 12 },
            { x: link.source.finalPos.x - 24, y: y0 + 12 },
            { x: link.source.finalPos.x - 24, y: y1 - 12 },
            { x: x1, y: y1 - 12 },
            { x: x1, y: y1 },
            { x: x1 - 3, y: y1 - 5 },
            { x: x1, y: y1 },
            { x: x1 + 3, y: y1 - 5 },
            { x: x1, y: y1 }
        ];
    };
    return Polyline;
}());
exports.Polyline = Polyline;
function LinkGenerator(type, DiyLine) {
    switch (type) {
        case 'straightLine': {
            return StraightLine;
        }
        case 'polyline': {
            return Polyline;
        }
        case 'diy': {
            return DiyLine;
        }
    }
}
exports.default = LinkGenerator;
//# sourceMappingURL=Link.js.map