"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function sortNodelevel(nodelevel) {
    var noChangeList = [];
    var internalNodeLevel = nodelevel.filter(function (node) {
        if (node._median === -1) {
            noChangeList.push(node);
        }
        return node._median !== -1;
    });
    internalNodeLevel.sort(function (node1, node2) {
        return node1._median - node2._median;
    });
    noChangeList.sort(function (node1, node2) {
        return node1.levelPos - node2.levelPos;
    });
    noChangeList.forEach(function (node) {
        var pos = node.levelPos;
        internalNodeLevel.splice(pos, 0, node);
    });
    internalNodeLevel.forEach(function (node, i) { return node._levelPos = i; });
    return internalNodeLevel;
}
exports.sortNodelevel = sortNodelevel;
function crossing(upNodes, downNodes) {
    var pieNodeList = [];
    upNodes.forEach(function (node) {
        node.sourceLinks.sort(function (link1, link2) {
            return link1.target._levelPos - link2.target._levelPos;
        });
        node.sourceLinks.forEach(function (link) {
            if (link.target.level - link.source.level === 1) {
                pieNodeList.push(link.target);
            }
        });
    });
    var q = downNodes.length;
    var firstIndex = 1;
    while (firstIndex < q)
        firstIndex *= 2;
    var treesize = 2 * firstIndex - 1;
    firstIndex -= 1;
    var tree = (new Array(treesize)).fill(0);
    var crossCount = 0;
    pieNodeList.map(function (node) {
        var index = node._levelPos + firstIndex;
        tree[index]++;
        while (index > 0) {
            if (index % 2)
                crossCount += tree[index + 1];
            index = Math.floor((index - 1) / 2);
            tree[index]++;
        }
    });
    return crossCount;
}
exports.crossing = crossing;
function getRatio(idx, length) {
    var range = [0, 1];
    var count = Math.ceil(length / 2) + 1;
    var interval = (range[1] - range[0]) / count;
    if (length % 2 === 1) {
        var median_1 = (length - 1) / 2;
        return interval * (Math.abs(median_1 - idx) + 1);
    }
    var median = [length / 2 - 1, length / 2];
    if (idx <= median[0]) {
        return interval * (Math.abs(median[0] - idx) + 1);
    }
    return interval * (Math.abs(median[1] - idx) + 1);
}
exports.getRatio = getRatio;
//# sourceMappingURL=utils.js.map