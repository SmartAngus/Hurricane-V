"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var dagre = require("dagre");
var utils_1 = require("../Utils/utils");
var base_1 = require("./base");
var GraphLayout = (function (_super) {
    tslib_1.__extends(GraphLayout, _super);
    function GraphLayout(nodes, links, config) {
        var _this = _super.call(this) || this;
        _this.nodes = _this.getNodes(nodes);
        _this.links = links;
        _this.config = config;
        _this.init();
        return _this;
    }
    GraphLayout.prototype.init = function () {
        this.g = new dagre.graphlib.Graph();
        this.g.setGraph(this.config);
        this.g.setDefaultEdgeLabel(function () {
            return {};
        });
    };
    GraphLayout.prototype.layout = function () {
        var _this = this;
        this.nodes.forEach(function (node) {
            var id = node.id, width = node.width, height = node.height;
            _this.g.setNode(id, { id: id, width: width, height: height });
        });
        this.links.forEach(function (link) {
            var u = link.u, v = link.v;
            _this.g.setEdge(u, v);
        });
        dagre.layout(this.g);
        return {
            nodes: this.nodes.map(function (node) {
                var _a = _this.g.node(node.id), x = _a.x, y = _a.y;
                return tslib_1.__assign(tslib_1.__assign({}, node), { x: x,
                    y: y });
            }),
            links: this.links.map(function (link) {
                var points = _this.g.edge({
                    v: link.u,
                    w: link.v
                }).points;
                return tslib_1.__assign(tslib_1.__assign({}, link), { u: link.u, v: link.v, points: points });
            })
        };
    };
    return GraphLayout;
}(base_1.BaseGroupLayout));
exports.GraphLayout = GraphLayout;
var GroupGraphLayout = (function (_super) {
    tslib_1.__extends(GroupGraphLayout, _super);
    function GroupGraphLayout(nodes, links, groups, groupLinks, config) {
        var _this = _super.call(this) || this;
        _this.renderGroups = [];
        _this.renderNodes = [];
        _this.renderNodeLinks = [];
        _this.renderGroupLinks = [];
        _this.preRenderGroups = [];
        _this.preRenderNodes = [];
        _this.preRenderNodeLinks = [];
        _this.preRenderGroupLinks = [];
        _this.init(nodes, links, groups, groupLinks, config);
        return _this;
    }
    GroupGraphLayout.prototype.init = function (nodes, links, groups, groupLinks, config) {
        this.nodes = this.getNodes(nodes);
        this.links = links;
        this.groups = this.getGroups(groups);
        this.groupLinks = groupLinks;
        this.config = config;
        this.groupNodeMap = new Map();
        this.groupLinkMap = new Map();
        this.getGroupNodeMap();
    };
    GroupGraphLayout.prototype.getGroupNodeMap = function () {
        var _this = this;
        this.groups.forEach(function (group) {
            group.vertexes.forEach(function (vertex) {
                _this.groupNodeMap.set(vertex.id, group);
            });
        });
    };
    GroupGraphLayout.prototype.getDownGroup = function (groupId) {
        var _this = this;
        return this.groupLinks
            .filter(function (link) {
            return link.u === groupId;
        })
            .map(function (link) {
            var v = link.v;
            return utils_1.find(_this.groups, function (group) {
                return group.id === v;
            });
        });
    };
    GroupGraphLayout.prototype.processGroupConnect = function (g, groupId, nodeId, forceNoExpand) {
        var _this = this;
        if (nodeId === void 0) { nodeId = ''; }
        if (forceNoExpand === void 0) { forceNoExpand = false; }
        var downGroups = this.getDownGroup(groupId);
        var connectId = nodeId || groupId;
        downGroups.forEach(function (downGroup) {
            if (downGroup.vertexes.length === 1) {
                g.setEdge(connectId, downGroup.vertexes[0].id);
            }
            else if (downGroup.expand && !forceNoExpand) {
                var downGroupNodeIds_1 = downGroup.vertexes.map(function (vertex) { return vertex.id; });
                _this.links
                    .filter(function (link) {
                    return link.u === connectId && downGroupNodeIds_1.includes(link.v);
                })
                    .forEach(function (link) {
                    g.setEdge(link.u, link.v);
                });
            }
            else {
                g.setEdge(connectId, downGroup.id);
            }
        });
    };
    GroupGraphLayout.prototype.getLayoutInGroup = function (group) {
        var _this = this;
        var g = new dagre.graphlib.Graph();
        g.setGraph(this.config.dagreConfig);
        g.setDefaultEdgeLabel(function () {
            return {};
        });
        var groupNodeIds = group.vertexes.map(function (vertex) { return vertex.id; });
        var links = [];
        groupNodeIds.forEach(function (nodeId) {
            var node = utils_1.find(_this.nodes, function (n) {
                return n.id === nodeId;
            });
            g.setNode(nodeId, {
                id: nodeId,
                width: node.width,
                height: node.height
            });
            _this.links
                .filter(function (link) {
                if (link.u === nodeId && _this.groupNodeMap.has(link.v)) {
                    var nodeGroup = _this.groupNodeMap.get(link.v);
                    return nodeGroup.id === group.id;
                }
                return false;
            })
                .forEach(function (link) {
                links.push(link);
                g.setEdge(nodeId, link.v);
            });
        });
        dagre.layout(g);
        return {
            vertexes: group.vertexes.map(function (vertex) {
                if (g.hasNode(vertex.id)) {
                    var _a = g.node(vertex.id), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                    return tslib_1.__assign(tslib_1.__assign({}, vertex), { x: x,
                        y: y,
                        width: width,
                        height: height });
                }
                return vertex;
            }),
            edges: links.map(function (link) {
                var points = g.edge({
                    v: link.u,
                    w: link.v
                }).points;
                return tslib_1.__assign(tslib_1.__assign({}, link), { u: link.u, v: link.v, points: points });
            })
        };
    };
    GroupGraphLayout.prototype.getGroupSize = function () {
        var _this = this;
        var groupPadding = this.config.groupPadding;
        this.groups = this.groups.map(function (group) {
            if (group.vertexes.length !== 1 && group.expand) {
                var maxChildX_1 = -Infinity;
                var maxChildY_1 = -Infinity;
                var minChildX_1 = Infinity;
                var minChildY_1 = Infinity;
                var _a = _this.getLayoutInGroup(group), vertexes = _a.vertexes, edges = _a.edges;
                vertexes.forEach(function (vertex) {
                    var x = vertex.x, y = vertex.y, width = vertex.width, height = vertex.height;
                    if (maxChildX_1 < x + width / 2 + groupPadding[1]) {
                        maxChildX_1 = x + width / 2 + groupPadding[1];
                    }
                    if (maxChildY_1 < y + height / 2 + groupPadding[2]) {
                        maxChildY_1 = y + height / 2 + groupPadding[2];
                    }
                    if (minChildX_1 > x - width / 2 - groupPadding[3]) {
                        minChildX_1 = x - width / 2 - groupPadding[3];
                    }
                    if (minChildY_1 > y - height / 2 - groupPadding[0]) {
                        minChildY_1 = y - height / 2 - groupPadding[0];
                    }
                });
                var links = edges.map(function (edge) {
                    var points = edge.points.map(function (point) {
                        return { x: point.x - minChildX_1, y: point.y - minChildY_1 };
                    });
                    return tslib_1.__assign(tslib_1.__assign({}, edge), { points: points });
                });
                _this.groupLinkMap.set(group.id, links);
                var groupWidth = maxChildX_1 - minChildX_1;
                var groupHeight = maxChildY_1 - minChildY_1;
                return tslib_1.__assign(tslib_1.__assign({}, group), { width: groupWidth, height: groupHeight, vertexes: vertexes.map(function (vertex) {
                        var x = vertex.x, y = vertex.y, width = vertex.width, height = vertex.height;
                        return tslib_1.__assign(tslib_1.__assign({}, vertex), { x: x - width / 2 - minChildX_1, y: y - height / 2 - minChildY_1 });
                    }) });
            }
            return group;
        });
    };
    GroupGraphLayout.prototype.groupLayout = function () {
        var _this = this;
        var nodeLinks = [];
        var g = new dagre.graphlib.Graph({});
        g.setGraph(this.config.dagreConfig);
        g.setDefaultEdgeLabel(function () {
            return {};
        });
        this.groups.forEach(function (group) {
            var groupId = group.id;
            if (group.vertexes.length === 1) {
                var _a = group.vertexes[0], id = _a.id, width = _a.width, height = _a.height;
                g.setNode(String(id), { id: id, width: width, height: height });
                _this.processGroupConnect(g, groupId, String(id), true);
            }
            else if (!group.expand) {
                g.setNode(groupId, {
                    id: groupId,
                    width: _this.config.defaultGroupWidth,
                    height: _this.config.defaultGroupHeight
                });
                _this.processGroupConnect(g, groupId, '', true);
            }
            else {
                g.setNode(groupId, {
                    id: groupId,
                    width: group.width,
                    height: group.height
                });
                _this.processGroupConnect(g, groupId, '', true);
            }
        });
        dagre.layout(g);
        this.groups = this.groups.map(function (group) {
            var groupId = group.id;
            if (g.hasNode(group.id)) {
                var _a = g.node(groupId), x_1 = _a.x, y_1 = _a.y, width_1 = _a.width, height_1 = _a.height;
                var vertexes = group.vertexes.map(function (vertex) {
                    return tslib_1.__assign(tslib_1.__assign({}, vertex), { x: x_1 - width_1 / 2 + vertex.x + vertex.width / 2, y: y_1 - height_1 / 2 + vertex.y + vertex.height / 2 });
                });
                var edges = _this.groupLinkMap.get(groupId) || [];
                edges.forEach(function (edge) {
                    var points = edge.points.map(function (point) {
                        return {
                            x: point.x + (x_1 - width_1 / 2),
                            y: point.y + (y_1 - height_1 / 2)
                        };
                    });
                    nodeLinks.push(tslib_1.__assign(tslib_1.__assign({}, edge), { points: points }));
                });
                return tslib_1.__assign(tslib_1.__assign({}, group), { x: x_1,
                    y: y_1,
                    vertexes: vertexes });
            }
            return tslib_1.__assign(tslib_1.__assign({}, group), { vertexes: group.vertexes.map(function (vertex) {
                    if (g.hasNode(vertex.id)) {
                        var _a = g.node(vertex.id), x = _a.x, y = _a.y;
                        return tslib_1.__assign(tslib_1.__assign({}, vertex), { x: x,
                            y: y });
                    }
                    return vertex;
                }) });
        });
        var nodes = this.groups.reduce(function (pre, cur) {
            if (cur.expand || cur.vertexes.length === 1) {
                return tslib_1.__spread(pre, cur.vertexes);
            }
            return pre;
        }, []);
        this.getGroupNodeMap();
        this.groupLinks = this.groupLinks.map(function (groupLink) {
            var u = groupLink.u, v = groupLink.v;
            var startPoint;
            var endPoint;
            var uGroup = utils_1.find(_this.groups, function (group) { return group.id === u; });
            var vGroup = utils_1.find(_this.groups, function (group) { return group.id === v; });
            var uGroupLink = _this.groupLinks.filter(function (gl) {
                return gl.u === u;
            }).sort(function (glA, glB) {
                var glAGroup = utils_1.find(_this.groups, function (group) { return group.id === glA.v; });
                var glBGroup = utils_1.find(_this.groups, function (group) { return group.id === glB.v; });
                var glAGroupPoint = g.edge({
                    v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,
                    w: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id,
                }).points;
                var glBGroupPoint = g.edge({
                    v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,
                    w: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id,
                }).points;
                if (glAGroupPoint[0].y < glBGroupPoint[0].y) {
                    return -1;
                }
                return 1;
            });
            var uIndex = utils_1.findIndex(uGroupLink, function (link) { return link.v === v; });
            if (uGroup.vertexes.length === 1) {
                var vertex = uGroup.vertexes[0];
                startPoint = {
                    x: vertex.x + vertex.width / 2,
                    y: vertex.y - vertex.height / 2 + ((uIndex + 1) / (uGroupLink.length + 1)) * vertex.height,
                };
            }
            else {
                startPoint = {
                    x: uGroup.x + uGroup.width / 2,
                    y: uGroup.y - uGroup.height / 2 + ((uIndex + 1) / (uGroupLink.length + 1)) * uGroup.height,
                };
            }
            var vGroupLink = _this.groupLinks.filter(function (gl) {
                return gl.v === v;
            }).sort(function (glA, glB) {
                var glAGroup = utils_1.find(_this.groups, function (group) { return group.id === glA.u; });
                var glBGroup = utils_1.find(_this.groups, function (group) { return group.id === glB.u; });
                var glAGroupPoint = g.edge({
                    v: glAGroup.vertexes.length === 1 ? glAGroup.vertexes[0].id : glAGroup.id,
                    w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,
                }).points;
                var glBGroupPoint = g.edge({
                    v: glBGroup.vertexes.length === 1 ? glBGroup.vertexes[0].id : glBGroup.id,
                    w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,
                }).points;
                if (glAGroupPoint[0].y < glBGroupPoint[0].y) {
                    return -1;
                }
                return 1;
            });
            var vIndex = utils_1.findIndex(vGroupLink, function (link) { return link.u === u; });
            if (vGroup.vertexes.length === 1) {
                var vertex = vGroup.vertexes[0];
                endPoint = {
                    x: vertex.x - vertex.width / 2,
                    y: vertex.y - vertex.height / 2 + ((vIndex + 1) / (vGroupLink.length + 1)) * vertex.height,
                };
            }
            else {
                endPoint = {
                    x: vGroup.x - vGroup.width / 2,
                    y: vGroup.y - vGroup.height / 2 + ((vIndex + 1) / (vGroupLink.length + 1)) * vGroup.height,
                };
            }
            var points = g.edge({
                v: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id,
                w: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id,
            }).points;
            var middlePoints = points.slice(1, points.length - 1);
            if (middlePoints.length === 1) {
                middlePoints = [{ x: middlePoints[0].x, y: endPoint.y }];
            }
            return tslib_1.__assign(tslib_1.__assign({}, groupLink), { points: tslib_1.__spread([
                    startPoint,
                    { x: startPoint.x + 10, y: startPoint.y }
                ], middlePoints, [
                    { x: endPoint.x - 20, y: endPoint.y },
                    endPoint
                ]) });
        });
        var groupLinks = [];
        this.links
            .filter(function (link) {
            var uGroup = _this.groupNodeMap.get(link.u);
            var vGroup = _this.groupNodeMap.get(link.v);
            return uGroup.id !== vGroup.id;
        }).forEach(function (link) {
            var u = link.u, v = link.v;
            var uGroup = _this.groupNodeMap.get(u);
            var vGroup = _this.groupNodeMap.get(v);
            var uNode = utils_1.find(nodes, function (node) { return node.id === u; });
            var vNode = utils_1.find(nodes, function (node) { return node.id === v; });
            var groupLink = utils_1.find(_this.groupLinks, function (link) {
                return link.u === uGroup.id && link.v === vGroup.id;
            });
            var startPoint = groupLink.points[0];
            var endPoint = groupLink.points[groupLink.points.length - 1];
            var point_1 = [];
            if (uGroup.expand) {
                point_1 = [
                    { x: uNode.x + uNode.width / 2, y: uNode.y },
                    { x: uNode.x + uNode.width / 2 + 10, y: uNode.y },
                    { x: startPoint.x - 20, y: startPoint.y },
                    startPoint
                ];
            }
            var point_3 = [];
            if (vGroup.expand) {
                point_3 = [
                    endPoint,
                    { x: endPoint.x + 10, y: endPoint.y },
                    { x: vNode.x - vNode.width / 2 - 20, y: vNode.y },
                    { x: vNode.x - vNode.width / 2, y: vNode.y },
                ];
            }
            groupLinks.push(tslib_1.__assign(tslib_1.__assign({}, link), { uGroupId: uGroup.vertexes.length === 1 ? uGroup.vertexes[0].id : uGroup.id, vGroupId: vGroup.vertexes.length === 1 ? vGroup.vertexes[0].id : vGroup.id, groupPoints: [point_1, groupLink.points, point_3] }));
        });
        return {
            nodes: nodes,
            nodeLinks: nodeLinks,
            groupLinks: groupLinks
        };
    };
    GroupGraphLayout.prototype.getTween = function (start, end) {
        var duration = 100;
        var times = Math.floor(duration / 16);
        var paths = [];
        var interval = (end - start) / times;
        for (var i = 0; i <= times; i++) {
            paths.push(start + interval * i);
        }
        return paths;
    };
    GroupGraphLayout.prototype.getAnimationPath = function (pre, current) {
        var preWidth = pre.width;
        var preHeight = pre.height;
        var preX = pre.x;
        var preY = pre.y;
        var currentWidth = current.width;
        var currentHeight = current.height;
        var currentX = current.x;
        var currentY = current.y;
        return {
            widthPath: this.getTween(preWidth, currentWidth),
            heightPath: this.getTween(preHeight, currentHeight),
            xPath: this.getTween(preX, currentX),
            yPath: this.getTween(preY, currentY)
        };
    };
    GroupGraphLayout.prototype.animation = function () {
        var _this = this;
        this.renderNodes = this.renderNodes.map(function (renderNode) {
            var preRenderNode = utils_1.find(_this.preRenderNodes, function (node) { return node.id === renderNode.id; });
            if (preRenderNode) {
                var _a = _this.getAnimationPath(preRenderNode, renderNode), widthPath = _a.widthPath, heightPath = _a.heightPath, xPath = _a.xPath, yPath = _a.yPath;
                return tslib_1.__assign(tslib_1.__assign({}, renderNode), { widthPath: widthPath,
                    heightPath: heightPath,
                    xPath: xPath,
                    yPath: yPath, isMount: false, width: preRenderNode.width, height: preRenderNode.height, x: preRenderNode.x, y: preRenderNode.y, opacity: 1 });
            }
            return tslib_1.__assign(tslib_1.__assign({}, renderNode), { isMount: true, opacity: 0, opacityPath: _this.getTween(0, 1) });
        });
        this.renderGroups = this.renderGroups.map(function (renderGroup) {
            var preRenderGroup = utils_1.find(_this.preRenderGroups, function (group) { return group.id === renderGroup.id; });
            if (preRenderGroup) {
                var _a = _this.getAnimationPath(preRenderGroup, renderGroup), widthPath = _a.widthPath, heightPath = _a.heightPath, xPath = _a.xPath, yPath = _a.yPath;
                return tslib_1.__assign(tslib_1.__assign({}, renderGroup), { widthPath: widthPath,
                    heightPath: heightPath,
                    xPath: xPath,
                    yPath: yPath, isMount: false, width: preRenderGroup.width, height: preRenderGroup.height, x: preRenderGroup.x, y: preRenderGroup.y, opacity: 1 });
            }
            return tslib_1.__assign(tslib_1.__assign({}, renderGroup), { isMount: true, opacity: 0, opacityPath: _this.getTween(0, 1) });
        });
        this.renderNodeLinks = this.renderNodeLinks.map(function (renderNodeLink) {
            var preNodeRenderLink = utils_1.find(_this.renderNodeLinks, function (link) { return link.u === renderNodeLink.u && link.v === renderNodeLink.v; });
            if (preNodeRenderLink) {
                return tslib_1.__assign(tslib_1.__assign({}, renderNodeLink), { isMount: false, opacity: 1 });
            }
            return tslib_1.__assign(tslib_1.__assign({}, renderNodeLink), { isMount: true, opacity: 0, opacityPath: _this.getTween(0, 1) });
        });
        this.renderGroupLinks = this.renderGroupLinks.map(function (renderGroupLink) {
            var preGroupRenderLink = utils_1.find(_this.renderGroupLinks, function (link) { return link.u === renderGroupLink.u && link.v === renderGroupLink.v; });
            if (preGroupRenderLink) {
                return tslib_1.__assign(tslib_1.__assign({}, renderGroupLink), { isMount: false, opacity: 1 });
            }
            return tslib_1.__assign(tslib_1.__assign({}, renderGroupLink), { isMount: true, opacity: 0, opacityPath: _this.getTween(0, 1) });
        });
    };
    GroupGraphLayout.prototype.update = function (nodes, links, groups, groupLinks, config) {
        this.init(nodes, links, groups, groupLinks, config);
    };
    GroupGraphLayout.prototype.layout = function () {
        this.preRenderNodes = this.renderNodes.map(function (node) {
            var isMount = node.isMount, widthPath = node.widthPath, heightPath = node.heightPath, xPath = node.xPath, yPath = node.yPath;
            if (isMount) {
                return node;
            }
            return tslib_1.__assign(tslib_1.__assign({}, node), { width: widthPath[widthPath.length - 1], height: heightPath[heightPath.length - 1], x: xPath[xPath.length - 1], y: yPath[yPath.length - 1] });
        });
        this.preRenderGroups = this.renderGroups.map(function (group) {
            var isMount = group.isMount, widthPath = group.widthPath, heightPath = group.heightPath, xPath = group.xPath, yPath = group.yPath;
            if (isMount) {
                return group;
            }
            return tslib_1.__assign(tslib_1.__assign({}, group), { width: widthPath[widthPath.length - 1], height: heightPath[heightPath.length - 1], x: xPath[xPath.length - 1], y: yPath[yPath.length - 1] });
        });
        this.preRenderNodeLinks = this.renderNodeLinks;
        this.preRenderGroupLinks = this.renderGroupLinks;
        this.getGroupSize();
        var _a = this.groupLayout(), nodeLinks = _a.nodeLinks, nodes = _a.nodes, groupLinks = _a.groupLinks;
        this.renderGroups = this.groups.filter(function (group) {
            return group.vertexes.length !== 1;
        });
        this.renderNodes = this.groups.reduce(function (pre, cur) {
            if (cur.expand || cur.vertexes.length === 1) {
                return tslib_1.__spread(pre, cur.vertexes);
            }
            return pre;
        }, []);
        this.renderNodeLinks = nodeLinks.map(function (link) {
            var u = link.u, v = link.v;
            var uNode = utils_1.find(nodes, function (node) { return node.id === u; });
            var vNode = utils_1.find(nodes, function (node) { return node.id === v; });
            var uLinks = nodeLinks
                .filter(function (link) { return link.u === u; })
                .sort(function (linkA, linkB) {
                var linkAStartPointY = linkA.points[0].y;
                var linkBStartPointY = linkB.points[0].y;
                if (linkAStartPointY < linkBStartPointY) {
                    return -1;
                }
                return 1;
            });
            var uNodeIndex = utils_1.findIndex(uLinks, function (link) { return link.v === v; });
            var startPoint = {
                x: uNode.x + uNode.width / 2,
                y: uNode.y - uNode.height / 2 + ((uNodeIndex + 1) / (uLinks.length + 1)) * uNode.height
            };
            var vLinks = nodeLinks
                .filter(function (link) { return link.v === v; })
                .sort(function (linkA, linkB) {
                var linkAEndPointY = linkA.points[linkA.points.length - 1].y;
                var linkBEndPointY = linkB.points[linkB.points.length - 1].y;
                if (linkAEndPointY < linkBEndPointY) {
                    return -1;
                }
                return 1;
            });
            var vNodeIndex = utils_1.findIndex(vLinks, function (link) { return link.u === u; });
            var endPoint = {
                x: vNode.x - vNode.width / 2,
                y: vNode.y - vNode.height / 2 + ((vNodeIndex + 1) / (vLinks.length + 1)) * vNode.height
            };
            var points = tslib_1.__spread([
                startPoint,
                { x: startPoint.x + 10, y: startPoint.y }
            ], link.points.slice(1, link.points.length - 1), [
                { x: endPoint.x - 20, y: endPoint.y },
                endPoint
            ]);
            return tslib_1.__assign(tslib_1.__assign({}, link), { points: points });
        });
        this.renderGroupLinks = groupLinks;
        this.animation();
        return {
            renderGroups: this.renderGroups,
            renderNodes: this.renderNodes,
            renderNodeLinks: this.renderNodeLinks,
            renderGroupLinks: this.renderGroupLinks,
        };
    };
    return GroupGraphLayout;
}(base_1.BaseGroupLayout));
exports.GroupGraphLayout = GroupGraphLayout;
//# sourceMappingURL=dagre.js.map