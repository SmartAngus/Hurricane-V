"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var define_1 = require("./define");
exports.Matrix = define_1.Matrix;
exports.LinkInfo = define_1.LinkInfo;
var graph_1 = require("../../Utils/graph");
var _ = require("lodash");
function calcRadius(maxRadius, maxSize, minSize) {
    if (maxSize === minSize) {
        return function () {
            return maxRadius;
        };
    }
    var minRadius = maxRadius * 0.7;
    var k = (maxSize - minSize) / (maxRadius - minRadius);
    var b = minSize - minRadius * k;
    return function (size) {
        return (size - b) / k;
    };
}
;
function randomNumber(start, end) {
    return Math.random() * (end - start) + start;
}
;
var defaultProps = (function () {
    function defaultProps() {
    }
    return defaultProps;
}());
var Bubble = (function () {
    function Bubble(_a) {
        var data = _a.data, width = _a.width, height = _a.height, rowCount = _a.rowCount, minSize = _a.minSize, maxSize = _a.maxSize;
        this.matrix = [];
        this.matrixRows = [];
        this.matrixColumns = [];
        this.edges = [];
        this.init(data, width, height, rowCount, maxSize, minSize);
    }
    Bubble.prototype.init = function (data, width, height, rowCount, maxSize, minSize) {
        this.data = data;
        this.rowCount = rowCount;
        this.maxSize = maxSize;
        this.minSize = minSize;
        this.columnCount = Math.ceil((data || []).length / rowCount);
        this.heightInterval = height / rowCount;
        this.widthInterval = width / this.columnCount;
        for (var i = 0; i < rowCount; i++) {
            this.matrixRows.push({ l: i * this.heightInterval, r: (i + 1) * this.heightInterval });
        }
        for (var i = 0; i < this.columnCount; i++) {
            this.matrixColumns.push({ l: i * this.widthInterval, r: (i + 1) * this.widthInterval });
        }
    };
    Bubble.prototype.getNodes = function () {
        var radiusF = calcRadius(_.min([this.heightInterval / 2, this.widthInterval / 2]) * 0.9, this.maxSize, this.minSize);
        var nodes = (this.data || []).map(function (node) {
            var radius = radiusF(node.value);
            return {
                id: String(node.id),
                name: node.name,
                value: node.value,
                radius: radius
            };
        });
        var allCount = this.rowCount * this.columnCount;
        var countList = Object.keys(Array.from({ length: allCount }))
            .map(function (item) {
            return +item;
        })
            .sort(function (a, b) {
            return Math.random() > 0.5 ? -1 : 1;
        });
        var matrix = [];
        for (var i = 0; i < nodes.length; i++) {
            var rowIndex = Math.floor(countList[i] / this.columnCount);
            var columnIndex = countList[i] % this.columnCount;
            var radius = nodes[i].radius;
            var randomX = randomNumber(this.matrixColumns[columnIndex].l + radius, this.matrixColumns[columnIndex].r - radius);
            var randomY = randomNumber(this.matrixRows[rowIndex].l + radius, this.matrixRows[rowIndex].r - radius);
            matrix.push({
                node: nodes[i],
                rowIndex: rowIndex,
                columnIndex: columnIndex,
                widthRange: this.matrixColumns[columnIndex],
                heightRange: this.matrixRows[rowIndex],
                center: {
                    x: randomX,
                    y: randomY
                },
                radius: radius
            });
        }
        this.matrix = matrix;
        return matrix;
    };
    Bubble.prototype.getLinks = function () {
        var _this = this;
        var dupliEdges = _.flatten((this.data || []).map(function (edge) {
            return (edge.siblings || []).map(function (end) { return ({
                u: String(edge.id),
                v: String(end.id),
                bothway: false
            }); });
        }));
        dupliEdges.forEach(function (item) {
            var edge = _.find(_this.edges, function (o) { return o.u === item.v && o.v === item.u; });
            if (!edge) {
                _this.edges.push(item);
            }
            else {
                edge.bothway = true;
            }
        });
        var link = [];
        this.edges.forEach(function (edge) {
            var u = edge.u, v = edge.v, bothway = edge.bothway;
            var startNode = _.find(_this.matrix, function (item) {
                return String(item.node.id) === String(u);
            });
            var initStartPoint = startNode.center;
            var endNode = _.find(_this.matrix, function (item) {
                return String(item.node.id) === String(v);
            });
            var initEndPoint = endNode.center;
            var initControlPoint = graph_1.getControlPoint(initStartPoint, initEndPoint, 0.2, 1);
            var startDis = graph_1.distance(initStartPoint, initControlPoint);
            var startPoint = {
                x: initStartPoint.x + (initControlPoint.x - initStartPoint.x) * (startNode.radius / startDis),
                y: initStartPoint.y + (initControlPoint.y - initStartPoint.y) * (startNode.radius / startDis)
            };
            var endDis = graph_1.distance(initControlPoint, initEndPoint);
            var endPoint = {
                x: initEndPoint.x + (initControlPoint.x - initEndPoint.x) * (endNode.radius / endDis),
                y: initEndPoint.y + (initControlPoint.y - initEndPoint.y) * (endNode.radius / endDis)
            };
            var linkInfo = {
                start: startPoint,
                end: endPoint,
                control: graph_1.getControlPoint(startPoint, endPoint, 0.15, 1),
                u: u,
                v: v,
                bothway: bothway
            };
            link.push(linkInfo);
        });
        return link;
    };
    Bubble.prototype.graph = function () {
        var nodes = this.getNodes();
        var links = this.getLinks();
        return {
            nodes: nodes,
            links: links
        };
    };
    return Bubble;
}());
exports.Bubble = Bubble;
//# sourceMappingURL=index.js.map